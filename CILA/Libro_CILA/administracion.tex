%Autor: faraox & ese

\chapter{Administración básica}

\section{Paquetes}

Un paquetes es un archivo que contiene varios ficheros que permiten la
instalación de un programa. En linux existen varios tipos de paquetes,
los más  conocidos son los *.rpm,  el tipo de paquetes  que fue creada
por Red Hat  y que utilizan todas las dristribuciones  que se basan en
ellas, *.deb,  que fue  creada por  el grupo  Debian, y  los tarballs,
estos  son ficheros  comprimidos que  contienen el  código fuente  del
programa y pueden instalarse en cualquier distribución.

Una parte importante  de un sistema de paquetes  son las dependencias.
Cada  paquete  necesita que  esten  instalados  en el  sistemas  otros
paquetes  que  son  necesariospara  su  funcionamiento,  los  paquetes
necesarios para  su instalación  se llaman dependencias.  Esto permite
dar estabilidad y fiabilidad al sistema GNU/Linux.

% Continuar con lo de dependencias.

\subsection{Sistema de Paquetes Deb}

Todos los paquetes deb tienen el siguiente formato:
{\tt nombre-del-paquete\_version(1.3.34-5).deb}  

La distribución Debian tiene  diversas utilidades para la instalaciónn
de  paquetes,  entre ellas,  el  APT,  que  permie la  instalación  de
paquetes de  forma fácil y  rápida, advirtiendo de las  dependencias y
recomendando  paquetes. El  sistema APT  engloba varios  comandos como
apt-get, apt-cache, apt-cdrom,...

\subsection{El fichero /etc/apt/sources.list}

Este fichero es impresindible para la instalación de paquetes con APT.
En el se guardan las direcciones  de donde la utilidad apt se descarga
los paquetes. Los medios por los  que se pueden descargar los paquetes
son  varios: file(podemos  elegir  un directorio  albitrario de  donde
bajarnos los  paquetes, esto es  útil para mirrors locales  o carpetas
NTFS),de un  cdrom,de un servidor  web(http), de un ftp,  por rsh/ssh.
Vamos a ver un ejemplo:

\begin{verbatim}
deb http://http.us.debian.org/debian woody main contrib non-free
deb http://non-us.debian.org/debian-non-US woody/non-US main contrib non-free
deb-src http://http.us.debian.org/debian woody main contrib non-free
\end{verbatim}

La  diferencia entre  {\tt  deb} y  {\tt deb-src}  es  que el  primero
indica  la descarga  de paquetes  .deb,  mientras que  con el  segundo
podemos descargarnos  el código  fuente del paquete(usando  el comando
apt-get  source). La  siguiente parte  de la  línea es  el {\tt  URI},
es  decir,  el  tipo  de  sistema para  la  descarga,  recordemos  que
existen  varios(file,cdrom,ftp,http,rsh/ssh). En  este caso  es de  un
servidor  web.  Seguidamente  escribimos  la  {\tt  localización}  del
mirror  de paquetes,  este caso  tenemos varias  líneas con  diferente
localización,  esto  es  debido  a  que  en  USA  es  ilegal  utilizar
aplicaciones de  encriptación, por lo  que para bajar  esos programas,
existen líneas especiales que contienen  la palabra non-US. Despues de
la localización, separado  por un espacio, se escribe  la {\tt version
de debian}, es válido tanto el alias  de la version como en qué estado
se encuentra  (stable, unstable,testing).  Por último se  escriben las
{\tt  secciones de  software} que  usaremos(main, contrib,  non-free).
Debian organiza los paquetes en  varias carpetas segun su licencia. La
sección {\tt main}  agrupa los paquetes en los que  su licencia cumple
con los criterios de la  DGFS(``Guías de Debian del Software libre'').
La sección {\tt contrib} agrupa  paquetes que tiene una licencia libre
pero que sin embargo dependen de  otros paquetes que no cumple con las
normas del  DGFS. Y  por último, la  sección {\tt  non-free} contienen
paquetes que son de libre distribución pero que sin embargo no cumplen
las  directrices de  la DGFS(no  distribuye el  código, no  se permite
redistribuir el código,etc).


\subsection{Apt-get}

El comando {\bf  apt-get} se utiliza para la  manipulación de paquetes
deb. Permite la instalación de paquetes, borrado, \dots

%probar ha hacer tabla 

\begin{table}[htbp]
\centering
\begin{tabular}{|c|p{0.88\textwidh}|}
\hline
{\tt apt-get install paquete1 paquete2 ...} & Instala paquetes \\
{\tt apt-get remove paquete1 paquete2 ...} & Borra paquetes \\
{\tt apt-get source paquete1 paquete2 ...} & Descarga el código fuente de los paquetes \\
{\tt apt-get update } & Actualiza la lista de paquetes disponibles para instalar \\
{\tt apt-get upgrade } & Instala las nuevas  versiones de los diferentes paquetes disponibles \\
{\tt apt-get dist-upgrade} & Funcion adicional de la opción upgrade que modifica las dependencias por la de las nuevas versiones de los paquete \\
{\tt apt-get build-dep paquete1 paquete2 ...} & Instala los paquetes necesarios para la compilación del código fuente de los paquetes.\\
{\tt apt-get clean} & Elimina los ficheros que se encuentran en /var/cache/apt/archives y /var/cache/apt/archives/partial. Ahí se encuentran los paquetes que hemos descargado para instalar.
\hline
\end{tabular}
\caption{Opciones principales de apt-get}
\end{table}

\begin{table}[htbp]
\centering
\begin{tabular}{|c|p{0.88\textwidth}|}
\hline
{\tt -d,--download-only} & Solo descarga el paquete, no lo instala \\
{\tt -f,--fix-broken} & Esta opción es imporatante, intenta arreglar problemas de dependencias que tengamos en el sistema\\
{\tt -s,--simulate} & Nos muestra los resultados de la instalación de un paquete\\
{\tt -b,--build} & Compila el paquete de código fuente que hayamos bajado\\
\hline
\end{tabular}
\caption{Otras opciones del apt-get}
\end{table}

\subsection{Apt-cache}

El comando apt-cache trabaja con la  cache de los paquetes. El comando
no manipula  el estado  del sistema,  por lo que  puede ser  usado por
usuarios normales. Es  un comando de gran utilidad ya  que nos muestra
información valiosa sobre los paquetes.

Algunas opciones más importantes:

\begin{itemize}

\item apt-cache show paquete1: Este comando muestra la cabezera de los
paquetes.  Muestra  el  desarrollador,  las  dependencias,  una  breve
descripción  del mismo,  su tamaño,  el  nombre del  fichero donde  se
encuentra, entre otros.

\item apt-cache search texto: Muestra una lista de todos los paquete y
una breve descripción relacionado con el texto que hemos buscado.

\item  apt-cache depends  paquete: Muestra  las dependencias  de dicho
paquete.

\item apt-cache stats: Muestra la estadística de el cache.

\end{itemize}

\subsection{El fichero {\tt /etc/apt/apt.conf}}

El fichero apt.conf sirve para la configuración por defecto de APT. En
el  fichero podemos  por  ejemplo darle  las órdenes  al  APT para  la
utilización de un  proxy. Podemos encontrar un ejemplo  del fichero en
{\tt /usr/share/doc/apt/examples/configure-index.gz}

\subsection{Apt-cdrom}

El comando apt-cdrom permite añadir nuevos cdrom al sources.list. Para
añadir un cdrom la orden es {\tt apt-cdrom add}


\section{Los procesos}

Un  proceso es  cualquier comando  que se  está ejecutando  en nuestro
sistema. Todo proceso  tiene un PID, un número que  le identifica y le
diferencia de todos los demás.  Una característa importate es que todo
proceso tiene un estado: corriendo, durmiendo, zombie o parado.

\subsection{El comando kill}

El  comando  kill  nos  permiter  interactuar  con  cualquier  proceso
mandando  señales(signal). Cuando  ejecutamos {\tt kill  pid} lo  que
hacemos es  mandar la señal de  TERM(terminar) con lo cual  se termina
ese  proceso. Podemos  usar cualquier  otro tipo  de señal,  para ello
utilizamos  {\tt kill signal  pid}.  Podemos conseguir  una lista  de
señales usando {\tt kill -l}. Una señal útil para alunas ocasiones es
{\tt -9}, esta señal fuerza a terminarl cualquier proceso.

También podemos utilizar el comando  {\tt killall} con el que podemos
mandar señales a un proceso utilizando el nombre, en vez del PID.

Entre los procesos diferenciamos los que  se estan ejecuntando en 1º o
2º plano.  Los que se ejutan  en primer plano son  los que interactúan
con el  usuario en ese momento,  mientras que los procesos  en segundo
plano se ejecutan pero están ocultos.

Solo puede haber un proceso en  primer plano por consola. Eso nos deja
las  manos atadas  si no  estamos en  el entorno  gráfico. Para  poder
ejecutar  varios  comandos,  lo  que podemos  hacer  es  ejecutar  los
comandos en segundo plano. Para  ello solo tenemos que añadir \verb.&.
al final del comando. Vamos a poner un ejemplo:

\begin{verbatim}
$ls -R / > /dev/null &
\end{verbatim}

En  el anterior  ejemplo  listamos  todos los  ficheros  de todos  los
directorios del  sistema. Enviamos la  salida a /dev/null para  que su
salida no nos moleste. El carácter \verb.&. manda el proceso a segundo
plano.

El comando {\tt jobs} nos muestra los procesos que se están ejecutando
en segundo plano:

\begin{verbatim}
$ls
[1]+  Running                 ls --color -R / >/dev/null &
\end{verbatim}

Aquí vemos  que estamos  ejecutando el  comando anterior.  El elemento
{\tt [1]} nos  indica el número del proceso que  se está ejecutando en
segundo  plano  y cual  es  su  estado,  en  este caso  {\tt  Running}
(corriendo).  Seguidamente nos  muestra  cual es  el proceso.  Podemos
utilizar también el comando {\tt fg}  para mandar un proceso al primer
plano y el comando {\tt bg} para mandar el proceso a segundo plano.

\begin{verbatim}
$fg
ls --color -R / >/dev/null
\end{verbatim}

{\tt fg} manda el proceso a primer plano y nos muestra el programa que
ha mandado.  Sí tenemos varios  procesos en segundo plano  añadimos el
número del proceso.

El comando  {\tt bg}  se utiliza cuando  tenemos por  ejemplo procesos
suspendidos.  Los   procesos  suspendidos  son  programas   que  estan
``parados'', es  decir, no consumen ni  CPU ni memoria, y  que podemos
volver  a poner  en marcha  en  cualquier momento.  Para suspender  un
proceso utilizamos  la combinación de  teclas {\tt C-z}, al  igual que
para interrurmpir un proceso utilizamos {\tt C-c}.

\begin{verbatim}
$jobs
[1]+  Stopped                 ls --color -R / >/dev/null
\end{verbatim}

Esta tarea está parada(Stopped).

\subsection{El comando ps}

El  comando {\tt  ps} permite  mostrar  todos los  procesos que  están
corriendo  en nuestro  sistema. Veamos  una  parte de  una salide  del
coamndo ps:

\begin{verbatim}
$ps -aux
faraox@menut:~/doc/glup_0.6-1.1-html-1.1$ ps xau
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.2  1272  436 ?        S    16:00   0:04 init [2] 
root         2  0.0  0.0     0    0 ?        SW   16:00   0:01 [keventd]
root         3  0.0  0.0     0    0 ?        SW   16:00   0:00 [kapmd]
root         4  0.0  0.0     0    0 ?        SWN  16:00   0:00 [ksoftirqd_CPU0]
faraox     613  0.0 15.4 46636 28308 ?       S    17:22   0:00 /usr/bin/galeon-bin
faraox    1360  0.0  2.0  6416 3728 ?        S    18:57   0:00 Eterm -F -misc-fixed-mediu
faraox    1363  0.0  0.8  2740 1564 pts/2    S    18:57   0:00 -bash
\end{verbatim}

Los parámetros  xau nos permiten ver  todos los procesos que  se están
ejecutando. El parámetro {\tt a} muestra lo que se está ejecutando en
las tty conocidas, el parámetro {\tt x}  añade los procesos que no se
conece la  tty en la  que se están  ejecutando y {\tt u}  muestra los
usuarios que están ejecutando esos procesos.

Algunas partes  de la salida  le serán conocidas. La  columna ``USER''
nos dice que  usuario está ejecutando el proceso,``PID''  es su número
de proceso, ``\%CPU''  es el porcentaje de CPU que  está utilizando al
igual que  ``\%MEM'' es el  porcentaje de memoria. También  incluye la
cantidad de  memoria en kylobytes  que ha utilizado dicho  proceso, se
muestra en  la columan ``RSS''.La  columna ``TTY'' muestra  la consola
desde  la que  se  está  ejecutando. ``STAT''  nos  muestra el  estado
del proceso:S(drmiendo),R(corriendo),T(parado),Z(zombie). Las opciones
``W''  y ``N''  son especiales  para procesos  del kernel.  La columna
``START'' muestra  la hora a  la que empezó  el proceso, y  la columna
``TIME'' muestra el tiempo de CPU que ha usado el proceso desde que se
inicio  y  ``COMMAND'' muestra  el  nombre  del  comando que  se  está
ejecutando.

\subsection{El comando top}

El comando  top es una utilidad  que permite la monitorización  de los
procesos de  la CPU. También muestra  el estado de la  memoria. Es una
mezcla del comando uptime, free y ps.

\begin{verbatim}
20:07:54 up  4:07,  5 users,  load average: 0.07, 0.05, 0.05
60 processes: 58 sleeping, 1 running, 0 zombie, 1 stopped
CPU states:   0.4% user,   0.6% system,   0.0% nice,  99.0% idle
Mem:    182900K total,   172404K used,    10496K free,    35064K buffers
Swap:    96352K total,    14284K used,    82068K free,    43228K cached

PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
1565 faraox    14   0  1040 1040   820 R     0.5  0.5   0:00 top
300 root       9 -10 24736 9.9M  1524 S <   0.1  5.5   2:47 XFree86
1541 faraox    10   0  3148 3148  2184 S     0.1  1.7   0:00 Eterm
1 root       8   0   480  436   416 S     0.0  0.2   0:04 init
\end{verbatim}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|p{0.88\textwidh}|}
\hline
{\tt espacio} & Actualiza la pantalla \\
{\tt Ctrol + L} & Borra y reescribe la pantalla \\
{\tt k} & Mata un proceso(kill) \\
{\tt r} & Cambia la prioridad de cualquier proceso \\
{\tt s} & Cambia el intervalo de refresco(por defecto es cada 5 segundos) \\
{\tt o} & Cambia el orden de los elementos \\
{\tt N} & Ordenar procesos por PID \\
{\tt P} & Mostrar procesos por el uso de la CPU(por defecto)\\
{\tt M} & Mostrar procesos por el uso de memoria \\
{\tt T} & Mostrar procesos por tiempo \\
{\tt W} & Guarda la configuración  en ~/.toprc\\
\hline
\end{tabular}
\caption{Teclas para la interactuación con el top}
\end{table}

\subsection*{Nice:prioridad en procesos}

Una CPU tiene que comprartir su tiempo de cálculo con varios procesos.
{\tt  Nice} es  un programa  que permite  cambiar la  prioridad de  un
proceso en  nuestro sistema. La prioridad  tiene un rango desde  -20 a
20.  Un usuario  normal  tiene prioridad  0  cuando ejecuta  cualquier
comando desde la consola. Con el comando nice, ese usuario normal solo
puede  bajar la  prioridad del  proceso, nunca  subirlo, solo  root es
capaz de ello.

El esquema de utilización sería: {nice -n prioridad comando} o también
podemos utilizar el  comando {\tt rnice} para cambiar  la prioridad de
un proceso: {\tt renice prioridad PID}

\section{Los servicios en debian}

Los servicios o demonios son  procesos que se ejecutan automáticamente
al  arrancar  el  sistema  o  al llamarlos  y  que  esperan  cualquier
petición.  Es el  caso por  ejemplo de  Apache, Qmail,  SSH, etc.  Los
servicios normalmente se  inician al iniciar el  sistema, pero podemos
iniciarlo(start),  pararlo(stop)  o  reiniciandolo,  sería  así:  {\tt
/etc/init.d/servicio opción}.

Para  que el  servicio  no  se inicie  cuando  arrancamos el  sistema,
podemos usar el comando update-rc.d. Este comando lo que hace es crear
enlaces  a los  diferentes directorios  de runlevels.  Para que  no se
inicie  automáticamente: {\tt  update-rc.d -f  servicio remove}.  Para
añadir un servicio, simplemente creamos  el script de nuestro servicio
en Bourne  Shell Script y  lo copiamos al directorio  /etc/init.d/. Si
queremos que  se inicie  automáticamente al arrancar  escribimos: {\tt
update-rc.d servicio defaults}


\section{Los archivos de registro }

Los ficheros de registro(logging files)  se almecenan los resultados e
información  util  de algunos  programas.  Estos  son muy  importantes
para  conocer el  estado de  nuestra máquina.  Los ficheros  log's más
importantes se encuentran en la carpeta {\tt /var/log/}. Normalmente,
los ficheros log se pueden visualizar con cualquier editor de texto ya
que están guardados en un fichero ASCII.

\begin{itemize}

\item El  fichero syslog.  El fichero  syslog es  el resultado  de los
mensajes  de el  demonio Syslogd.  Este de  demonio se  encarga de  la
organización de los mensajes del kernel,  es por eso que en el fichero
syslog podemos  enontrar toda  la información sobre  lo que  ocurre en
nuestra máquina.

\item El  fichero messages. Este  fichero es  igual al syslog,  lo que
muestra información más simple. En el podemos controlar por ejemplo la
información del demonio pppd.

\item  Los ficheros  \verb+~/.bash\_history+. Estos  ficheros muestran
los  comandos  que han  sido  ejecutados  por  los usuarios  desde  la
consola.

\item El fichero  wtmp. En el hay un listado  de todas las conecciones
que ha  tenido la máquinamientras  ha permanecido encendida.  Se puede
visulizar con el comando last.

\end{itemsize}


Normalmente  cada  demonio  tiene  un fichero  de  registro  así  como
muchos  programas   también  lo   tienen.  Solo   hay  que   mirar  la
documentación. Los log's  de nuestro servidor de  correo se encuentran
en  /var/log/mail.log,  así  como  los del  Apache  se  encuentran  en
/var/log/apache,etc.

\section{Otras utilidades para la administración}

\subsection*{uptime}

El comando {\tt uptime} nos indica  el tiempo que ha estado corriendo
la máquina.

\begin{verbatim}
$ uptime
17:56:33 up  1:55,  8 users,  load average: 0.05, 0.01, 0.01
\end{verbatim}

El primer elemento  es la hora actual. El  siguiente elemento, seguido
de  la palabra  ''up'' es  el tiempo  que la  máquina está  encendida.
Seguidamente  nombra el  número de  usuarios que  se encuentran  en el
sistema. Por  último muestra  la carga  media de  la máquina,  en tres
tiempos, 1,5 y 15 minutos.

\subsection*{w}

Muestra  los usuarios  que  se  encuentran en  el  sistema. Veamos  un
ejemplo:

\begin{verbatim}
$w
18:00:59 up  2:00,  8 users,  load average: 0.01, 0.02, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
faraox   tty1     -                16:01    1:58m  2.69s  0.00s  /bin/sh /usr/bin/X11/star
faraox   pts/0    :0.0             16:02    9.00s 40.22s 40.16s  vi administracion.tex 
\end{verbatim}

La primera  línea que muestra  el comando {\tt w}  es la salida  de el
comando  {\tt uptime}.  Por orden,  la información  que muestra  es el
nombre de usuario,  la consola desde donde ha entrado,  desde donde se
conecta, la  hora de entrada, el  idle, el tiempo usado  por todos los
procesos  de  esa  consola(tty),  el tiempo  usado  por  los  procesos
actuales y lo que está haciendo el usuario.

\subsection*{free}

El  comando {\tt  free}  muestra  información sobre  el  estado de  la
memoria del  sistema. Muestran  tanto el estado  de la  memoria física
como de  la swap. También muestra  el buffer utilizado por  el kernel.
Una salida del comando {\tt free}

\begin{verbatim}
$free
	     total       used       free     shared    buffers     cached
Mem:        182900     173300       9600          0      11796      66588
-/+ buffers/cache:      94916      87984
Swap:        96352        448      95904
\end{verbatim}

Este comando lee la información del fichero /proc/meninfo.

\subsection*{dmesg}

Este comando  muestra los  mensajes del kernel  durante el  inicio del
sistema.

