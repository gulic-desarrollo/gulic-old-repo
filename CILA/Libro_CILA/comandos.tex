%Autor: _ese
\chapter{El intérprete de comandos}
\index{comandos, intérprete}
\section{¿Qué es un intérprete de comandos?}

Si  bien  manejarse en  Linux  es  cada vez  más  fácil,  debido a  la
proliferación  de escritorios,  los  comienzos no  siempre fueron  así
de  fáciles. De  hecho,  puede  ocurrir que  nos  encontremos con  una
emergencia  en el  que  no  nos quede  más  remedio  que trabajar  con
comandos.

Un intérprete  de comandos tiene el  aspecto de una pantalla  llena de
letras, generalmente  con fondo negro  y letras  blancas, y que  en la
última línea inferior, se suele ver lo siguiente:

\begin{verbatim}
[felix@localhost Comandos]$
\end{verbatim}

En  este entorno  es donde  introduciremos  los comandos  con los  que
trabajaremos, y  coloquialmente diremos que estamos  trabajando en una
consola. Estos comandos pueden ser de diferentes clases:

\begin{itemize}
\item Programas ejecutables.
\item Scripts del intérprete.
\item Scripts de lenguajes de script como Python, Perl, Tcl, etc.
\item Macros del intérprete.
\end{itemize}

Todos  tienen en  común que  son ficheros:  al cargar  un programa  en
Linux, se ordena al intérprete que busque el fichero con el nombre del
programa y  una vez  encontrado, lo  ejecute, si  éste da  permisos de
ejecución al usuario.

Los comandos tienen el siguiente aspecto:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk
[felix@localhost Comandos]$ lsmod
[felix@localhost Comandos]$ ls
\end{verbatim}

También funcionan con opciones:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk -v
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
\end{verbatim}

Y con parámetros:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk /dev/hda
[felix@localhost Comandos]$ ls /tmp
[felix@localhost Comandos]$ ls *.txt
\end{verbatim}

Con opciones y parámetros:

\begin{verbatim}
[felix@localhost Comandos]$ rpm -qpl joe-1.0.3.rpm
[felix@localhost Comandos]$ gcc -o suma suma.c
[felix@localhost Comandos]$ ls -al /tmp
\end{verbatim}

Al  ser Linux  un sistema  {\tt multitarea}  y {\tt  multiusuario}, se
aportan  ventajas que  se  agradecen  incluso en  un  sistema PC  {\tt
monousuario}. Una de estas ventajas es  que se puede trabajar con seis
consolas  virtuales, que  es como  si pudiéramos  trabajar con  varias
sesiones  simultáneas, entendiendo  por  sesión el  tiempo de  trabajo
desde que  el usuario entra  tras identificarse  en el {\tt  login} de
entrada hasta que abandona el  sistema. Lo que significa realmente que
el mismo usuario puede entrar varias veces al mismo tiempo.

Para alternar  entre estas  consolas virtuales,  basta con  pulsar las
cobinaciones de la teclas {\bf Alt + F1} a {\bf Alt + F6}

Si se quiere acceder a una  consola desde un entorno gráfico, entonces
se pulsan las combinaciones {\bf Ctrl + Alt  + F1} a {\bf Ctrl + Alt +
F6}

\section{Directorios y nombres de ficheros}

\subsection{Trabajando con directorios.}
\index{Directorio}

Toda  la  información  (ya  sean  textos,  imágenes,  bases  de  datos
o  información  para la  configuración  del  sistema) se  almacena  en
``ficheros'', que  a su vez  se guardan en ``directorios''.  Con todas
las  herramientas y  programas  existentes se  puede  acceder a  estos
ficheros para ver su contenido o modificarlo.

A diferencia del los sistemas  MS-DOS/Windows, en los sistemas UNIX no
se dividen los  directorios entre las distintas  unidades físicas (C:,
D:, etc.). Al  contrario, para UNIX todos son  ficheros y directorios.
Éste  considerará un  disco duro,  un  scanner o  una disquetera  como
directorios.  Por  tanto, no  tiene  sentido  escribir en  la  consola
``C:'', sino que nos iremos al directorio asociado a esa partición que
para MS-DOS es ``C:''.

Todos los  ficheros y  directorios de  un sistema  UNIX cuelgan  de un
directorio principal llamado ``raíz'', que se representa como ``/''.

Hay que  destacar que  cuando el  usuario accede  a una  sesión, Linux
``envía'' al usuario a su directorio de trabajo. Es decir, si yo entro
como el usuario {\tt felix}, en  el momento de entrar me encontraré en
el directorio {\tt /home/felix}. Éste  será mi directorio personal, en
donde  tengo  libertad absoluta  para  hacer  lo  que quiera  con  mis
ficheros y directorios  ubicados ahí. Sin embargo no  podré hacer todo
lo que quiera en el directorio  {\tt /home/miguel}. ¿Por qué? Pues por
la  sencilla razón  de  que Linux  tiene un  sistema  de permisos  que
concede o  restringe libertades sobre  los directorios y  ficheros que
hay en Linux. ¿Significa eso que  puede existir un usuario ``dios'' en
Linux que puede  hacer totalmente cualquier cosa en Linux?  Sí, ése es
el usuario {\tt root}. Sin embargo, para los propósitos de este curso,
sólo nos remitiremos a la cuenta de trabajo del propio lector ;-)

¿Cómo sé  yo en  qué directorio  me encuentro?  Basta con  escribir el
comando {\tt pwd} (Print Work Directory).
\index{Directorio!pwd}
\begin{verbatim}
[felix@localhost felix]$ pwd
/home/felix/
\end{verbatim}

Y la salida que obtendré es:

\begin{verbatim}
/home/felix
\end{verbatim}

Para cambiar de directorio,  emplearemos el comando {\tt cd}
(Change Directory)
\index{Directorio!cd}

\begin{verbatim}
[felix@localhost Comandos]$ cd /etc
\end{verbatim}

Es decir, nos vamos al directorio {\tt /etc}

Si  simplemente escribimos  {\tt  cd} sin  especificar  el nombre  del
directorio, esto será  igual que escribir {\tt cd  /home/felix} o {\tt
cd}, es decir, me manda a {\bf mi propio directorio de trabajo} (que es
como irse a casa).

¿Cómo veo los ficheros y directorios de un directorio? Escribimos {\tt
ls Nombre del directorio}.
\index{Directorio!ls}

\begin{verbatim}
[felix@localhost apuntes]$ ls /home/felix/apuntes/apuntes/
Apuntes_CILA_2001.dvi   CVS/    introduccion.sgml  programando.sgml
 xwindow.sgml
Apuntes_CILA_2001.sgml  editores.sgml  LEEME             recursos.sgml
cabecera.sgml           final.sgml     Makefile
 resumen_temario.txt
comandos.sgml           graficos.sgml  matematicas.sgml  sobre.sgml
compila*                internet.sgml  presentacion.sgml temario.estado
\end{verbatim}

Si escribimos {\tt ls} (a secas) entonces se nos mostrará el contenido
del directorio en el que nos encontramos actualmente.

El comando {\tt ls} admite parámetros tales como {\tt -a, -l}

\begin{verbatim}
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
[felix@localhost Comandos]$ ls -la
\end{verbatim}

Obsérvese que ambas  formas de escribir los  parámetros son igualmente
válidas.  Como anotación,  si queremos  ver que  parámetros se  pueden
utilizar en un comando, normalmente basta con escribir {\tt Nombre del
comando --help}.

\begin{verbatim}
[felix@localhost apuntes]$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
Muestra información acerca de los FICHEROs (del directorio actual por defecto).
Ordena las entradas alfabéticamente si no se especifica ninguna de las
opciones -cftuSUX ni --sort.

Los argumentos obligatorios para las opciones largas son también obligatorios
para las opciones cortas
  -a, --all                  do not hide entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               print the author of each file
  -b, --escape               print octal escapes for nongraphic characters
      --block-size=TAMAÑO    utiliza bloques de TAMAÑO bytes
  -B, --ignore-backups       no muestra la entradas que terminan con ~
  -c                         con -lt: ordena por ctime y muestra ctime (fecha
                               de última modificación del fichero)
                               con -l: muestra ctime y ordena por nombre
                               en cualquier otro caso: ordena por ctime
  -C                         muestra las entradas por columnas
      --color[=CUÁNDO]       especifica si se usará color para distinguir los
                               tipos de ficheros. CUÁNDO puede ser `never',
                               `always' o `auto'
  -d, --directory            muestra las entradas de los directorios en lugar
                             de sus contenidos
  -D, --dired                genera el resultado para el modo `dired' de Emacs
  -f                         no ordena, utiliza -aU, no utiliza -lst
  -F, --classify             añade un indicador (uno de */=@|) a las entradas
      --format=PALABRA       across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            como -l --time-style=full-iso
  -g                         como -l, pero no muestra el propietario
  -G, --no-group             no muestra la información del grupo
  -h, --human-readable       muestra los tamaños de forma legible
                             (p.e. 1K 234M 2G)
      --si                   análogo, pero utilizando potencias de 1000,
                             no de 1024
  -H, --dereference-command-line  sigue los enlaces simbólicos en la línea de
                                  órdenes
      --indicator-style=PALABRA  añade un indicador con estilo PALABRA a los
                                 nombres de las entradas: none (predeterminado),
                                 classify (-F), file-type (-p)
  -i, --inode                muestra el número de nodo-i de cada fichero
  -I, --ignore=PATRÓN        no lista las entradas que coincidan (encajen)
                             con PATRÓN de shell
  -k                         como --block-size=1K
  -l                         utiliza un formato de listado largo
  -L, --dereference          al mostrar la información de un fichero para un
                               enlace simbólico, muestra la información del
                               fichero al que apunta el enlace en lugar de la
                               del propio enlace
  -m                         rellena el ancho con una lista de entradas
                             separadas por comas
  -n, --numeric-uid-gid      como -l, pero muestra los UIDs y GIDs numéricos
  -N, --literal              muestra los nombres literalmente (no trata p.ej.
                             los caracteres de control de forma especial)
  -o                         como -l, pero no muestra el grupo
  -p  --file-type            añade un indicador (uno de /=@|) a las entradas
  -q, --hide-control-chars   imprime ? en lugar de los caracteres no gráficos
      --show-control-chars   muestra los caracteres no gráficos tal y como
                             son (predeterminado a menos que el programa sea
                             `ls' y la salida sea un terminal)
  -Q, --quote-name           encierra los nombres de las entradas entre
                             comillas
      --quoting-style=PALABRA  utiliza el estilo de cita PALABRA para los
                               nombres de las entradas:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              invierte el orden, en su caso
  -R, --recursive            muestra los subdirectorios recursivamente
  -s, --size                 muestra el tamaño de cada fichero, en bloques
  -S                         ordena los ficheros por tamaño
      --sort=PALABRA         extension -X, none -U, size -S, time -t, version -v
                             status -c, time -t, atime -u, access -u, use -u
      --time=PALABRA         muestra la fecha según PALABRA, en lugar de la
                             fecha de modificación:
                               atime, access, use, ctime ó status; utiliza
                               la fecha especificada como clave de ordenación
                               si --sort=time
      --time-style=PALABRA   muestra la fecha utilizando el estilo PALABRA:
                               full-iso, iso, locale, posix-iso, +FORMATO
                             FORMATO se interpreta como en `date'; si FORMATO
                             es FORMATO1<nuevalínea>FORMATO2, FORMATO1 se
                             aplica a los ficheros no recientes y FORMATO2
                             a los ficheros recientes
  -t                         ordena por la fecha de modificación
  -T, --tabsize=COLS         establece los topes de tabulación a cada COLS
                             en lugar de 8
  -u                         con -lt: ordena por atime y muestra atime (fecha
                               de último acceso al fichero)
                               con -l: muestra atime y ordena por nombre
                               en cualquier otro caso: ordena por atime
  -U                         no ordena; muestra las entradas en el orden del
                             directorio
  -v                         ordena por versión
  -w, --width=COLS           establece el ancho de la pantalla en lugar del
                             valor actual
  -x                         muestra las entradas por líneas en vez de por
                             columnas
  -X                         ordena alfabéticamente por la extensión de la
                             entrada
  -1                         muestra un fichero por cada línea
      --help     muestra esta ayuda y finaliza
      --version  muestra la versión y finaliza

TAMAÑO puede ser (o puede ser un entero seguido opcionalmente por) uno
de los siguientes: kB 1.000, K 1.024, MB 1.000.000, M 1.048.576, y así
en adelante para G, T, P, E, Z, Y.

Por defecto, no se emplea color para distinguir los tipos de ficheros. Esto
equivale a usar --color=none. Usar la opción --color sin el argumento opcional
CUÁNDO equivale a usar --color=always. Con --color=auto, sólo se muestran
los códigos de color si la salida estándar está conectada a un terminal (tty).

Comunicar bichos a <bug-fileutils@gnu.org>.
\end{verbatim}

Disculpe el  lector semejante ejemplo, pero  era para que se  viera la
información que se  puede obtener de primera mano.  Para consultar con
detenimiento esta  ayuda, el  autor recomienda usar  {\tt ls  --help |
more}, y  que según se  avanza con la  información, se pulsa  la barra
espaciadora, y para salir, se pulsa la tecla {\tt q}.


Obsérvese que  se pueden  escribir los parámetros  de dos  formas: una
corta ({\tt -l, -a}) y otra larga ({\tt --all, --help}).

Para  crear  un  directorio,  usaremos {\tt  mkdir  nombre  del  nuevo
directorio},  y para  eliminarlo {\tt  rmdir nombre  del directorio  a
eliminar}. {\bf ¡Atención!  El directorio que se  quiere eliminar debe
estar vacío  y no debe haber  nadie trabajando en él  en ese momento.}
Evidentemente, podemos  crear y destruir  un directorio dando  su ruta
completa o sólo  su nombre si nos encontramos en  el directorio que lo
contiene. En  caso de querer borrar  de un sólo golpe  un directorio y
todo su  contenido disponemos  del comando {\tt  rm} con  las opciones
{\tt  -rf}. {\bf  Mucho  cuidado con  borrar  directorios enteros  sin
comprobar lo que se hace, pues no hay marcha atrás}

\begin{verbatim}
[felix@localhost apuntes]$ mkdir pepe
[felix@localhost apuntes]$ mkdir tmp
[felix@localhost apuntes]$ rmdir pepe
[felix@localhost apuntes]$ rm -rf tmp
\end{verbatim}

en el directorio actual, o también,

\begin{verbatim}
[felix@localhost apuntes]$ mkdir /home/felix/pepe
[felix@localhost apuntes]$ rmdir /home/felix/pepe
\end{verbatim}

desde cualquier directorio.

\subsection{Trabajando con ficheros}
\index{Fichero}

Antes  que nada,  hay  que  entender el  sistema  de  permisos de  los
ficheros y directorios. Si escribimos {\tt ls -l}, nos encontramos con
la siguiente salida:
\index{Fichero!permisos}

\begin{verbatim}
[felix@localhost apuntes]$ ls -l
total 468
-rw-rw-r--    1 felix    felix      163004 oct 29 10:05
 Apuntes_CILA_2001.dvi
-rw-rw-r--    1 felix    felix      119151 oct 29 10:05
 Apuntes_CILA_2001.sgml
-rw-rw-r--  1 felix  felix    1617 oct 28 22:15 cabecera.sgml
-rw-rw-r--  1 felix  felix   13329 oct 29 10:05 comandos.sgml
-rwx------  1 felix  felix      33 oct 29 00:32 compila*
drwxrwxr-x  2 felix  felix    4096 oct 28 23:20 CVS/
-rw-rw-r--  1 felix  felix   17250 oct 28 12:11 editores.sgml
-rw-rw-r--  1 felix  felix      12 oct 27 23:10 final.sgml
-rw-rw-r--  1 felix  felix     157 oct 27 23:10 graficos.sgml
-rw-rw-r--  1 felix  felix    2816 oct 28 21:51 internet.sgml
-rw-rw-r--  1 felix  felix   23308 oct 28 23:05 introduccion.sgml
-rw-rw-r--  1 felix  felix     402 oct 27 23:10 LEEME
-rw-rw-r--  1 felix  felix    2295 oct 28 22:19 Makefile
-rw-rw-r--  1 felix  felix   13087 oct 28 17:30 matematicas.sgml
-rw-rw-r--  1 felix  felix     652 oct 28 21:56 presentacion.sgml
-rw-rw-r--  1 felix  felix    34797 oct 28 21:56 programando.sgml
-rw-rw-r--  1 felix  felix      47 oct 28 21:56 recursos.sgml
-rw-rw-r--  1 felix  felix    1320 oct 25 13:35 resumen_temario.txt
-rw-rw-r--  1 felix  felix    4662 oct 28 22:17 sobre.sgml
-rw-rw-r--  1 felix  felix    5247 oct 28 22:19 temario.estado
-rw-rw-r--  1 felix  felix    7417 oct 27 23:10 xwindow.sgml
\end{verbatim}

La primera letra a  la izquierda de cada línea nos  indica si se trata
de un fichero (``-'') o un directorio (``d'').

Después nos encontramos con tres  grupos de tres letras (``rwx''), que
según  estén activados  (la propia  letra, r,w,x)  o desactivados  (un
guión,  -)  nos concede  o  deniega  permisos  de lectura  ({\tt  r}),
escritura ({\tt w}) y ejecución ({\tt x}). ¿Y por qué son tres grupos?
Pues porque las tres primeras letras se refieren al propio usuario que
es el dueño de esos ficheros, el  segundo grupo se refiere al grupo de
usuario  que  pertenece ese  usuario,  y  el  tercero a  los  usuarios
``extraños`` o ''ajenos'' al usuario. Por tanto, si leemos


\begin{center}
$-\underbrace{rw-}_{u}\underbrace{rw-}_{g}\underbrace{r--}_{o}$
\end{center}

vemos  que se  trata  de un  fichero  (-) con  permisos  de lectura  y
escritura  para el  usuario y  el grupo  al que  pertenece, y  de sólo
lectura para un ``extraño''.

El  siguiente  sería un  fichero  de  lectura, escritura  y  ejecución
únicamente para el usuario pro\-pie\-ta\-rio del fichero.

\begin{center}
$-\underbrace{rwx}_{u}\underbrace{---}_{g}\underbrace{---}_{o}$
\end{center}

Este  último ejemplo  es un  directorio (d)  con permisos  de lectura,
escritura  y ejecución  para  el  usuario y  el  grupo,  y de  lectura
y  ejecución  para el  ``extraño''.  En  el  caso de  directorios,  el
permiso de  ejecución es equivalente  a permiso para ``entrar''  en el
directorio.

\begin{center}
$d\underbrace{rwx}_{u}\underbrace{rwx}_{g}\underbrace{r-x}_{o}$
\end{center}

En  el ejemplo  del  listado anterior  vemos dos  veces  el nombre  de
``felix''. El de la primera columna se refiere al usuario propietario,
y el segundo  es el nombre del grupo, que  casualmente coincide con el
nombre  del usuario.  Esto  es importante  recordarlo, porque  debemos
tener  en  cuenta  que  {\bf  jamás podremos  eliminar  un  fichero  o
retocarlo  si no  tenemos permisos  de  escritura sobre  él}. Esto  es
impensable en algunas versiones de {\tt Windows}.

El  comando para  copiar un  fichero es  {\tt cp  [fichero de  origen]
[fichero  de  destino]},  es  decir,  que  copiamos  el  fichero  {\bf
pepe.txt} en {\bf juan.txt}.

\begin{verbatim}
[felix@localhost apuntes]$ cp pepe.txt juan.txt
\end{verbatim}

El comando  para mover o  renombrar un fichero  es {\tt mv  fichero de
origen fichero  de destino},  es decir, que  copiamos el  fichero {\bf
pepe.txt}  en {\bf  juan.txt},  pero {\bf  pepe.txt}  deja de  existir
físicamente.

\begin{verbatim}
[felix@localhost apuntes]$ mv pepe.txt juan.txt
\end{verbatim}

\noindent\rule{\linewidth}{.75pt}
NOTA: El intérprete de comandos  \textbf{SÍ} distingue en mayúsculas y
minúsculas,  tanto en  el  caso de  los  comandos como  en  el de  los
ficheros y directorios. Esto significa que el comando mv es totalmente
diferente a Mv, mV y MV. Asimismo,  el fichero pepe.txt no es el mismo
fichero que Pepe.txt, ni que PEPE.TXT, etc.
\rule{\linewidth}{.75pt}
\vspace{1pt}

Un último punto  a esta sección. Si queremos que  un fichero cambie de
propietario, lo haremos, con {\tt chown}:
\index{Fichero!chown}

\begin{verbatim}
[felix@localhost apuntes]$ chown miguel pepe.txt
\end{verbatim}

si antes, {\bf pepe.txt} era de {\tt  felix}, ahora pasa a ser de {\tt
miguel}.

De igual forma, para cambiarlo de grupo, usaremos {\tt chgrp}. Si {\bf
pepe.txt} era  del grupo  de los  profesores, y  queremos que  sea del
grupo de los estudiantes, sólo habrá que escribir lo siguiente:

\begin{verbatim}
[felix@localhost apuntes]$ chgrp estudiantes pepe.txt
\end{verbatim}

En algunos sistemas  no se puede cambiar el propietario  de un fichero
bajo ciertas condiciones:

\begin{verbatim}
$ ls -l hola
-rw-r--r--    1 miguev   108             0 ago 10 20:27 hola
$ chown frodo hola
chown: hola: Operación no permitida
\end{verbatim}

Esto es normal en sistemas donde hay cuotas de usuario. Las cuotas son
un mecanismo de limitación para que  los usuarios no puedan ocupar más
de un  determinado volumen (su cuota)  en el disco. Si  este mecanismo
está activo  no se permite  a los  usuarios cambiar el  propietario de
ningún fichero, ya que podría usarse  este cambio para ocupar la cuota
de otro usuario.
\index{Fichero!chmod}
Finalmente, para  cambiar los permisos  de un fichero, lo  haremos con
{\tt chmod},  indicando a  que tipo de  usuario queremos  asignarlos y
sobre qué permisos.  Para indicar el usuario  propietario, usaremos el
parámetro {\tt u}, el  de grupo será {\tt g} y el  ajeno será {\tt o},
(de {\tt otros}). Para indicar el tipo de permiso, usaremos las letras
{\tt  r},  {\tt w},  {\tt  x},  según  sean  de lectura,  escritura  o
ejecución  respectivamente. Y  para conceder  o denegar,  usaremos los
símbolos ``+'' y ``-'':

\begin{verbatim}
[felix@localhost apuntes]$ chmod u+rwx pepe.txt
\end{verbatim}

Este ejemplo sirve para dar todos los permisos al usuario.

En el  siquiente ejemplo  daremos permisos de  lectura y  ejecución al
usuario  y al  grupo,  pero  no de  escritura  sobre  el fichero  {\bf
compila}.


\begin{verbatim}
[felix@localhost apuntes]$ chmod ug+r-x compila
\end{verbatim}

O quitar el permiso de ejecución a  todos los usuarios sin que se vean
afectados los otros tipos de permisos:

\begin{verbatim}
[felix@localhost apuntes]$ chmod -x probar
\end{verbatim}

\section{Comandos básicos para sobrevivir}

\begin{description}

\item [clear:] limpia la pantalla de la consola (teclas CTRL+L)

\item [top:] muestra los procesos  que se ejecutan en ese momento,
sabiendo los recursos que se están consumiendo.

\item [locate:] es la orden de búsqueda más rápida y sencilla para
localizar un archivo.

\item [whoami:] de (Who am  I?, ¿Quién soy?), que  indica con qué
nombre de usuario se entró en esa consola. Puede parecer una tontería,
pero si una persona entra en dos  sesiones, en una como root y en otra
como usuario  normal, si no se  sabe quién es en  ese momento, podrían
ocurrir accidentes catastróficos.

\item [reset:] si observamos  que  escribimos en  pantalla y  no
aparece  el  texto  pero  al  pulsar {\tt  enter}  realmente  se  está
escribiendo,  o  que  los  colores  o los  textos  de  la  consola  se
corrompen,  puede  ser  que  alguna  aplicación  en  modo  texto  haya
finalizado  bruscamente  no restaurando  los  valores  estándar de  la
consola  al  salir.  Con  esto  forzamos  unos  valores  por  defecto,
regenerando la pantalla.


\end{description}

\subsection{El comando {\tt man}}
\index{Comandos!man}


Este comando es  muy útil, ya que nos dará  mucha información sobre la
mayoría de los comandos con los que vamos a trabajar.

\begin{verbatim}
[felix@localhost apuntes]$ man bash
\end{verbatim}

Omitimos la información de salida ya que puede ser muy extensa e invita
al lector a que lo pruebe él mismo.

\section{Unidades de disco}

Como hemos dicho anteriormente, en  Linux no existen las unidades {\tt
A}:  ni {\tt  C:}  sino  que todos  los  dispositivos ``cuelgan''  del
directorio raíz {\tt /}. Para acceder  a un disco es necesario primero
{\em  montarlo},  esto es  asignarle  un  lugar  dentro del  árbol  de
directorios del sistema.

Por ejemplo, podemos asignar  a la disquetera el directorio {\tt /floppy}, al CD-ROM  el directorio {\tt /cdrom} o a la  grabadora de  CDs el  directorio {\tt  /grabata}. Normalmente  los directorios  para  la  disquetera  y  el lector  de  CD-ROM  están  ya asignados desde  el momento  de instalar el  sistema, aunque  se puede cambiar a voluntad (si somos root ;-).

Para montar  un disco  utilizamos el  comando {\tt  mount} indicándole
como parámetros el dispositivo al que queremos acceder y el directorio
en el que lo queremos montar. Sin embargo estas precisiones suelen ser
responsabilidad  del administrador  (root) y  los usuarios  tienen que
conformarse montar lo  que root les permita. En nuestro  caso el señor
root ha determinado que los usuarios sólo podemos montar la disquetera
en el directorio {\tt /floppy}.

\begin{verbatim}
[miguev@euler apuntes]$ mount /dev/fd0 /floppy
mount: only root can do that
[miguev@euler apuntes]$ mount /floppy
\end{verbatim}

Una vez montado el disquete en  el directorio {\tt /floppy} ya podemos
acceder a él y  trajinar sus ficheros como nos dé  la gana. Y ahora
viene el pero: pobre de quien  saque el disquete sin desmontarlo. ¿Por
qué? Pues por tres razones:

\begin{enumerate}

\item  Existe el  riesgo de  que perdamos  la información  que hayamos
grabado en el disquete.

\item  Ningún otro  usuario  podrá  usar la  disquetera  hasta que  se
reinicie el ordenador, lo cual no le hará gracia a nadie.

\item El  Sr. root puede  mosquearse con quien lo  haga, y a  nadie le
conviene que el tiener mosqueado al Sr. root.

\end{enumerate}

Para desmontar el disquete simplemente utilizamos el sencillo comando:

\begin{verbatim}
$ umount /floppy
\end{verbatim}

Como último ejemplo, hagamos lo siguiente:

\begin{verbatim}
$ mount /floppy
$ cd /floppy
$ umount /floppy
\end{verbatim}

¿Verdad que no funciona? Esto se debe a que en el momento de desmontar
la  disketera, {\em  no debe  haber NADIE}  dentro de  ese directorio.
Recordemos que estamos en un  sistema multiusuario y puede ocurrir que
más  de  una persona  acceda  a  la  disketera  o a  otro  dispositivo
desmontable, como  el CD-ROM. Por  tanto, hemos de asegurarnos  que no
hay nadie.

Para comprobar en un momento dado  si el disquete está montado podemos
usar el  comando {\tt  df}, que  nos informa  sobre los  ``sistemas de
ficheros'' que están montados y su estado de almacenamiento. La opción
{\tt -h} nos muestra las cantidades en cifras ``{\bf h}umanas''.

\begin{verbatim}
[miguev@euler apuntes]$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda2             1.9G  1.8G   80M  96% /
euler:/home            20G  3.2G   16G  17% /home
euler:/usr/soft       3.9G  5.4M  3.7G   0% /usr/soft
/dev/fd0              1.4M  758k  665k  53% /floppy
\end{verbatim}

Aquí  vemos  que la  segunda  partición  del  primer disco  duro  {\tt
/dev/hda2} está montada en el directorio {\tt /}, los directorios {\tt
/home} y  {\tt /usr/soft} del  servidor {\tt euler} están  montados en
sus equivalente locales, y el  disquete {\tt /dev/fd0} está montado en
el directorio {\tt /floppy}.
