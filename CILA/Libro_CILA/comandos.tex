%Autor: _ese
\chapter{El intérprete de comandos}
\index{Comandos, intérprete}
\section{¿Qué es un intérprete de comandos?}

Si  bien  manejarse en  Linux  es  cada vez  más  fácil,  debido a  la
proliferación  de escritorios,  los  comienzos no  siempre fueron  así
de  fáciles. De  hecho,  puede  ocurrir que  nos  encontremos con  una
emergencia  en el  que  no  nos quede  más  remedio  que trabajar  con
comandos.

Un intérprete  de comandos tiene el  aspecto de una pantalla  llena de
letras, generalmente  con fondo negro  y letras  blancas, y que  en la
última línea inferior, se suele ver lo siguiente:

\begin{verbatim}
[felix@localhost Comandos]$
\end{verbatim}

En  este entorno  es donde  introduciremos  los comandos  con los  que
trabajaremos, y  coloquialmente diremos que estamos  trabajando en una
consola. Estos comandos pueden ser de diferentes clases:

\begin{itemize}
\item Programas ejecutables.

\item Scripts del intérprete.

\item Scripts  de lenguajes de  script como {\sf Python},  {\sf Perl},
{\sf Tcl}, etc.

\item Macros del intérprete.
\end{itemize}

Todos  tienen en  común que  son ficheros:  al cargar  un programa  en
Linux, se ordena al intérprete que busque el fichero con el nombre del
programa y  una vez  encontrado, lo  ejecute, si  éste da  permisos de
ejecución al usuario.

Los comandos tienen el siguiente aspecto:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk
[felix@localhost Comandos]$ lsmod
[felix@localhost Comandos]$ ls
\end{verbatim}

También funcionan con opciones:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk -v
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
\end{verbatim}

Y con parámetros:

\begin{verbatim}
[felix@localhost Comandos]$ fdisk /dev/hda
[felix@localhost Comandos]$ ls /tmp
[felix@localhost Comandos]$ ls *.txt
\end{verbatim}

Con opciones y parámetros:

\begin{verbatim}
[felix@localhost Comandos]$ rpm -qpl joe-1.0.3.rpm
[felix@localhost Comandos]$ gcc -o suma suma.c
[felix@localhost Comandos]$ ls -al /tmp
\end{verbatim}

Al  ser Linux  un sistema  {\em multitarea}  y {\em  multiusuario}, se
aportan  ventajas que  se  agradecen  incluso en  un  sistema PC  {\em
monousuario}.  Una de  estas ventajas  es  que se  puede trabajar  con
seis  consolas  virtuales, que  es  como  si pudiéramos  trabajar  con
varias  sesiones  simultáneas, entendiendo  por  sesión  el tiempo  de
trabajo  desde que  el usuario  entra  tras identificarse  en el  {\tt
login}\index{login} de entrada  hasta que abandona el  sistema. Lo que
significa realmente que el mismo  usuario puede entrar varias veces al
mismo tiempo.

Para alternar  entre estas  consolas virtuales,  basta con  pulsar las
combinaciones de la teclas {\tt A-F1} a {\tt A-F6}

Si se quiere acceder a una  consola desde un entorno gráfico, entonces
se pulsan las combinaciones {\tt C-A-F1} a {\tt C-A-F6}

\section{Directorios y nombres de ficheros}

\subsection{Trabajando con directorios.}

\subsubsection{Estructura del árbol de directorios}

Toda  la información  (ya  sean  textos, imágenes,  bases  de datos  o
información para  la configuración  del sistema)  se almacena  en {\em
ficheros}, que a su vez se guardan en {\em directorios}. Con todas las
herramientas y programas existentes se  puede acceder a estos ficheros
para ver su contenido o  modificarlo. En la Figura \ref{arbol} podemos
ver una ejemplo de dicha estructura en árbol.

\begin{figure}[hbtp]
\centering
\includegraphics[width=\textwidth]{imagenes/arbol.eps}
\caption{Estructura en árbol de directorios en sistemas UNIX}\label{arbol}
\end{figure}

Todos los  ficheros y  directorios de  un sistema  UNIX cuelgan  de un
directorio principal  llamado {\em raíz}\index{directorio  raíz, raíz,
/}, que se  representa como {\tt /}. En la  Figura \ref{arbol} podemos
observar como del  directorio raíz {\tt /}  cuelgan otros directorios,
como {\tt etc} o {\tt home}.

En  dicho  esquema  diferenciamos  los directorios  de  los  ficheros,
complementando el  final del  nombre de los  primeros con  el caracter
{\tt /}.  En el  mismo esquema vemos  como algunos  directorios pueden
contener otros directorios,  como es el caso de {\tt  home}, que es el
{\em padre} de los directorios {\tt usr1} y {\tt usr2}. También pueden
contener algunos  ficheros, como es  el caso de  {\tt dev}, que  es el
padre de {\tt  dsp}; o el propio  {\tt usr2}, que es el  padre de {\tt
trabajo.txt}. Éste  último fichero tiene  la {\em ruta  absoluta} {\tt
/home/usr2/trabajo.txt}, que  define su localización dentro  del árbol
de directorios.

Todos  los  directorios  de  un sistema  UNIX  contienen  almenos  dos
subdirectorios.  El  primero es  {\tt  ./}  que representa  al  propio
directorio,  mientras que  el segundo  es  {\tt ../}  y representa  al
directorio padre. Por  ejemplo, el directorio {\tt ./}  dentro de {\tt
/home/usr1} es el propio {\tt  /home/usr1}, mientras que el directorio
{\tt ../}  dentro de  {\tt /home/usr1}  es {\tt  /home}, es  decir, su
directorio padre.

En  los sistemas  UNIX  todo son  ficheros.  Dispositivos como  discos
duros,  scanners  o  disqueteras  se representan  como  {\em  archivos
especiales} en  el directorio  {\tt /dev}. Por  ejemplo, en  la Figura
\ref{arbol} vemos  el fichero {\tt /dev/dsp}  que suele corresponderse
con la tarjeta de sonido instalada en el sistema.

A diferencia de  los sistemas MS-DOS/Windows, en los  sistemas UNIX no
se  reparten los  directorios en  función de  si están  en una  unidad
física o en otra (C:, D:, etc.). Durante el arranque del sistema, cada
uno  los  archivos representativos  de  los  diferentes discos  duros,
particiones y  demás elementos de  almacenamientos son asociados  a un
directorio  del  directorio  raíz.  A  este  proceso  se  lo  denomina
{\em  montaje}\index{Montar},  y no  sólo  es  revesible sino  que  es
completamente configurable.  Por ejemplo, en la  Figura \ref{arbol} el
directorio {\tt /home}  podría estar en una partición  diferente en un
disco duro distinto al que contiene a  {\tt /} o a {\tt /etc}. Nada en
el esquema  o en  el trabajo  con el sistema  nos permite  apreciar la
diferencia. Por  tanto, no tiene  sentido escribir en la  consola {\tt
C:}, tal  y como haríamos  en MS-DOS. Solamente debemos  dirigirnos al
directorio asociado a esa partición que para MS-DOS es {\tt C:}.

Hay que  destacar que  cuando el  usuario accede  a una  sesión, Linux
``envía'' al usuario a su directorio de trabajo. Es decir, si yo entro
como el usuario {\tt felix}, en  el momento de entrar me encontraré en
el directorio {\tt /home/felix}. Éste  será mi directorio personal, en
donde  tengo  libertad absoluta  para  hacer  lo  que quiera  con  mis
ficheros y directorios  ubicados ahí. Sin embargo no  podré hacer todo
lo que quiera en el directorio  {\tt /home/miguel}. ¿Por qué? Pues por
la  sencilla razón  de  que Linux  tiene un  sistema  de permisos  que
concede o  restringe libertades sobre  los directorios y  ficheros que
hay en Linux. ¿Significa eso que  puede existir un usuario ``dios'' en
Linux que puede  hacer totalmente cualquier cosa en Linux?  Sí, ése es
el usuario {\tt root}\index{root}. Sin embargo, para los propósitos de
este curso,  sólo nos remitiremos  a la  cuenta de trabajo  del propio
lector ;-)

\subsubsection{Comandos sobre el árbol de directorios}

Para movernos por el árbol  de directorios emplearemos el comando {\tt
cd} ({\sf Change Directory}) \index{Comandos!cd}

\begin{verbatim}
[felix@localhost Comandos]$ cd /etc
\end{verbatim}

Es decir, nos vamos al directorio {\tt /etc}

Si  simplemente escribimos  {\tt  cd} sin  especificar  el nombre  del
directorio, esto será  igual que escribir {\tt cd  /home/felix} o {\tt
cd}, es decir,  me manda a {\bf mi propio  directorio de trabajo} (que
es como irse a casa).

¿Cómo sé  yo en  qué directorio  me encuentro?  Basta con  escribir el
comando {\tt pwd} ({\sf Print Work Directory}).
\index{Comandos!pwd}
\begin{verbatim}
[felix@localhost felix]$ pwd
/home/felix/
\end{verbatim}

Y la salida que obtendré es:

\begin{verbatim}
/home/felix
\end{verbatim}

En  caso   de  querer   listar  los   ficheros  y   subdirectorios  de
un   directorio   dado   escribimos   {\tt   ls   nombre\_directorio}.
\index{Comandos!ls}

\begin{verbatim}
[felix@localhost apuntes]$ ls /home/felix/apuntes/apuntes/
Apuntes_CILA_2001.dvi   CVS/    introduccion.sgml  programando.sgml
 xwindow.sgml
Apuntes_CILA_2001.sgml  editores.sgml  LEEME             recursos.sgml
cabecera.sgml           final.sgml     Makefile
 resumen_temario.txt
comandos.sgml           graficos.sgml  matematicas.sgml  sobre.sgml
compila*                internet.sgml  presentacion.sgml temario.estado
\end{verbatim}

El comando {\tt ls} admite parámetros tales como {\tt -a, -l}

\begin{verbatim}
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
[felix@localhost Comandos]$ ls -la
\end{verbatim}

Obsérvese que ambas  formas de escribir los  parámetros son igualmente
válidas.  Como anotación,  si queremos  ver que  parámetros se  pueden
utilizar  en   un  comando,   normalmente  basta  con   escribir  {\tt
nombre\_comando --help}.

\begin{verbatim}
[felix@localhost apuntes]$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
Muestra información acerca de los FICHEROs (del directorio actual por defecto).
Ordena las entradas alfabéticamente si no se especifica ninguna de las
opciones -cftuSUX ni --sort.

Los argumentos obligatorios para las opciones largas son también obligatorios
para las opciones cortas
  -a, --all                  do not hide entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               print the author of each file
  -b, --escape               print octal escapes for nongraphic characters
      --block-size=TAMAÑO    utiliza bloques de TAMAÑO bytes
  -B, --ignore-backups       no muestra la entradas que terminan con ~
  -c                         con -lt: ordena por ctime y muestra ctime (fecha
                               de última modificación del fichero)
                               con -l: muestra ctime y ordena por nombre
                               en cualquier otro caso: ordena por ctime
  -C                         muestra las entradas por columnas
      --color[=CUÁNDO]       especifica si se usará color para distinguir los
                               tipos de ficheros. CUÁNDO puede ser `never',
                               `always' o `auto'
  -d, --directory            muestra las entradas de los directorios en lugar
                             de sus contenidos
  -D, --dired                genera el resultado para el modo `dired' de Emacs
  -f                         no ordena, utiliza -aU, no utiliza -lst
  -F, --classify             añade un indicador (uno de */=@|) a las entradas
      --format=PALABRA       across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            como -l --time-style=full-iso
  -g                         como -l, pero no muestra el propietario
  -G, --no-group             no muestra la información del grupo
  -h, --human-readable       muestra los tamaños de forma legible
                             (p.e. 1K 234M 2G)
      --si                   análogo, pero utilizando potencias de 1000,
                             no de 1024
  -H, --dereference-command-line  sigue los enlaces simbólicos en la línea de
                                  órdenes
      --indicator-style=PALABRA  añade un indicador con estilo PALABRA a los
                                 nombres de las entradas: none (predeterminado),
                                 classify (-F), file-type (-p)
  -i, --inode                muestra el número de nodo-i de cada fichero
  -I, --ignore=PATRÓN        no lista las entradas que coincidan (encajen)
                             con PATRÓN de shell
  -k                         como --block-size=1K
  -l                         utiliza un formato de listado largo
  -L, --dereference          al mostrar la información de un fichero para un
                               enlace simbólico, muestra la información del
                               fichero al que apunta el enlace en lugar de la
                               del propio enlace
  -m                         rellena el ancho con una lista de entradas
                             separadas por comas
  -n, --numeric-uid-gid      como -l, pero muestra los UIDs y GIDs numéricos
  -N, --literal              muestra los nombres literalmente (no trata p.ej.
                             los caracteres de control de forma especial)
  -o                         como -l, pero no muestra el grupo
  -p  --file-type            añade un indicador (uno de /=@|) a las entradas
  -q, --hide-control-chars   imprime ? en lugar de los caracteres no gráficos
      --show-control-chars   muestra los caracteres no gráficos tal y como
                             son (predeterminado a menos que el programa sea
                             `ls' y la salida sea un terminal)
  -Q, --quote-name           encierra los nombres de las entradas entre
                             comillas
      --quoting-style=PALABRA  utiliza el estilo de cita PALABRA para los
                               nombres de las entradas:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              invierte el orden, en su caso
  -R, --recursive            muestra los subdirectorios recursivamente
  -s, --size                 muestra el tamaño de cada fichero, en bloques
  -S                         ordena los ficheros por tamaño
      --sort=PALABRA         extension -X, none -U, size -S, time -t, version -v
                             status -c, time -t, atime -u, access -u, use -u
      --time=PALABRA         muestra la fecha según PALABRA, en lugar de la
                             fecha de modificación:
                               atime, access, use, ctime ó status; utiliza
                               la fecha especificada como clave de ordenación
                               si --sort=time
      --time-style=PALABRA   muestra la fecha utilizando el estilo PALABRA:
                               full-iso, iso, locale, posix-iso, +FORMATO
                             FORMATO se interpreta como en `date'; si FORMATO
                             es FORMATO1<nuevalínea>FORMATO2, FORMATO1 se
                             aplica a los ficheros no recientes y FORMATO2
                             a los ficheros recientes
  -t                         ordena por la fecha de modificación
  -T, --tabsize=COLS         establece los topes de tabulación a cada COLS
                             en lugar de 8
  -u                         con -lt: ordena por atime y muestra atime (fecha
                               de último acceso al fichero)
                               con -l: muestra atime y ordena por nombre
                               en cualquier otro caso: ordena por atime
  -U                         no ordena; muestra las entradas en el orden del
                             directorio
  -v                         ordena por versión
  -w, --width=COLS           establece el ancho de la pantalla en lugar del
                             valor actual
  -x                         muestra las entradas por líneas en vez de por
                             columnas
  -X                         ordena alfabéticamente por la extensión de la
                             entrada
  -1                         muestra un fichero por cada línea
      --help     muestra esta ayuda y finaliza
      --version  muestra la versión y finaliza

TAMAÑO puede ser (o puede ser un entero seguido opcionalmente por) uno
de los siguientes: kB 1.000, K 1.024, MB 1.000.000, M 1.048.576, y así
en adelante para G, T, P, E, Z, Y.

Por defecto, no se emplea color para distinguir los tipos de ficheros. Esto
equivale a usar --color=none. Usar la opción --color sin el argumento opcional
CUÁNDO equivale a usar --color=always. Con --color=auto, sólo se muestran
los códigos de color si la salida estándar está conectada a un terminal (tty).

Comunicar bichos a <bug-fileutils@gnu.org>.
\end{verbatim}

Disculpe el  lector semejante ejemplo, pero  era para que se  viera la
información que se  puede obtener de primera mano.  Para consultar con
detenimiento esta  ayuda, el  autor recomienda usar  {\tt ls  --help |
more}, y  que según se  avanza con la  información, se pulsa  la barra
espaciadora, y para salir, se pulsa la tecla {\tt q}.

Obsérvese que  se pueden  escribir los parámetros  de dos  formas: una
corta ({\tt -l, -a}) y otra larga ({\tt --all, --help}).

Para crear  un directorio, usaremos {\tt  mkdir nombre\_directorio}.

\begin{verbatim}
[felix@localhost apuntes]$ mkdir pepe
[felix@localhost apuntes]$ mkdir tmp
\end{verbatim}

Mientras que para eliminarlo  usaremos {\tt rmdir nombre\_directorio}.
{\bf ¡Atención! El directorio que  se quiere eliminar debe estar vacío
y no debe haber nadie trabajando en él en ese momento.} Evidentemente,
podemos crear y  destruir un directorio dando su ruta  completa o sólo
su nombre si nos encontramos en el directorio que lo contiene. En caso
de querer  borrar de un sólo  golpe un directorio y  todo su contenido
disponemos del comando {\tt rm} con las opciones {\tt -rf}. {\bf Mucho
cuidado con borrar  directorios enteros sin comprobar lo  que se hace,
pues no sueñe haber forma de recuperar los archivos borrados}

\begin{verbatim}
[felix@localhost apuntes]$ rmdir pepe
[felix@localhost apuntes]$ rm -rf tmp
\end{verbatim}

Obsérvese que los comandos  anteriores borran los subdirectorios {\tt
pepe} y {\tt tmp} del directorio actual. Como hemos comentado, podemos
emplear rutas absolutas  para crear o borrar  un directorio cualquiera
del árbol de directorios.

\begin{verbatim}
[felix@localhost apuntes]$ mkdir /home/felix/pepe
[felix@localhost apuntes]$ rmdir /home/felix/pepe
\end{verbatim}

\subsection{Trabajando con ficheros}

\subsubsection{Comandos sobre el árbol de ficheros}

El  comando  para  copiar  un   fichero  es  {\tt  cp  fichero\_origen
fichero\_destino}, es decir, que copiamos el fichero {\tt pepe.txt} en
{\tt juan.txt}.

\begin{verbatim}
[felix@localhost apuntes]$ cp pepe.txt juan.txt
\end{verbatim}

El   comando  para   mover  o   renombrar  un   fichero  es   {\tt  mv
fichero\_origen fichero\_destino},  es decir, que copiamos  el fichero
{\tt pepe.txt} en {\tt juan.txt},  pero {\tt pepe.txt} deja de existir
físicamente.

\begin{verbatim}
[felix@localhost apuntes]$ mv pepe.txt juan.txt
\end{verbatim}

\noindent\rule{\linewidth}{.75pt}  NOTA:  El  intérprete  de  comandos
\textbf{SÍ} distingue en mayúsculas y  minúsculas, tanto en el caso de
los comandos como en el de  los ficheros y directorios. Esto significa
que el comando mv es totalmente diferente  a {\tt Mv}, {\tt mV} y {\tt
MV}. Asimismo,  el fichero {\tt pepe.txt}  no es el mismo  fichero que
{\tt Pepe.txt}, ni que {\tt PEPE.TXT}, etc.
\rule{\linewidth}{.75pt}
\vspace{1pt}

En  caso de  que  deseemos borrar  definitivamente  un fichero  podemos
emplear el comando {\tt rm nombre\_fichero}.

\begin{verbatim}
[felix@localhost apuntes]$ rm pepe.txt juan.txt
\end{verbatim}

\subsubsection{Utilización de comodines}

En ocaciones el  nombre de los directorios y/o ficheros  sobre los que
estamos trabajando  contienen partes comunes que  podemos utilizar con
ayuda  de  comodines  para  facilitarnos  el uso  de  la  interfaz  de
comandos.

En general el caracter {\tt *} al  indicar el nombre de un fichero y/o
directorio  es sustituido  por  un número  indeterminado de  cualquier
combinación de caracteres. Por ejemplo,

\begin{verbatim}
[felix@localhost apuntes]$ rm pe*
\end{verbatim}

\noindent borrará cualquier  ficheros que empiecen por {\tt  pe} en el
directorio actual. Mientras que,

\begin{verbatim}
[felix@localhost apuntes]$ cp *txt* tmp/
\end{verbatim}

\noindent copiará los ficheros que contengan la cadena {\tt txt} en el
nombre al directorio {\tt tmp}.

El caracter {\tt ?} al indicar el nombre de un fichero sólo representa
a {\em un} carácter cualquiera.

\begin{verbatim}
[felix@localhost apuntes]$ mv pepe?.txt tmp/
\end{verbatim}

El  ejemplo  anterior  moverá  archivos como  {\tt  pepe.txt}  o  {\tt
pepa.txt} al directorio {\tt tmp}.

\subsubsection{Sistema de permisos}

A la hora  de trabajar con ficheros, es necesario  entender el sistema
de  permisos de  los ficheros  y  directorios. Si  escribimos {\tt  ls
-l}\index{Ficheros!permisos,  Ficheros!propietario,  Ficheros!tamaño},
nos encontramos con la siguiente salida: \index{Fichero!permisos}

\begin{verbatim}
[felix@localhost apuntes]$ ls -l
total 468
-rw-rw-r--    1 felix    felix      163004 oct 29 10:05
 Apuntes_CILA_2001.dvi
-rw-rw-r--    1 felix    felix      119151 oct 29 10:05
 Apuntes_CILA_2001.sgml
-rw-rw-r--  1 felix  felix    1617 oct 28 22:15 cabecera.sgml
-rw-rw-r--  1 felix  felix   13329 oct 29 10:05 comandos.sgml
-rwx------  1 felix  felix      33 oct 29 00:32 compila*
drwxrwxr-x  2 felix  felix    4096 oct 28 23:20 CVS/
-rw-rw-r--  1 felix  felix   17250 oct 28 12:11 editores.sgml
-rw-rw-r--  1 felix  felix      12 oct 27 23:10 final.sgml
-rw-rw-r--  1 felix  felix     157 oct 27 23:10 graficos.sgml
-rw-rw-r--  1 felix  felix    2816 oct 28 21:51 internet.sgml
-rw-rw-r--  1 felix  felix   23308 oct 28 23:05 introduccion.sgml
-rw-rw-r--  1 felix  felix     402 oct 27 23:10 LEEME
-rw-rw-r--  1 felix  felix    2295 oct 28 22:19 Makefile
-rw-rw-r--  1 felix  felix   13087 oct 28 17:30 matematicas.sgml
-rw-rw-r--  1 felix  felix     652 oct 28 21:56 presentacion.sgml
-rw-rw-r--  1 felix  felix    34797 oct 28 21:56 programando.sgml
-rw-rw-r--  1 felix  felix      47 oct 28 21:56 recursos.sgml
-rw-rw-r--  1 felix  felix    1320 oct 25 13:35 resumen_temario.txt
-rw-rw-r--  1 felix  felix    4662 oct 28 22:17 sobre.sgml
-rw-rw-r--  1 felix  felix    5247 oct 28 22:19 temario.estado
-rw-rw-r--  1 felix  felix    7417 oct 27 23:10 xwindow.sgml
\end{verbatim}

La primera letra a  la izquierda de cada línea nos  indica si se trata
de un fichero (``-'') o un directorio (``d'').

Después nos encontramos con tres  grupos de tres letras (``rwx''), que
según  estén activados  (la propia  letra, r,w,x)  o desactivados  (un
guión,  -)  nos concede  o  deniega  permisos  de lectura  ({\tt  r}),
escritura ({\tt w}) y ejecución ({\tt x}). ¿Y por qué son tres grupos?
Pues porque las tres primeras letras se refieren al propio usuario que
es el dueño de esos ficheros, el  segundo grupo se refiere al grupo de
usuario  que  pertenece ese  usuario,  y  el  tercero a  los  usuarios
``extraños`` o ''ajenos'' al usuario. Por tanto, si leemos


\begin{center}
$-\underbrace{rw-}_{u}\underbrace{rw-}_{g}\underbrace{r--}_{o}$
\end{center}

vemos  que se  trata  de un  fichero  (-) con  permisos  de lectura  y
escritura  para el  usuario y  el grupo  al que  pertenece, y  de sólo
lectura para un ``extraño''.

El  siguiente  sería un  fichero  de  lectura, escritura  y  ejecución
únicamente para el usuario pro\-pie\-ta\-rio del fichero.

\begin{center}
$-\underbrace{rwx}_{u}\underbrace{---}_{g}\underbrace{---}_{o}$
\end{center}

Este  último ejemplo  es un  directorio (d)  con permisos  de lectura,
escritura  y ejecución  para  el  usuario y  el  grupo,  y de  lectura
y  ejecución  para el  ``extraño''.  En  el  caso de  directorios,  el
permiso de  ejecución es equivalente  a permiso para ``entrar''  en el
directorio.

\begin{center}
$d\underbrace{rwx}_{u}\underbrace{rwx}_{g}\underbrace{r-x}_{o}$
\end{center}

En  el ejemplo  del  listado anterior  vemos dos  veces  el nombre  de
``felix''. El de la primera columna se refiere al usuario propietario,
y el segundo  es el nombre del grupo, que  casualmente coincide con el
nombre  del usuario.  Esto  es importante  recordarlo, porque  debemos
tener  en  cuenta  que  {\bf  jamás podremos  eliminar  un  fichero  o
retocarlo  si no  tenemos permisos  de  escritura sobre  él}. Esto  es
impensable en algunas versiones de Microsoft® Windows®.

Si queremos que un fichero cambie de propietario, lo haremos, con {\tt
chown}: \index{Comandos!chown, Ficheros!propietario}

\begin{verbatim}
[felix@localhost apuntes]$ chown miguel pepe.txt
\end{verbatim}

si antes, {\tt pepe.txt} era de {\tt  felix}, ahora pasa a ser de {\tt
miguel}.

De   igual   forma,   para   cambiarlo   de   grupo,   usaremos   {\tt
chgrp}\index{Comandos!chgrp}. Si  {\tt pepe.txt} era del  grupo de los
profesores,  y queremos  que sea  del grupo  de los  estudiantes, sólo
habrá que escribir lo siguiente:

\begin{verbatim}
[felix@localhost apuntes]$ chgrp estudiantes pepe.txt
\end{verbatim}

En algunos sistemas  no se puede cambiar el propietario  de un fichero
bajo ciertas condiciones:

\begin{verbatim}
$ ls -l hola
-rw-r--r--    1 miguev   108             0 ago 10 20:27 hola
$ chown frodo hola
chown: hola: Operación no permitida
\end{verbatim}

Esto es normal en sistemas donde hay cuotas de usuario. Las cuotas son
un mecanismo de limitación para que  los usuarios no puedan ocupar más
de un  determinado volumen (su cuota)  en el disco. Si  este mecanismo
está activo  no se permite  a los  usuarios cambiar el  propietario de
ningún fichero, ya que podría usarse  este cambio para ocupar la cuota
de otro usuario.

\index{Comandos!chmod, Ficheros!permisos}
Finalmente, para  cambiar los permisos  de un fichero, lo  haremos con
{\tt chmod},  indicando a  que tipo de  usuario queremos  asignarlos y
sobre qué permisos.  Para indicar el usuario  propietario, usaremos el
parámetro {\tt u}, el  de grupo será {\tt g} y el  ajeno será {\tt o},
(de {\tt otros}). Para indicar el tipo de permiso, usaremos las letras
{\tt  r},  {\tt w},  {\tt  x},  según  sean  de lectura,  escritura  o
ejecución  respectivamente. Y  para conceder  o denegar,  usaremos los
símbolos ``+'' y ``-'':

\begin{verbatim}
[felix@localhost apuntes]$ chmod u+rwx pepe.txt
\end{verbatim}

Este ejemplo sirve para dar todos los permisos al usuario.

En el  siquiente ejemplo  daremos permisos de  lectura y  ejecución al
usuario  y al  grupo,  pero  no de  escritura  sobre  el fichero  {\tt
compila}.

\begin{verbatim}
[felix@localhost apuntes]$ chmod ug+r-x compila
\end{verbatim}

O quitar el permiso de ejecución a  todos los usuarios sin que se vean
afectados los otros tipos de permisos:

\begin{verbatim}
[felix@localhost apuntes]$ chmod -x probar
\end{verbatim}

\section{Comandos básicos para sobrevivir}

A  parte de  los comandos  para el  manejo de  ficheros y  directorios
existen  algunos otros  que  conviene conocer  puesto que  simplifican
notablemente nuestro quehacer diario.

\subsection{Teclas especiales}

La interfaz de comandos está llena de atajos de teclado diseñados para
facilitarnos  la vida.  La  mayor parte  se  apoyan en  el  uso de  un
historial de los últimos comandos ejecutados. Estos son algunos de los
atajos más importantes:

\begin{description}

\item[{\tt Teclas del cursor}] Las  flechas hacia arriba y hacia abajo
nos  permiten  elegir  un  comando  de entre  los  almacenados  en  el
historial de la interfaz de comandos. Las flechas hacia la izquierda y
hacia la derecha  nos permiten movernos por la línea  de comandos para
editarla.

\item[{\tt TAB}] Si  mientras escribimos el nombre de un  comando o el
de  un  fichero tenemos  alguna  duda  podemos  pulsar {\tt  TAB}.  La
interfaz de comandos nos ayudará completando el nombre en la medida de
lo posible.  En caso  de que  no sepa darnos  una respuesta  por haber
varias soluciones  disponibles podemos pulsar nuevamente  para que nos
muestre  una lista  de  las mismas.  La interfaz  de  comandos nos  lo
indicará con una señal sonora si no hay ninguna solución posible.

\item[{\tt S-Re. Pag. y S-Av. Pag.}] Nos  permiten movernos por el búffer de
pantalla de la  consola para ver texto que en  condiciones normales no
podemos observar  puesto que el  desplazamiento vertical lo  ha dejado
fuera de la misma.

\item[{\tt C-l}] Limpiar la pantalla de la consola.

\item[{\tt C-r}] Buscar comandos en el historial.

\end{description}

\subsection{Imprimir en la salida estándar}

Uno   de   los  comandos   más   prácticos   y  utilizados   es   {\tt
cat}\index{Comandos!cat}.   Dicho   comando  encadena   los   archivos
especificados y los imprime por pantalla uno detrás de otro.

\begin{verbatim}
[felix@localhost apuntes]$ cat pepe.txt juan.txt
\end{verbatim}

En realidad  los comandos de la  consola de GNU/Linux no  entienden la
salida por pantalla y la entrada por  teclado de la misma forma que la
entendemos nosotros. La mayor parte de los comandos toman toda o parte
de la información que necesitan para  realizar su trabajo de lo que se
denomina la  {\em entrada estándar}.  De la misma manera,  utilizan la
{\em salida estándar}  para mostrar los resultado de su  trabajo, y la
{\em salida de error estándar} para mostrar los mensajes de lo errores
producidos durante la realización de la misma.

En general la {\em entrada estándar} suele estar asociada a la entrada
por teclado, mientras que la {\em salida estándar} y la {\em salida de
error estándar}  suelen estar sociadas  a la salida por  pantalla. Sin
embargo, Linux nos proporciona mecanismos para que cualquiera de estas
{\em entrada/salidas} pueda ser redirigida a un fichero. De esa manera
la entrada  a un  comando puede haber  sido almacenada  previamente; o
podemos  guardar  la salida  de  un  comando  en  un fichero  para  su
posterior análisis.

En  todo caso  la caraterística  de la  interfaz de  comandos que  nos
interesa es aquella que permite  redirigir la {\em salida estándar} de
un comando a la {\em entrada estándar} de otro.

\begin{verbatim}
[felix@localhost apuntes]$ cat pepe.txt | sort
[felix@localhost apuntes]$ ls -l | more
\end{verbatim}

En el ejemplo  anterior utilizamos el {\em metacaracter}  {\tt |} para
redirigir la salida del comando {\tt  cat} (es decir, el contenido del
fichero  {\tt pepe.txt})  a  la  entrada del  comando  {\tt sort}.  El
comando {\tt  sort}\index{Comandos!sort} toma las líneas  de texto que
provienen de la {\em entrada estándar},  las ordena, y las muestra por
su  {\em  salida estándar}.  Por  lo  tanto,  el ejemplo  muestra  por
pantalla el contenido de {\tt pepe.txt} ordenado alfabéticamente.

En el mismo ejemplo redirigimos la  salida de {\tt ls} al comando {\tt
more}.  El comando  {\tt more}\index{Comandos!more}  resulta muy  util
cuando el  contenido de  un fichero o  la salida de  un comando  es lo
suficientemente grande como para no  caber completa en la pantalla. En
esos casos  {\tt more} nos permite  ver el texto pantalla  a pantalla,
utilizando la barra espaciadora para avanzar por el mismo.

Un comando  mucho más  potente pero  con una  utilidad similar  a {\tt
more} es {\tt less}\index{Comandos!less}.

\begin{verbatim}
[felix@localhost apuntes]$ ls -l | less
\end{verbatim}

El comando {\tt less} nos permite utilizar las teclas del cursor, {\tt
Re. Pag.}  y {\tt Av.  Pag.} para avanzar  y retroceder por  el texto.
También  podemos iniciar  una búsqueda,  o continuar  una búsqueda  ya
iniciada, con las teclas {\tt /} y {\tt n} respectivamente. Muchas son
las características de {\tt less},  aunque nos conformaremos con saber
que con  {\tt h} podemos consultar  la ayuda del comando  mientras que
con {\tt q} salimos del mismo.

En general los  comandos que hemos estudiado son  programas de consola
como otros cualquiera. Por lo  tanto pueden ser llamados directamente,
e incluso en muchos casos disponen de opciones de línea de comandos.

\begin{verbatim}
[felix@localhost apuntes]$ sort -r pepe.txt
[felix@localhost apuntes]$ less pepe.txt
\end{verbatim}

\subsection{El comando {\tt man}}
\index{Comandos!man}

El comando {\tt  man} es muy útil, ya que  nos dará mucha información
sobre la mayoría de los comandos con los que vamos a trabajar.

\begin{verbatim}
[felix@localhost apuntes]$ man bash
\end{verbatim}

Omitimos  la información  de salida  ya que  puede ser  muy extensa  e
invita al lector a que lo pruebe él mismo.

En cualquier  caso, en  el tema \ref{documentacion}  estudiaremos este
comando con más detenimiento.

\subsection{El comando {\tt gzip}}
\index{Comandos!gzip}

El comando  {\tt gzip nombre\_fichero} comprime  un fichero utilizando
el algoritmo {\sf Lempel-Ziv}.

\begin{verbatim}
[felix@localhost apuntes]$ gzip pepe.txt
\end{verbatim}

Por regla  general el fichero  desaparece y en  su lugar se  crea otro
comprimido y con el mismo nombre más el sufijo {\tt .gz}.

La  descompresión  se  realiza  utilizando  la  opción  {\tt  -d}.  Es
importante destacar  que, al  igual que  antes, el  archivo comprimido
desaparece para dejar en su lugar la versión descomprimida.

\begin{verbatim}
[felix@localhost apuntes]$ gzip -d pepe.txt.gz
\end{verbatim}

Debido a la incomodidad de tener que comprimir/descomprimir para poder
acceder  a la  información son  muchos  los comandos  que cuentan  con
versiones especialmente diseñadas  para manipular archivos comprimidos
directamente. Es  el caso  de {\tt  zless}\index{Comandos!zless}, {\tt
zgrep}\index{Comandos!zgrep},  {\tt  zcat}\index{Comandos!zcat},  {\tt
zmore}\index{Comandos!zmore}, etc\dots

Pese  a lo  extendido  del uso  de  {\tt gzip}  en  la actualidad  hay
muchos otros  algoritmos con  ratios de  compresión mayores.  Por ello
se  han  creado comandos  compatibles,  en  cuanto  a opciones  de  la
línea  de  comandos,  con  {\tt   gzip},  pero  que  implementan  esos
otros  algoritmos. Es  el  caso  de {\tt  bzip2}\index{Comandos!bzip2}
y   de   los   comandos  {\tt   bzless}\index{Comandos!bzless},   {\tt
bzgrep}\index{Comandos!bzgrep},   {\tt   bzcat}\index{Comandos!bzcat},
{\tt bzmore}\index{Comandos!bzmore}, etc\dots

\subsection{El comando {\tt tar}}
\index{Comandos!tar}

El  comando {\tt  tar} permite  la  manipulación de  {\em ficheros  de
archivo} en  formato {\sf TAR}.  Dichos ficheros están  diseñados para
almacenar uno  o más  ficheros y/o directorios  y toda  la información
relacionada con  los mismos. Entre  esa información se  encuentran las
fechas  de acceso  y modificación,  los permisos,  el propietario,  el
grupo,  etc. El  origen del  comando {\tt  tar} se  remonta al  uso de
dipositivos sencuenciales  (como por  ejemplo cintas  magnéticas) para
almacenar  copias de  seguridad de  los  archivos del  sistema. En  la
actualidad no  es sino  una forma  de empaquetar  en un  único archivo
pedazos concretos del árbol de directorios de nuestro sistema.

Para crear  un archivo {\sf  TAR} basta  con que utilicemos  la opción
{\tt -c} seguida por la lista de ficheros y/o directorios que queremos
empaquetar. En general el archivo {\sf TAR} resultante es volcado a la
{\em  salida  estándar}.  Puesto  que eso  resulta  poco  práctico  es
habitual utilizar la opción {\tt -f} seguida del nombre del fichero de
destino.

\begin{verbatim}
[felix@localhost apuntes]$ tar -cf fichero.tar pepe.txt juan.txt /bin
\end{verbatim}

En el ejemplo  anterior {\tt fichero.tar} almacena  tanto los ficheros
{\tt pepe.txt} y {\tt juan.txt}  como el contenido del directorio {\tt
/bin}.

Los datos almacenados en los  ficheros {\sf TAR} no están comprimidos.
Por  ello es  habitual  utilizar  las opciones  {\tt  -z}  o {\tt  -j}
para  que {\tt  tar} pase  el  fichero por  {\tt gzip}  o {\tt  bzip2}
respectivamente, cuando termine de empaquetar los ficheros.

\begin{verbatim}
[felix@localhost apuntes]$ tar -zcf fichero.tar.gz pepe.txt /bin
\end{verbatim}

Para recuperar los ficheros originales se sustituye la opción {\tt -c}
por {\tt  -x}, mientras que  para verificar la integridad  del archivo
sin tener que desempaquetarlo se utiliza la opción {\tt -t}.

\begin{verbatim}
[felix@localhost apuntes]$ tar -xf fichero.tar
[felix@localhost apuntes]$ tar -zxf fichero.tar.gz
[felix@localhost apuntes]$ tar -ztf fichero.tar.gz
\end{verbatim}

\subsection{El comando {\tt grep}}
\index{Comandos!grep}

Cuando deseamos  localizar un cadena de  texto dentro de uno  o varios
ficheros  solemos  recurrir  al  comando  {\tt  grep}.  Dicho  comando
requiere que  se especifique la cadena  de texto a buscar  seguida del
nombre de  los ficheros en  los que  realizar la búsqueda.  Puesto que
alguno de los  caracteres de la cadena de texto  a buscar pueden tener
algún significado especial  para la interfaz de  comandos dicha cadena
suele ir entrecomillada.

\begin{verbatim}
[felix@localhost apuntes]$ grep 'felix' *
[felix@localhost apuntes]$ grep 'CaSa' pepe.txt
\end{verbatim}

Como  se puede  observar, en  el  primer ejemplo  estamos buscando  la
cadena  de  texto \verb|'felix'|  dentro  de  todos los  ficheros  del
directorio actual.

En  general {\tt  grep}  es  sensible a  mayúsculas  y minúsculas.  Si
queremos eliminar dicho comportamiento  podemos emplear la opción {\tt
-i}.  También  podemos pedir  que  nos  indique  donde {\bf  NO}  está
la  cadena indicada  utilizando  la  opción {\tt  -v}.  Por otro  lado
las  búsquedas  pueden  extenderse por  directorios  y  subdirectorios
utilizando la opción {\tt -r}.

En realidad  {\tt grep} no  sólo nos permite utilizar  simples cadenas
para buscar dentro  de los ficheros indicados. El  comandos {\tt grep}
nos permite utilizar {\em expresiones  regulares}. Es decir, dentro de
nuestra cadena de texto podemos utilizar caracteres con un significado
especial con los  que podemos buscar casi cualquier  tipo de expresión
entre nuestros archivos. Puesto que las expresiones regulares se salen
completamente  del  alcance de  este  tema  recomendamos consultar  la
página correspondiente del manual.

\begin{verbatim}
[felix@localhost apuntes]$ man grep
\end{verbatim}

\subsection{Otros comandos}

\begin{description}

\item [clear]\index{Comandos!clear}  Limpia la pantalla de  la consola
(tecla {\tt C-l})

\item  [locate]\index{Comandos!locate} Es  la  orden  de búsqueda  más
rápida y sencilla para localizar un archivo.

\item  [reset]\index{Comandos!reset} Si  observamos que  escribimos en
pantalla y no aparece el texto pero al pulsar {\tt ENTER} realmente se
está escribiendo,  o que  los colores  o los textos  de la  consola se
corrompen,  puede  ser  que  alguna  aplicación  en  modo  texto  haya
finalizado  bruscamente  no restaurando  los  valores  estándar de  la
consola  al  salir.  Con  esto  forzamos  unos  valores  por  defecto,
regenerando la pantalla.

\item [top]\index{Comandos!top}  Muestra los procesos que  se ejecutan
en  el  momento  actual,  informando  de los  recursos  que  se  están
consumiendo.

\item  [whoami]\index{Comandos!whoami}  El   curioso  nombre  de  este
comando proviene {\em  Who am I?} ({\em ¿Quién soy?}),  que indica que
este comando es capaz de informarnos  del nombre de usuario con que se
entró en esa consola. Puede parecer  una tontería, pero si una persona
entra en dos sesiones,  en una como {\tt root} y  en otra como usuario
normal,  si no  se  sabe  quién es  en  ese  momento, podrían  ocurrir
accidentes catastróficos.

\end{description}

\section{Unidades de disco}

Como hemos dicho anteriormente, en  Linux no existen las unidades como
{\tt A:} o {\tt C:}. Para acceder a un disco es necesario primero {\em
montarlo}\index{Montar}, esto  es asignarle un lugar  dentro del árbol
de directorios del sistema.

Por  ejemplo,  podemos asignar  a  la  disquetera el  directorio  {\tt
/floppy}, al CD-ROM el directorio {\tt /cdrom} o a la grabadora de CDs
el  directorio {\tt  /grabata}.  Normalmente los  directorios para  la
disquetera y el  lector de CD-ROM están ya asignados  desde el momento
de instalar el  sistema, aunque se puede cambiar a  voluntad (si somos
{\tt root} ;-).

Para    montar     un    disco    utilizamos    el     comando    {\tt
mount}\index{Montar!mount} indicándole como  parámetros el dispositivo
al que queremos acceder, el directorio en el que lo queremos montar, y
el  sistema de  archivos utilizado  para ordenar  la información.  Sin
embargo,  el  administrador ({\tt  root})  suele  indicar todos  estos
parámetros  en el  fichero {\tt  fichero}, y  los usuarios  tienen que
conformarse montar lo  que {\tt root} les permita. En  nuestro caso el
señor {\tt root}  ha determinado que los usuarios  sólo podemos montar
la disquetera en el directorio {\tt /floppy}.

\begin{verbatim}
[miguev@euler apuntes]$ mount /dev/fd0 /floppy
mount: only root can do that
[miguev@euler apuntes]$ mount /floppy
\end{verbatim}

Una vez montado el disquete en  el directorio {\tt /floppy} ya podemos
acceder  y  manipular  sus  ficheros y  subdirectorios  como  más  nos
convenga. Desde la  perspectiva del usuario no  hay ninguna diferencia
entre trabajar en ese directorio y trabajar en otro cualquiera.

Pobre de quien  saque el disquete sin desmontarlo. ¿Por  qué? Pues por
tres razones:

\begin{enumerate}

\item  Existe el  riesgo de  que perdamos  la información  que hayamos
grabado en el disquete.

\item Ningún otro usuario podrá usar la disquetera, al menos hasta que
se reinicie el  ordenador o el {\tt root} tenga  tiempo para forzar el
que la unidad sea desmontanda, lo cual no le hará gracia a nadie.

\item El  Sr. root puede  mosquearse con quien lo  haga, y a  nadie le
conviene tener mosqueado al Sr. root.

\end{enumerate}

Para desmontar el disquete simplemente utilizamos el sencillo comando
{\tt umount}\index{Montar!umount}:

\begin{verbatim}
$ umount /floppy
\end{verbatim}

Como último ejemplo, hagamos lo siguiente:

\begin{verbatim}
$ mount /floppy
$ cd /floppy
$ umount /floppy
\end{verbatim}

¿Verdad que no funciona? Esto se debe a que en el momento de desmontar
la  disketera, {\bf  no debe  haber NADIE  dentro} de  ese directorio.
Recordemos que estamos en un  sistema multiusuario y puede ocurrir que
más  de  una persona  acceda  a  la  disketera  o a  otro  dispositivo
desmontable, como  el CD-ROM. Por  tanto, hemos de asegurarnos  que no
hay nadie.

Para comprobar en un momento dado  si el disquete está montado podemos
usar el comando {\tt df}\index{Comandos!df}, que nos informa sobre los
{\em  sistemas  de  ficheros}  que  están  montados  y  su  estado  de
almacenamiento.  La opción  {\tt  -h} nos  muestra  las cantidades  en
cifras {\em humanas}.

\begin{verbatim}
[miguev@euler apuntes]$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda2             1.9G  1.8G   80M  96% /
euler:/home            20G  3.2G   16G  17% /home
euler:/usr/soft       3.9G  5.4M  3.7G   0% /usr/soft
/dev/fd0              1.4M  758k  665k  53% /floppy
\end{verbatim}

Aquí  vemos  que la  segunda  partición  del  primer disco  duro  {\tt
/dev/hda2} está montada en el directorio {\tt /}, los directorios {\tt
/home} y  {\tt /usr/soft} del  servidor {\tt euler} están  montados en
sus equivalente locales, y el  disquete {\tt /dev/fd0} está montado en
el directorio {\tt /floppy}.

\section{Unidades de disco con Mtools}

En general,  la mayor parte  de los  disquetes que solemos  usar están
en  formato  DOS/Windows.  Cuando  disponemos de  uno  esos  disquetes
podemos  acceder  a  su  contenido  de forma  sencilla  con  las  {\sf
Mtools}\index{Mtools}.

{\sf Mtools} es  una colección de herramientas de  dominio público que
permite a sistemas  UNIX manipular ficheros en un  sistema de archivos
DOS/Windows (típicamente un disquete). {\sf Mtools} es suficiente para
dar acceso  a sistemas de  archivos DOS/Windows. Por  ejemplo, órdenes
como  {\tt mdir  a:}  funcionan en  el disquete  {\tt  A:} sin  ningún
montaje preliminar ni otro procedimiento  de inicio (suponiendo que el
{\tt /etc/mtools.conf}  sea correcto). Gracias  a todo ello,  con {\sf
Mtools} uno puede cambiar disquetes sin tener que desmontar y montar.

\subsection{Nombres de ficheros}

Muchas  de  las   herramientas  de  {\sf  Mtools}   requieren  que  se
especifiquen nombres de archivo en  el sistema de archivos DOS/Windows
al que  estamos accediendo.  Las rutas  de ficheros  en el  sistema de
archivos DOS/Windows  se componen de:  una {\em letra  de dispositivo}
seguida de  dos puntos, un subdirectorio  y un nombre de  fichero. Los
nombres de  directorio pueden  emplear como separador  {\tt /}  o {\tt
$\backslash$}. El  uso del  separador {\tt $\backslash$}  requiere que
los nombres se entrecomillen para protegerlos, por lo que recomendamos
utilizar  {\tt /}  con  el fin  de evitar  problemas.  Los nombres  de
ficheros  que  no  van  precedidos  de una  letra  de  dispositivo  se
consideran ficheros del sistema UNIX.

Por ejemplo,  el siguiente  comando copia  el archivo  {\tt TEST1.TXT}
desde  el directorio  {\tt TEST}  del primer  dispositivo de  disquete
({\tt A:}), hasta nuestro directorio  de trabajo actual, con el nombre
de archivo {\tt test2.txt}.\label{mcopyej}

\begin{verbatim}
$ mcopy 'a:\TEST\TEST1.TXT' test2.txt
\end{verbatim}

que es completamente equivalente a:

\begin{verbatim}
$ mcopy a:/TEST/TEST1.TXT test2.txt
\end{verbatim}

Como  es obvio  las  {\sf  Mtools} no  distinguen  entre mayúsculas  y
minúsculas  en  el acceso  al  sistema  de archivos  DOS/Windows.  Sin
embargo, si permiten la utilización de  comodines (como {\tt *} o {\tt
?}) tanto cuando especificamos un nombre de archivo Linux, como cuando
hacemos lo mismo con nombres de archivo DOS/Windows.

En cuanto a  las letras de dispositivo, comúnmente la  unidad {\tt A:}
es la  primera unidad de  disquete, la unidad  {\tt B:} es  la segunda
unidad de disquete,  la unidad {\tt J:}  es una unidad {\em  Jaz} y la
unidad  {\tt Z:}  es  una  unidad {\em  Zip}.  Sin  embargo todo  esto
puede  ser  configurado  mediante  el fichero  de  configuración  {\tt
/etc/mtools.conf}.

\subsection {Lista de comandos}

A continuación presentamos  algunos de los comandos  más utilizados de
las {\sf Mtools}.

\subsubsection{mattrib}\index{Mtools!mattrib}

Se emplea para cambiar los  atributos de ficheros DOS/Windows de forma
semejante a como lo hace el comando {\tt ATTRIB} del MS-DOS.

\subsubsection{mcd}\index{Mtools!mcd}

El comando {\tt mcd } se  emplea para cambiar el directorio de trabajo
actual de {\sf Mtools} en los discos DOS/Windows.

\begin{verbatim}
$ mcd <directorio_dos>
\end{verbatim}

Sin argumentos, {\tt mcd} informa de la unidad y directorio de trabajo
actuales. De otra forma, mcd cambia la unidad en curso y el directorio
de trabajo relativos a un sistema de archivos DOS/Windows.

Por ejemplo, si ejecutamos la siguiente secuencia de comandos:

\begin{verbatim}
$ mcd a:/TEST
$ mcopy a:TEST1.TXT test2.txt
\end{verbatim}

Copiaríamos  el  archivo  {\tt  TEST1.TXT}   tal  y  como  lo  hicimos
anteriormente (página \pageref{mcopyej}).

A diferencia de los sistemas DOS/Windows, con {\sf Mtools} sólo hay un
directorio  de  trabajo  actual  para  todas las  unidades,  y  no  un
directorio de trabajo diferente para cada unidad.

\subsubsection{mcopy}\index{Mtools!mcopy}

El comando {\tt mcopy} permite  copiar ficheros desde o hacia sistemas
de archivos DOS/Windows. Las formas de uso son:

\begin{verbatim} 
$ mcopy fichero_fuente fichero_destino
$ mcopy fichero_fuente <fichero_fuente> directorio_destino
$ mcopy fichero_fuente_dos
\end{verbatim}

El comando copia el {\tt fichero\_fuente} al {\tt fichero\_destino}, o
copia múltiples ficheros  al directorio de destino  indicado. Fuente y
destino pueden ser ficheros de DOS o de Linux. La presencia, o no, del
indicador de  letra del dispositivo  es el que determina  que ficheros
son de DOS y cuales de Linux.

Si sólo  se suministra uno  de los  parámetros fuente, se  supone como
destino el directorio actual de trabajo en el sistema Linux.

\subsubsection{mdel}\index{Mtools!mdel}

El comando {\tt mdel} se emplea para borrar ficheros.

\begin{verbatim}
$ mdel fichero_dos
\end{verbatim}

Por ejemplo:

\begin{verbatim}
$ mdel a:/TEST2.TXT
\end{verbatim}

\subsubsection{mdeltree}\index{Mtools!mdeltree}

El  comando  {\tt  mdeltree}  se utiliza  para  borrar  un  directorio
DOS/Windows y todos sus archivos y subdirectorios.

\begin{verbatim}
$ mdeltree directorio_dos
\end{verbatim}

\subsubsection{mdir}\index{Mtools!mdir}

El  comando {\tt  mdir}  se emplea  para mostrar  el  contenido de  un
directorio DOS/Windows.

\begin{verbatim}
$ mdir <directorio_dos>
\end{verbatim}

Por ejemplo:

\begin{verbatim}
$ mdir a:
 Volume in drive A has no label
 Volume Serial Number is 3E48-13E9
Directory for A:/

TRABAJO  TXT     13838 11-01-1993   3:11
PROGRA~1 EXE    268232 12-14-2002  22:15  programinstall.exe
TEST         <DIR>     12-14-2002  22:13
        3 files             282 070 bytes
                          1 174 528 bytes free
\end{verbatim}

\subsubsection{mformat}\index{Mtools!mformat}

El comando {\tt mformat} se utiliza  para crear un sistema de archivos
DOS/Windows vacio en la unidad indicada.

\begin{verbatim}
$ mformat <unidad:>
\end{verbatim}

\subsubsection{mmd}\index{Mtools!mmd}

El comando  {\tt mmd} se emplea  para crear un nuevo  directorio en un
sistema  de archivos  DOS.  El comando  informará de  un  error si  el
directorio ya existe.

\begin{verbatim}
$ mmd directorio_dos
\end{verbatim}

\subsubsection{mmove}\index{Mtools!mmove}

El comando {\tt  mmove} se utiliza para mover o  renombra un fichero o
subdirectorio  existente en  un sistema  de archivos  DOS/Windows. Las
formas de uso son:

\begin{verbatim} 
$ mmove fichero_fuente fichero_destino
$ mmove fichero_fuente <fichero_fuente> directorio_destino
$ mmove directorio_fuente directorio_destino
\end{verbatim}

\subsubsection{mrd}\index{Mtools!mrd}

El comando {\tt mrd} se emplea para borrar un directorio de un sistema
de  archivos  DOS/Windows. El  comando  volverá  con  un error  si  el
directorio no existe o no está vacío.

\begin{verbatim}
$ mrd directorio_dos
\end{verbatim}

\subsubsection{mtype}\index{Mtools!mtype}

El  comando  {\tt mtype}  muestra  el fichero  DOS/Windows
especificado, en la pantalla o en la salida estándar.

\begin{verbatim}
$ mtype fichero_dos
\end{verbatim}
