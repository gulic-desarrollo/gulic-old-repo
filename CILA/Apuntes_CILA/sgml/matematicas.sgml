
  <sect>Matemáticas en GNU/Linux

    <sect1>Documentos y fórmulas matemáticas

      <sect2> LaTeX 

<p>
<quote> TeX  (pronunciado  &quot;Tek&quot;)  es el  más
potente procesador de <tt/textos/ orientados a documentos científicos,
aunque puede ser  usado para cualquier tipo de documento.  LaTeX es un
lenguaje estructurado para la elaboración de documentos, desde apuntes
(quedan muy  bien) hasta libros completos,  problemas, boletines, etc.
Una de las  principales diferencias entre LaTeX y  los procesadores de
texto al uso es que a diferencia  de estos últimos LaTeX no cuenta con
una interface WYSWYG, sino que por el contrario, un domumento en LaTeX
ha de ser escrito en forma de fichero fuente para luego ser compilado.
Esto se  puede interpretar de dos  maneras, o un gran  inconveniente o
una gran ventaja. </quote>

<quote> La  primera versión  de TeX,  obra de  Donald E.  Knuth (DEK),
nació a  principios de  los años  ochenta. Esta  versión, si  bien muy
potente, era extremadamente  dificil de usar, por lo que  el mismo DEK
desarrolló la primera ampliación de TeX, el plain TeX. </quote>

<quote> El Plain TeX introducía gran  número de órdenes de alto nivel,
pero seguía  estando más  orientado a aspectos  tipográficos que  a la
estructura de  los documentos como un  todo Por ello, en  1985, Leslie
Lamport  desarrolló un  lenguaje  construido sobre  el  Plain TeX  que
recibió  el  nombre  de  LaTeX  dirigidos  a  confeccionar  documentos
completos (artículos o libros). Desde  su aparición, LaTeX ha conocido
una  gran  difusión  en  el  ámbito  científico,  siendo  hoy  día  el
procesador  más  usado  por  matemáticos, físicos  y  gran  número  de
ingenieros. </quote>


<quote> El futuro  del LaTeX depende no sólo de  si mismo sino también
de  los avances  en  otros procesadores,  en la  medida  en que  estos
incorporen  las herramientas  y  la flexibilidad  de este  procesador,
podrán sustituirlo. Dada la desatención  de las grandes compañías a la
comunidad científica internacional, parece que  el futuro del LaTeX es
todavía prometedor. Aparte de por una gran ventaja que lo distingue de
AmiPro, Word o WordPerfect. El LaTeX es freeware. </quote>


<quote> Veamos  la versatilidad de  LaTeX aplicada a  las matemáticas,
con  un  ejemplo  no  demasiado sencillo.  Las  líneas  que  comienzan
por  el  caracter  <tt/%/  (porcentaje) son  comentarios,  y  explican
suficientemente el contenido del  fichero. Veamos cómo podemos obtener
distintos  ficheros de  salida,  en formatos  PostScript  y PDF  entre
otros.  En el  fichero <tt/ejemplo.tex/  tenemos el  siguiente código:
</quote>

<code>
% BEGIN: Ejemplo 1 de LaTeX para CILA

% Define el  tipo de documento  como "article" (artículo)  y especifica
% las opciones "a4paper" (tamaño de  papel A4), "12pt" (tamaño de letra
% a 12 puntos) y "twoside" (para imprimir a doble cara)
\documentclass[a4paper,12pt,twoside]{article}

% Utiliza  el  paquete "inputenc"  con  la  opción "latin1",  esto  nos
% permite teclear  las "ñ" y las  tildes sin tener que  preocuparnos de
% nada, porque el charset que estamos  usando el latin1 y se lo decimos
% a LaTeX
\usepackage[latin1]{inputenc}

% Utiliza el  paquete "babel" con  la opción "spanish", lo  que incluye
% entre  otras  cosas  patrones  de silabeo,  traducción  de  elementos
% insertados  automáticamente,  como  "Índice   general"  en  lugar  de
% "Contents"
\usepackage[spanish]{babel}

% Utiliza el  paquete amssymb,  American Mathematical  Society SYMbols,
% (símbolos de  la Sociedad Matemática  Americana). Es este  paquete se
% encuentra  por ejemplo  el símbolo  de "isomorfo  a" utilizado  en el
% Teorema de Isomorfía.
\usepackage{amssymb}

% Utiliza el paquete  "eurosym" para proporcionar el  símbolo del euro.
% Con este  paquete podemos escribir el  símbolo del euro con  la orden
% \euro
\usepackage{eurosym}

% Ordenamos a LaTeX que no numere  las páginas, ya que tenemos una sóla
% página y un "1" solitario no queda muy bien.
\pagestyle{empty}

% Evita que  LaTeX introduzca  espacios mayores de  lo normal  tras los
% finales de las oraciones. Una pijada.
\frenchspacing

\begin{document} % Comienza el documento

% Esta frase estará centrada y con un tamaño de letra mayor
\begin{center}
{\large Curso de Introducción a Linux para Alumnos}
\end{center}

Esto es un  pequeño ejemplo de {\LaTeX}, el más  potente procesador de
textos. La mayoría  de apuntes y exámenes de Matemáticas  que vemos en
la  Facultad están  escritos  en {\LaTeX}.  Por  cierto, con  {\LaTeX}
también estamos preparados para la llegada del \euro

A continuación algunos ejemplos de fórmulas matemáticas:

% Comenzamos una descripción de varios "items"
\begin{description}

\item [Definición de límite (Análisis Matemático I)]
$$
\lim_{x \longrightarrow a} = l \iff 
\forall \, \varepsilon > 0 \,
\, \exists \, \delta > 0 \, / \,
\, 0 < \| x - a \| < \delta \,
\Longrightarrow \, \| f(x) - l \| < \varepsilon
$$

\item [Teorema Generalizado de Cauchy (Análisis Matemático I)]
Si $f$ y $g$ tienen derivadas contínuas hasta el orden $n(n-1)$ en 
el intervalo $\lbrack a , b \rbrack$ y además $\forall \, x \in (a,b)
\, \, \exists \, f^{n)}(x), g^{n)}(x)$, entonces
$\exists \, c \in (a,b) \, /$
$$
\bigg( f(b) - \sum_{k=0}^{n-1} \frac{f^{k)}(a)}{k!}(b-a)^k \bigg) g^{n)}(x) =
f^{n)}(x) \bigg( g(b) - \sum_{k=0}^{n-1} \frac{g^{k)}(a)}{k!}(b-a)^k \bigg) 
$$

\item [$1^{er}$ Teorema de Isomorfía (Álgebra I)]
Sean $G$, $G'$ grupos, $f : G \longrightarrow G'$
homomorfismo de grupos. Entonces
$$
\frac{G}{Ker(G)} \, \thickapprox \, Im f
$$

\item [Funciones Eulerianas: Gamma y Beta (Análisis Matemático II)]
$$
\Gamma(p) = \int_{0}^{+\infty} e^{-x} x^{p-1} dx \quad \forall \, p > 0
$$
$$
\beta(p,q) = \int_{0}^{1} x^{p-1} (1-x)^{q-1} dx
$$

\item [Y por último, un ejemplo denso]
$$
\sum \limits_{n = 0}^{\infty} 
\left(
  \frac
    {\int \limits_{-\infty}^{+\infty}
      {\left\lceil 
        \frac
          {\sin 
      	    \left[ 
    	      8 \frac{\pi}{3}^3
    	    \right]}
          {\arctan \left(
    	    \sqrt[3]{ 2 \cdot \sin {(x)} }
    	  \right)}
      \right\rceil 
      dx}
    }
    {\lim \limits_{x \to n^2}
      \left(
        \vert{
          \frac
    	    {\log
    	      {\frac
    	        {\pi}
      	        {x^4}
    	      }
    	    }
            {e^{
    	      \frac
    	        {n + 1}
    	        {n - 1}
    	      }
            }
        \vert}
      \right)
    }
\right)
=
\left|
  \begin{array}{cccc}
    m_{(i,j)}   & m_{(i,j+1)}       & \ldots   & m_{(i,n)}     \\
    m_{(i+1,j)} & m_{(i+1,j+1)}     & \ldots   & m_{(i+1,n)}   \\
    \vdots        & \vdots              & \ddots & \vdots          \\
    m_{(n,j)}   & m_{(i + n,j + 1)} & \ldots   & m_{(n,n)}
  \end{array}
\right|
$$

\end{description}

\end{document} % Termina el documento

% END: Ejemplo 1 de LaTeX para CILA
</code>

<quote>  Copiamos   esta  fórmula   en  algún  fichero,   por  ejemplo
<tt/ejemplo.tex/ y  veamos los pasos necesarios  para <em/compilarlo/.
Para compilar el  fuente lo único que hay que  hacer es ejecutar LaTeX
seguido del nombre  del fichero fuente LaTeX. En  nuestro ejemplo, nos
colocaremos  en  el directorio  donde  tenemos  el <tt/ejemplo.tex/  y
teclearemos:</quote>

<code>
$ latex ejemplo.tex
</code>

<quote> Esto generará varios ficheros,  pero el que realmente interesa
en estos momentos es <tt/ejemplo.dvi/. Este fichero es el resultado de
la compilación  y lo  podemos ver usando  por ejemplo  <tt/xdvi/. Para
verlo teclearemos en el mismo directorio en el que está el fichero
</quote>

<code>
xdvi ejemplo.dvi
</code>

<quote> Dado que el formato  <tt/DVI/ (DeVice Independent) no está muy
extendido se  han generado conversores  de formato, de tal  manera que
podemos  pasar  desde  dvi  a  formato  <tt/PostScript/  y  a  formato
<tt/PDF/, ambos mucho más extendidos que el dvi. Para pasar un fichero
generado por  LaTeX en formato  <tt/DVI/ a un  fichero <tt/PostScript/
usaremos el comando <tt/dvips/ de la siguiente manera: </quote>

<code>
$ dvips ejemplo.dvi -o ejemplo.ps
</code>

<quote> Ahora podemos  ver el resultado con  cualquier visualizador de
ficheros PostScript, por ejemplo <tt/gv/: </quote>

<code>
$ gv ejemplo.ps
</code>

<quote>Una  vez comprobado  que  todo va  bien  intentemos pasar  este
último  fichero   en  formato  <tt/PostScript/  a   formato  <tt/PDF/.
Para  ello  usaremos   el  comando  <tt/ps2pdf/  como   se  explica  a
continuación:</quote>

<code>
$ ps2pdf ejemplo.ps ejemplo.pdf
</code>

<quote> Y una  vez hecho esto ya podemos usar  nuestro visualizador de
PDF preferido para ver el <tt/ejemplo.pdf/. </quote>

<quote> Esta ha sido una muy  breve introducción a LaTeX que esperamos
haya  sido  suficiente como  para  que  os  pique  el gusanillo  y  os
introduzcais en el maravilloso mundo del LaTeX. </quote>

      </sect2>

      <sect2> LyX

<p>
<quote> LyX es un procesador de  textos avanzado, basado en LaTeX, que
permite  crear documentos  de calidad  de forma  más sencilla  que con
LaTeX. Aunque LyX utiliza LaTeX, es mucho más que una simple interface
para  LaTeX,  también  puede  generar otros  formatos.  Una  cosa  muy
interesante de LyX  es que permite insertar código de  LaTeX, de forma
que los conocimientos  sobre LaTeX pueden aplicarse también  al uso de
LyX aunque no sean necesarios. </quote>

<quote> Debido a la brevedad del presente curso, no nos entretendremos
en el uso de LyX, ya  que éste proporciona una sencilla introducción y
un  breve  tutorial  en  castellano  que  son  ayuda  suficiente  para
comenzar a escribir  apuntes, trabajos, cartas y  otros documentos sin
necesidad de estudiar nada complicado.  Para leer la introducción y el
tutorial  de LyX  basta con  elegir <tt/Introducción/  o <tt/Tutorial/
respectivamente en el menú <tt/Ayuda/.  En el mismo menú se encuentran
los restantes capítulos de la documentación de LyX en inglés: <tt/Guía
del  usuario/, <tt/Características  extendidas/, <tt/Personalización/,
<tt/Manual de  referencia/, <tt/Preguntas  de uso frecuente/  y otros.
</quote>


      </sect2>

    </sect1>

    <sect1>Software de cálculo y representación.

<sect2> Octave

<p>
<quote> Octave se puede definir como un lenguaje de alto nivel pensado
para  cálculos numéricos,  en especial  para trabajar  con matrices  y
vectores. Se puede usar para resolver numéricamente problemas lineales
o no lineales, o para hacer otros tipos de experimentos numéricos. Los
comandos que  se quieren ejecutar se  pueden escribir interactivamente
en  una  línea  de  comandos,  o  bien,  en  caso  de  que  se  quiera
automatizar una ejecución, se puede escribir el script correspondiente
y ejecutarlo de manera sencilla. </quote>

<quote> Para ejecutar Octave de manera interactiva, se abre un shell y
se teclea <tt/octave/, tras lo que aparece un prompt y queda preparado
a la espera de que teclees comandos. </quote>

<code>
alberto@mencey:~$ octave
GNU Octave, version 2.1.34 (i386-pc-linux-gnu).
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 John W. Eaton.
This is free software with ABSOLUTELY NO WARRANTY.
For details, type `warranty'.

octave:1> 
</code>

<quote>  Si quieres  salir  al  shell desde  dentro  de Octave  teclea
<tt/exit/,  <tt/quit/  o   <tt/CTRL+D/.  Para  hacer  representaciones
gráficas deberás haber ejecutado Octave desde un shell dentro de las X
puesto que la  representación gráfica se realiza  usando Gnuplot, cuya
forma de funcionar por defecto es en entorno X-Window. </quote>

<quote> Existen varias maneras de  documentarse sobre la forma de usar
Octave.</quote>

<itemize>

<item> Si quieres  ir relajadamente y de forma  ordenada mirando cosas
por tu cuenta, la mejor fuente, aunque no siempre actualizada, es abrir
un shell y ejecutar:

<code>
alberto@mencey:~$ info octave
</code>

Podrás navegar por una ayuda detallada,  mientras por el otro lado vas
trabajando, y  en la que  se describen las funciones  documentadas del
programa, pero  clasificadas por  materias y  explicadas de  una forma
cuidadosa.  Usa  <tt/tabulador/,  <tt/flechas/, <tt/enter/  y  <tt/u/,
<tt/s/ para  buscar y  <tt/q/ para  salir. Si ya  eres un  usuario mas
avanzado, puedes  pasearte por el  árbol de directorios que  cuelga de
<tt>/usr/share/octave</tt>


<item>  Para   el  más  osado,  escribiendo   sencillamente  <tt/help/
aparece el  gigantesco listado de funciones  disponibles descompuestas
en  categorías  que  se  puede  visualizar  con  las  flechas,  teclas
<tt>Home/RePag/AvPag/End</tt> y q para regresar a la línea de comandos
(también regresa  pasando el  final). Esta es  la ayuda  más completa,
pues presenta todas las funciones  existentes en el sistema, muchas de
las cuales a lo mejor no están agregadas en el <tt/info/.


<item>  Para  obtener ayuda  de  una  función en  particular,  teclear
<tt/help  nombredelafuncion/.  Si  el  lector  teclea  los  siguientes
ejemplos, obtendrá, aparte  del resultado que se  transcribe aquí, una
coletilla  que informa  sobre como  obtener ayuda  desde el  entorno o
en  la WWW.  La  omitiremos  para clarificar  y  ahorrar espacio.  Por
ejemplo, veamos que  resulta de ver la ayuda de  la función cotangente
hiperbólica:

<code>
octave:2> help coth
coth is the user-defined function from the file
/usr/share/octave/2.1.34/m/elfun/coth.m

 - Mapping Function:  coth (X)
     Compute the hyperbolic cotangent of each element of X.
</code>

La mayoría de los comandos complejos de Octave disponen de esta ayuda.
Vemos que se  nos dice una descripción  de los parámetros y  de lo que
realiza la función, lo cual es suficiente para que podamos utilizarla.
Para el autodidacta, solo tienes que ir al listado largo, quedarte con
la categoría  que te interese, e  ir chequeando cada función  a ver si
hace lo que nos interesa.

</itemize>

<quote>  Si leemos  más detenidamente  el principio  de la  ayuda, nos
comenta que <tt/coth(X)/ es una función  definida por el usuario en un
fichero  situado en  <tt>/usr/share/octave/version/m/elfun/coth.m</tt>
Si  tenemos curiosidad  por ver  ese fichero,  descartando comentarios
precedidos por <tt>##</tt>, observamos lo siguiente: </quote>

<code>
function w = coth (z)

  if (nargin != 1)
    usage ("coth (z)");
  endif

  w = cosh (z) ./ sinh (z);

endfunction
</code>

<quote>  Como  el  lector  ha  visto,  así  es  como  se  amplían  las
capacidades  de  Octave  y   se  implementan  nuevos  comandos.  Todas
las  funciones  que  has  visto  en  el  listado  largo  (excepto  las
nativas)  proceden  de  ficheros  <tt/*.m/,  por  lo  que  puedes  ver
incluso  de  que  forma   están  implementadas  simplemente  hiendo  a
<tt>/usr/share/octave</tt>,   localizándolas  y   mirándolas  por   tí
mismo.  Si  durante su  uso  diario  encuentras  algún defecto  en  su
funcionamiento, tú mismo  puedes ir a su código fuente  y comprobar si
el fallo es tuyo o es de la función, en este caso podrás contribuir al
proyecto  enviando la  notificación del  bug  y su  corrección, si  la
conoces. </quote>

<quote> Ni  que decir  tiene que puedes  crear tus  propias funciones,
siguiendo   unas  pequeñas   reglas   que  puedes   consultar  en   la
documentación, y si las  colocas dentro de <tt>/usr/share/octave</tt>,
serán  añadidas al  listado como  si  de las  funciones originales  se
tratasen. Si la función que  has creado es interesante, siempre puedes
enviarla a  los autores de Octave  para que la incluyan  en la próxima
versión. </quote>

<quote>  Si, de  igual forma  hacemos help  sobre comandos  nativos de
Octave: </quote>

<code>
octave:3> help sinh
help: sorry, `sinh' is not documented
octave:4> help cosh
help: sorry, `cosh' is not documented
</code>

<quote> Octave  nos da un mensaje  de error puesto que  esa función no
esta implementada  mediante un fichero <tt/*.m/,  una función definida
por el usuario,  sino que es una función nativa  del lenguaje. También
existen otras funciones, con extensión  <tt/*.oct/ que no son visibles
pues están compiladas para optimizar su rendimiento, como por ejemplo:
</quote>

<code>
octave:5> help lsode
lsode is the dynamically-linked function from the file
/usr/lib/octave/2.1.34/oct/i386-pc-linux-gnu/lsode.oct
...
</code>

<quote> Los  tipos de  datos en  Octave son  los vectores  y matrices,
strings y  estructuras. Las  matrices y vectores  son los  más usados,
los  strings  no  se  suelen  usar sino  para  presentar  mensajes,  y
las  estructuras  suelen ser  una  buena  base para  organizar  tareas
complicadas, pero  no se  tratarán aquí. En  el siguiente  log veremos
definiciones de cada uno de ellos. </quote>

<code>
octave:6> a=[1,2,3] 
a =
  1  2  3

octave:7> b=[1,2,3;4,5,6;7,8,9]
b =
  1  2  3
  4  5  6
  7  8  9

octave:8> c="hola mundo"
c = hola mundo

octave:9> d.vector=[1,2];
octave:10> d.matriz=[1,2;3,4];
octave:11> d 
d =
{
  vector =
    1  2

  matriz =
    1  2
    3  4
}
</code>

<quote>  Se  hace  necesario  anotar  una  característica  introducida
sutilmente en  este último  ejemplo. Un  punto y coma  al final  de la
línea le  dice a Octave que  no muestre ninguna salida  al ejecutar el
comando.  Así, en  el ejemplo,  las  asignaciones a  la estructura  no
mostraron mensaje pues tenían <tt>;</tt> al final. </quote>

<quote> También añadiré que para mostrar el valor de una variable solo
hay que introducir su  nombre, tal como se ha hecho  en el ultimo paso
del ejemplo  anterior. Si queremos  ver que variables existen  en este
momento  en  el  programa,  simplemente  tecleamos  <tt/who/  (versión
reducida) o <tt/whos/ (versión larga). </quote>

<code>
octave:12> who

*** currently compiled functions:
coth

*** local user variables:
a  b  c  d

octave:13> whos

*** currently compiled functions:
prot  type                       rows   cols  name
====  ====                       ====   ====  ====
 rwd  user-defined function         -      -  coth

*** local user variables:
prot  type                       rows   cols  name
====  ====                       ====   ====  ====
 rwd  matrix                        1      3  a
 rwd  matrix                        3      3  b
 rwd  string                        1     10  c
 rwd  struct                        -      -  d
</code>

<quote>  Como  curiosidad,  añadir  que Octave,  la  primera  vez  que
ejecutas  una  función  de  usuario, realiza  una  parte  de  análisis
sintáctico para verificación de la  función y luego compila la función
para  seguidamente ejecutarla,  todo  esto de  forma transparente.  La
segunda vez  que ejecutas  la función,  si el  fuente no  ha cambiado,
aprovecha  la compilación  anterior  y pasa  a ejecutar  directamente,
ahorrando un tiempo precioso en el proceso. </quote>

<quote> Otro aspecto muy útil  es que Octave posee estructuras típicas
de lenguajes de programación propiamente dichos, como son: <tt/if/,
<tt/switch/, <tt/while/, <tt/do-until/,  <tt/for/, <tt/break/,
<tt/continue/, y <tt/unwind_protect/  y <tt/try-catch/
para  el manejo  de  excepciones. También  se  definen los  operadores
lógicos típicos  and, or,  ...; los  de comparación  <tt/==/, <tt/!=/,
<tt/&gt;=/, ...; incluso los operadores  típicos de post-incremento
<tt/x++/ y similares de C++. Esto último y la existencia de los try-catch
posiblemente hayan hecho pensar a algún lector que existe alguna
relación  entre Octave  y C++...
Pues  ese lector  ha pensado  correctamente. Al  final nombraremos  la
relación. </quote>

<quote>  Para limpiar  la memoria  se usa  el comando  <tt/clear/. Con
<tt/save/  guardamos el  entorno de  variables a  un fichero,  para su
posterior recuperación  con <tt/load/. Proseguiremos  haciendo algunas
operaciones básicas sobre matrices y vectores. </quote>

<code>
octave:14> a=[1:4]    # comienzo -> paso=1 -> final
a =
  1  2  3  4

octave:15> b=[2:2:8]  # comienzo -> paso -> final
b =
  2  4  6  8

octave:16> a.*b   # multiplicación elemento a elemento
ans =
   2   8  18  32

octave:17> a./b   # división elemento a elemento
ans =
  0.50000  0.50000  0.50000  0.50000

octave:18> a*b'   # vector 1x4 x vector 4x1
ans = 60

octave:19> a'*b   # vector 4x1 x vector 1x4
ans =
   2   4   6   8
   4   8  12  16
   6  12  18  24
   8  16  24  32

octave:20> c=diag([1,2,3,4]) # creación de matrices diagonales
c =
  1  0  0  0
  0  2  0  0
  0  0  3  0
  0  0  0  4

octave:21> inv(c) # inversa de una matriz
ans =
  1.00000  0.00000  0.00000  0.00000
  0.00000  0.50000  0.00000  0.00000
  0.00000  0.00000  0.33333  0.00000
  0.00000  0.00000  0.00000  0.25000

octave:22> det(c) # determinante de una matriz
ans = 24

octave:23> eye(4) # matriz identidad de dimensión 4
ans =
  1  0  0  0
  0  1  0  0
  0  0  1  0
  0  0  0  1

octave:24> rand(4,3) # matriz de números aleatorios 4x3
ans =
  0.85927  0.43700  0.85462
  0.88050  0.27016  0.52905
  0.58098  0.54402  0.29237
  0.41791  0.73324  0.45943
</code>

<quote> Esto es  sólo una mínima expresión de  los comandos utilizados
para vectores y matrices. Cuando ya  se tiene experiencia y se conocen
todos los  comandos, muchas  cosas que  se suelen  hacer con  bucles u
otras construcciones  se empiezan a  hacer con vectores y  entonces es
cuando aprovechas al máximo las capacidades de Octave. En las primeras
secciones de <tt/info octave/ o en los primeros capítulos de cualquier
manual de  Matlab&reg; se pueden  encontrar paso a  paso explicaciones
sobre todas estas funciones. </quote>

<quote>  En los  siguientes  ejemplos  entraremos en  el  campo de  la
representación gráfica,  que también  es sencillo (NOTA:  no olvidarse
los puntos y comas al final de línea pues los vectores son algo largos
para estarlos visualizando, y pulsar <tt/q/ para cerrar las gráficas).
</quote>

<quote> Presentación en una  dimensión: La función <tt/plot(vector)/ o
<tt/plot(x,y)/  es muy  sencilla de  usar. La  diferencia entre  ambas
llamadas  es que  cuando presentamos  un vector,  el eje  x se  numera
automáticamente de  1 en  adelante, mientras que  la segunda  forma de
llamarla, el  valor del eje  x esta  definido por nosotros.  Veamos el
siguiente ejemplo que presenta un periodo de una senoidal. </quote>

<code>
octave:25> x=[0:0.01:1];
octave:26> y=sin(2*pi*x);
octave:27> plot(x) # presentamos una recta
octave:28> plot(y) # presentamos una senoidal
octave:29> plot(x,y) # senoidal, pero con eje x bien puesto
</code>

<quote> Representación en dos dimensiones: La función <tt/mesh(x,y,z)/
hace una representación 3D dados dos vectores <tt/x/ e <tt/y/ para los
ejes y una matriz bidimensional <tt/z/  que será la coordenada Z en un
espacio  tridimensional.  En  este  ejemplo, lo  mas  complicado  será
generar una  matriz <tt/z/  bonita. Una  vez tenemos  la matriz  y los
ejes, la llamada es directa. </quote>

<code>
octave:30> x=[-1:0.1:1]; # vector del eje x 
octave:31> y=[-1:0.1:1]; # vector del eje x
octave:32> [mx,my]=meshgrid(x,y); # genera matrices de ejes
octave:33> mesh(mx) # matriz que representa las x
octave:34> mesh(my) # matriz que representa las y
octave:35> mz=2-mx.^2-my.^2; # elemento por elemento
octave:36> mesh(x,y,mz)
</code>

<quote>  Dentro  del  campo  de   la  ingeniería,  Octave  dispone  de
una  excelente toolbox  para  teoría del  control,  donde se  utilizan
estructuras  para  abstraer  al  usuario el  concepto  de  función  de
transferencia  de un  sistema, y  funciones para  el procesamiento  de
señales. En este  último caso, permite aplicar los  resultados a casos
reales ya que tiene módulos para cargar y salvar los datos de imágenes
y sonidos. </quote>

<quote>  La transformada  de  Fourier discreta,  más  conocida por  el
nombre  de  su algoritmo  FFT  (<bf/Fast  Fourier Transform/),  es  la
versión  discreta  y  periódica  de  la  transformada  exponencial  de
Fourier. Es una función muy usada en  ingeniería y en la vida real. La
tomaremos como  la función  para la ingeniería  por antonomasia,  y en
este ejemplo veremos  que sencillo resulta obtener  la transformada de
fourier discreta de un pulso. </quote>

<code>
octave:37> x=[-1:0.01:1];
octave:38> y=(abs(x)<0.2); # escalon generado con una comparación
octave:39> plot(x,y) # función original
octave:40> f=abs(fftshift(fft(y)));
octave:41> plot(f)  # función transformada
</code>

<quote> Por último, dentro del  campo de las Matemáticas, Octave tiene
muchas  más funciones  avanzadas para  realizar cálculos  financieros,
distribuciones estadísticas, álgebra lineal  y ecuaciones no lineales,
polinomios, etc,  unas más  avanzadas que otras,  lo que  bien valdría
dedicarle un estudio particular. Como ejemplo indicativo se muestra lo
que  es necesario  escribir para  resolver numéricamente  una ecuación
diferencial no lineal de  la forma <bf>dx/dt=f(x,t)</bf> con condición
inicial <bf>x(t=t0)=x0</bf>. Aunque no podamos  ver el código de lsode
puesto que es una función interna, nos puede servir como ejemplo de lo
versátil  que puede  resultar en  calculo numérico  la metodología  de
Octave al trabajar solo con vectores y matrices. </quote>

<code>
octave:42> function xdot = f (x, t)
> r = 0.25;
> k = 1.4;
> a = 1.5;
> b = 0.16;
> c = 0.9;
> d = 0.8;
> xdot(1) = r*x(1)*(1 - x(1)/k) - a*x(1)*x(2)/(1 + b*x(1));
> xdot(2) = c*a*x(1)*x(2)/(1 + b*x(1)) - d*x(2);
> endfunction
octave:43> x0 = [1; 2];
octave:44> t = linspace (0, 50, 200)';
octave:45> x = lsode ("f", x0, t);
octave:46> plot (t, x)
</code>

<quote>  Para   cualquiera  que  desee  optimizar   las  computaciones
realizadas  con   Octave,  Octave  provee  de   una  librería  llamada
<tt/liboctave/ que define unas clases  sobre C++ que te permiten pasar
tu  script  desde  Octave  hacia C++  casi  directamente,  para  luego
compilarlo y obtener tu ejecutable, o  para crear tu código objeto que
puedas integrar  en una  aplicación mayor  escrita en  otros lenguajes
como C, C++, Perl, Python, etc. </quote>

<quote> La  web oficial de Octave  es: http://bevo.che.wisc.edu/octave
</quote>

</sect2>
<sect2> Gnuplot
<p>

<p>
<quote> Gnuplot es el programa encargado de hacer las gráficas 2D y 3D
que se visualizaban en Octave. Gnuplot es un programa independiente de
Octave, que  usado por si  mismo te permite hacer  representaciones de
funciones  continuas  y  de  tablas  de  datos.  Octave  solo  usa  un
subconjunto de las funcionalidades de Gnuplot. </quote>

<quote> La primera  característica de Gnuplot es que es  muy similar a
Octave  en  funcionamiento,  es  decir,  que  posee  una  interfaz  de
comandos muy poderosa que también puedes utilizar escribiendo scripts.
Esta  forma de  trabajar tiene  sus  desventajas y  sus ventajas.  Las
desventajas es que necesitas una curva de aprendizaje más lenta, donde
tienes que  haberte mirado por lo  menos la descripción de  uno de los
comandos (<tt/plot/)  para poder  empezar a  hacer algo.  Cuando estas
tanteando datos mejor que uses otro  programa que te permita hacer las
cosas más interactivamente. Pero cuando  ya tienes claro lo que tienes
que hacer, por ejemplo, sobre una  tabla de datos, y tienes 100 tablas
de datos a las que hacer lo  mismo, poder hacer un script puede ser de
una gran ayuda.</quote>

<quote> La otra característica destacable de Gnuplot es la variedad de
formatos de  salida de que  dispone, que  se pueden seleccionar  en el
script.  Te  permite  exportar  a formatos  vectoriales  (xfig,  tex,
postscript),  formatos  bitmap (png,  pbm),  o  formatos de  impresora
(epson, hp, etc).  Con esto puedes tener tu gráfica  retocada por xfig
en tu publicación en  LaTeX, o bien puesta en tu página  web (png) y o
bien impresa directamente en una impresora. </quote>

<quote> Al ejecutar  gnuplot en un shell  de x entramos a  su linea de
comandos: </quote>

<code>
alberto@mencey:~$ gnuplot

	G N U P L O T
	Linux version 3.7
	patchlevel 1
	last modified Fri Oct 22 18:00:00 BST 1999

	Copyright(C) 1986 - 1993, 1998, 1999
	Thomas Williams, Colin Kelley and many others

	Type `help` to access the on-line reference manual
	The gnuplot FAQ is available from
	<http://www.ucc.ie/gnuplot/gnuplot-faq.html>

	Send comments and requests for help to <info-gnuplot@dartmouth.edu>
	Send bugs, suggestions and mods to <submit@bugs.debian.org>


Terminal type set to 'x11'
gnuplot> 
</code>

<quote>  Como  fuente  de  ayuda teclea  <tt/help/  desde  dentro  del
programa y después  de una pantalla introductoria te  saldrá un prompt
sobre el  que podrás escribir,  o bien un  nombre que elegirás  de los
topics que  se te presentan,  o bien un  nombre de comando  si quieres
conocer su sintaxis. </quote>

<quote> Como has visto, el formato de salida es x11 (visualizar en las
X). Para ver un listado de  los diferentes tipos de salida disponibles
usa <tt/set terminal/. </quote>

<quote> La parte más sencilla y práctica de Gnuplot es la presentación
de funciones  continuas, tanto en  forma explícita <tt/y=f(x)/  o
<tt/z=f(x,y)/, como puede ser  en forma paramétrica: curvas 2D
<tt/(x,y)=f(t)/, curvas 3D <tt/(x,y,z)=f(u)/, superficies 3D
<tt/(x,y,z)=f(u,v)/. </quote>

<quote> Con  <tt/help functions/ tenemos  un listado de  las funciones
que  admite.  Una  gran  desventaja  que tiene  es  que  muestrea  las
funciones a intervalos  regulares, por tanto, no  hace ningún análisis
de  discontinuidades (lo  que  se  nota en,  por  ejemplo, la  función
<tt/floor/),  aunque  si  se  puede configurar  para  que  reduzca  el
intervalo. Si queremos imponer cual será el  rango del eje X o el Y lo
ponemos  entre  corchetes  antes  de  la  función.  Algunos  ejemplos:
</quote>

<code>
gnuplot> plot x                        # identidad
gnuplot> plot abs(x)                   # valor absoluto
gnuplot> plot x**2                     # parábola
gnuplot> plot [-1:1] sqrt(1-x**2)      # semicircunferencia
gnuplot> plot [] [-0.1:1.1] exp(-x**2) # gaussiana
gnuplot> plot [-1:4] gamma(x)          # función gamma
gnuplot> plot floor(x)                 # función redondeo hacia abajo
gnuplot> plot x-floor(x)               # diente de sierra
gnuplot> splot x**2+y**2               # plot en 3D
gnuplot> splot sqrt(1-x**2+y**2)              
gnuplot> set isosamples 20,20          # cambia la resolución
gnuplot> replot                 
gnuplot> set isosamples 50,50          # cambia la resolución
gnuplot> set contour		       # activa líneas de nivel
gnuplot> replot
gnuplot> set parametric                # modo paramétrico 

	dummy variable is t for curves, u/v for surfaces
gnuplot> set samples 500                   # mejor resolución (+lento)
gnuplot> plot sin(7*t),cos(5*t)            # lissajous en 2D
gnuplot> splot sin(5*u),sin(6*u),sin(7*u)  # lissajous en 3D
gnuplot> set samples 100                   # menor resolución (+rapido)
gnuplot> splot cos(u)*cos(v),cos(u)*sin(v),sin(u)  # esfera en 3D
</code>

<quote> Gnuplot  también tiene un  modo para trabajar con  archivos de
datos con múltiples columnas. Cuando los  archivos de datos tienen 1 o
2  columnas  se  presentan  directamente.  Si  un  archivo  tiene  más
de  2 columnas  se  pueden presentar  columnas arbitrariamente,  hacer
operaciones matemáticas  sencillas entre  columnas. Veamos esto  en un
ejemplo real (bastante prolijo) donde  un servidor genera una linea de
log de  load, logins y  carga de cpu, a  cada hora y  queremos obtener
gráficas que muestren la evolución en el tiempo </quote>

<code>
# Ejemplo para la monitorización de carga de un servidor en el tiempo

set title "Convex     November 1-7 1989    Circadian"
set key left box
set xrange[-1:24]
plot 'gnuplot.dat' using 2:4 title "Logged in" with impulses,\
     'gnuplot.dat' using 2:4 title "Logged in" with points
pause -1 "Hit return to continue"

set xrange [1:8]
#set xdtic
set title "Convex     November 1-7 1989"
set key below
set label "(Weekend)" at 5,25 center
plot 'gnuplot.dat' using 3:4 title "Logged in" with impulses,\
     'gnuplot.dat' using 3:5 t "Load average" with points,\
     'gnuplot.dat' using 3:6 t "%CPU used" with lines
set nolabel
pause -1 "Hit return to continue"
reset
</code>

<quote> Como último  ejemplo, vamos a probar un script  donde se hacen
ajustes por el método de mínimos  cuadrados con Gnuplot. En el ejemplo
se realizan ajustes a una recta  variando los pesos, pero el método de
ajuste que utiliza Gnuplot permite  poner cualquier función de ajuste,
simplemente definiendo las variables y constantes y dando unos valores
iniciales a las constantes. </quote>

<code>
# ajustes por mínimos cuadrados en Gnuplot 

y(x) = a*x + b   # función a la que se ajustará
a = 0.0          # valores iniciales
b = 0.0          # de los parámetros

fit y(x) 'gnuplot-fit.dat' via a, b
set title 'Ajuste sin pesar'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:3 via a, b
set title 'Ajuste con mayor peso en bajas temperaturas'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:4 via a, b
set title 'Ajuste con mayor peso a altas temperaturas'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:5 via a, b
set title 'Ajuste con peso correspondiente a error experimental'
plot 'gnuplot-fit.dat' using 1:2:5 with errorbars, y(x)
pause -1 "Pulsa enter para continuar"
</code>

</sect2>

<sect2> Scilab

<p>  <quote>  Visto Octave,  Scilab  es  otro  intento de  clónico  de
Matlab&reg; totalmente diferente a Octave, que intenta ganar facilidad
de uso  pero en ciertas  cosas dejando de  ser Matlab&reg;-compatible.
También existe una diferencia en espíritu y es que Octave es GPL, todo
su  código  es obtenido  de  fuentes  GPL  y  por tanto,  los  cambios
repercuten en  los usuarios por  las vías  usuales en la  comunidad de
software libre, mientras que en el  scilab, la licencia es escrita por
<bf/INRIA/ (Francia)  y tiene ciertas  limitaciones con respecto  a la
GPL,  en especial  sobre  autoría,  aparte de  incluir  una mezcla  de
código  de libre  distribución y  código propietario.  Las principales
diferencias que se aprecian, con más detalle son: </quote>

<itemize>

<item>Las ayudas ahora están en integradas en modo gráfico, lo que las
hace un poco más amistosas pero más molestas. En contenido son un poco
más detalladas que las de Octave.

<item>Ya no se  usa Gnuplot para la presentación gráfica.  La forma de
presentar plots  es diseñada por  la gente  de scilab y  permite hacer
zoom y exportar usando el ratón.

<item>Octave posee estructuras de datos y scilab no

<item>En  Octave 3.14159...  se llama  <tt/pi/  y en  scilab se  llama
<tt/%pi/

<item>Los comentarios de Octave eran con <tt/##/ y en scilab son con
<tt>//</tt>

<item>El  plot de  Octave (para  2D) sigue  funcionando, pero  el mesh
para  3D  es  sustituido/ampliado   por  varias  funciones  diferentes
(<tt/param3d/, <tt/plot3d/, ...).

<item>Los valores lógicos  en Octave se presentan como  valores (0.0 y
1.0). En scilab son otro tipo de datos (V y F).

<item>El load/save del Octave, aunque siguen funcionando en scilab, se
complementan con el menú <bf/File &lt; File Operations/.

<item>Cargar funciones externas  en scilab es un  proceso más complejo
(ver <tt/getf/).

<item>El Octave permitía exportar a C++ y el scilab no lo permite.

<item>En scilab se aumenta el número de funciones disponibles, pues te
permite utilizar funciones  de su API que el programa  usa para pintar
ventanas,  controles,  lineas, dibujos,  imágenes,  etc,  para que  tu
pintes lo que quieras.

<item>En estabilidad,  subjetivamente, encuentro más estable  a Octave
que a scilab

<item>Ambos tienen ports  a plataforma Win32, por lo  tanto, no existe
demasiada diferencia en ese aspecto.

</itemize>

<quote> En resumen, si usas un  Matlab&reg; básico, pues escoge el que
más  te guste  de  ámbos. Ten  cuidado porque  si  quieres pasarle  tu
programa a álguien que use el  otro deberá estar cambiando los <tt/pi/
y los comentarios que pongas. Si  no puedes vivir sin GUI, usa scilab.
Si  vas a  hacer algo  serio, usa  Octave, porque  tu código  será más
entendible por  los viejos usuarios de  Matlab&reg;, cualquier ejemplo
de  Matlab que  encuentres por  ahí lo  podrás ejecutar  sin demasiado
problema, podrás pasarlo a C++ en un futuro, y lo de dibujar en scilab
no está tan claro que lo vayas a aprovechar. </quote>

</sect2>

      <sect2>R 

<p>  <quote> <tt/R/  es un  entorno de  programación para  análisis de
datos y gráficos, especialmente  útil para estadística. <tt/R/ dispone
de librerías  que implementan muchas técnicas  estadísticas, desde las
clásicas  hasta la  última  metodología, pero  el  usuario debe  estar
dispuesto a trabajar un poco para encontrarlas. </quote>

<quote> La forma  de trabajar con <tt/R/ es distinta  que con de otros
programas  como  <tt/SPSS/.  En  <tt/R/, un  análisis  estadístico  se
realiza en  una serie  de pasos, con  unos resultados  intermedios que
se  van  almacenando en  objetos,  para  ser observados  o  analizados
posterioresmente,  produciendo  unas  salidas  mínimas.  En  <tt/SPSS/
se  obtendría de  modo  inmediato una  salida  copiosa para  cualquier
análisis. Esto puede parecer a primera vista una terrible incomodidad,
pero  si  tuviéramos   que  trabajar  en  una   máquina  poco  potente
rápidamente nos daríamos cuenta de que puede resultar muy ventajosa la
sencillez  del  entorno  de  <tt/R/  (un entorno  de  comandos)  y  la
posibilidad de ver en cada momento exáctamente lo que se necesita, sin
excesos que desperdicien recursos del sistema. </quote>

<quote> Veamos  cómo se trabaja  con <tt/R/ usándolo. En  primer lugar
conviene crear  un directorio  y entrar  en él  antes de  comenzar una
sesión con <tt/R/, que en éste almacena siempre en el directorio donde
se ejecutan unos ficheros donde almacena los objetos, datos, funciones
y comandos ejecutados. Esto puede  sernos muy útil en trabajos largos,
podemos  interrumpir  la sesión  con  <tt/R/  en cualquier  momento  y
recuperarla luego donde mismo la dejamos. </quote>

<quote> Hemos considerado a lo largo  de este curso que el símbolo del
sistema  Linux/UNIX es  <tt/$/,  y  ahora vamos  a  considerar que  el
símbolo del prompt <tt/R/ es <tt/&gt/. Abrimos un emulador de terminal
dentro del entorno gráfico y seguimos los siguientes pasos. </quote>

<code>
$ mkdir sesion_R
$ cd sesion_R
$ R

R : Copyright 1999, The R Development Core Team
Version 0.90.1  (December 15, 1999)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type	"?license" or "?licence" for distribution details.

R is a collaborative project with many contributors.
Type	"?contributors" for a list.

Type	"demo()" for some demos, "help()" for on-line help, or
     	"help.start()" for a HTML browser interface to help.
Type	"q()" to quit R.

>
</code>

<quote> El símbolo  <tt/&gt;/ es el prompt de <tt/R/,  indica que está
esperando  nuestras  órdenes  para ejecutarlas.  Comenzamos  con  unos
ejemplos de vectores, distribuciones  probabilísticas y algún gráfico.
</quote>

<code>
> x <- rnorm(50)
> y <- rnorm(x)
> plot(x,y)
> ls()
[1] "x"        "y"
> rm(x,y)
</code>

<quote> Hasta ahora nada complicado,  hemos introducido en <tt/x/ y en
<tt/y/ dos vectores  cada uno de 50 pseudoaleatorios  obtenidos de una
distribución normal  N(0,1), los mostrado  en un gráfico  X-Y, listado
los  objetos  disponibles y  borrados  los  objetos <tt/x/  e  <tt/y/.
</quote>

<code>
> x <- 1:20
> w <- 1 + sqrt(x)/2
> hoja.de.datos <- data.frame(x=x,y=x+rnorm(x)*w)
> hoja.de.datos
> regr <- lm(y~x,data=hoja)
> summary(regr)

Call:
lm(formula = y ~ x, data = hoja)

Residuals:
    Min      1Q  Median      3Q     Max 
    -4.4338 -1.6785 -0.4704  1.9643  4.1038 

    Coefficients:
                Estimate Std. Error t value Pr(>|t|)    
(Intercept)  1.78985    1.08627   1.648    0.117    
x            0.84553    0.09068   9.324 2.59e-08 ***
---
Signif. codes:  0  `***'  0.001  `**'  0.01  `*'  0.05  `.'  0.1  ` '  1 

Residual standard error: 2.338 on 18 degrees of freedom
Multiple R-Squared: 0.8285,	Adjusted R-squared: 0.8189 
F-statistic: 86.94 on 1 and 18 degrees of freedom,	p-value: 2.592e-08 
</code>

<quote> Esta vez hemos introducido  en <tt/x/ el vector (1,2,...,20) y
a partir  de él creamos  un vector ponderado de  desviaciones típicas,
que  almacenamos  en  <tt/w/.  Con  estos  dos  vectores  creamos  una
<em/hoja  de datos/,  la guardamos  en <tt/hoja/,  y la  mostramos por
pantalla.  A  continuación  realizamos  el  ajuste  de  un  modelo  de
regresión lineal de <tt/y/ sobre <tt/x/, lo almacenamos en <tt/regr/ y
presentamos en pantalla un resumen  del análisis. Veamos ahora algunas
representaciones gráficas a partir de estos datos. </quote>

<quote> En primer  lugar conectamos la hoja de datos,  de tal modo que
sus  columnas  aparecen  como  variables y  podemos  acceder  a  ellas
directamente  por  su  nombre.   Realizamos  una  regresión  local  no
paramétrica.  Representamos el  gráfico  bidimensional  estándar y  le
superponemos la regresión local, la verdadera recta de regresión, y la
recta de regresión ponderada. Una vez  que hemos terminado con la hoja
de datos <tt/hoja/ la desconectamos. </quote>

<code>
> attach(hoja)
> regr.loc <- lowess(x,y)
> plot(x,y)
> lines(x,regr.loc$y)
> abline(0,1,lty=3)
> abline(coef(regr),col="red")
> detach()
</code>

<quote>  Finalmente  terminamos la  sesión  con  el comando  <tt/q()/.
<tt/R/ nos  preguntará si  queremos guardar la  imagen del  espacio de
trabajo, que es donde están  guardados todos los objetos que estábamos
usando y  el historial  de los comandos  que hemos  ejecutado. Podemos
responder <tt/c/  para cancelar y  no salir, <tt/n/ para  desechar los
datos y no guardarlos  o <tt/y/ para guardar los datos  de la sesión y
poder así retomarla en cualquier momento. Nótese que <tt/R/ guarda una
imagen de espacio  de trabajo en cada directorio donde  se ejecuta, lo
que  nos permite  tener múltiples  sesiones guardadas  según dónde  lo
hayamos ejecutado. </quote>


      </sect2>

    </sect1>

  </sect>

