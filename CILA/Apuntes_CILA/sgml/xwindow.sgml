 
  <sect>El entorno X-Window

    <sect1>Qué es X-Window

<p>
<quote>En algunos sistemas operativos el entorno gráfico, más conocido
como  <bf/GUI  (Graphic  User   Interface)/  es  una  parte  inherente
del  sistema.  Los  diseñadores  de dichos  sistemas  no  conciben  el
funcionamiento de la  máquina en situaciones donde el GUI  no sólo sea
inútil  sino  que  incluso  implique  un  desperdicio  innecesario  de
recursos. En esos  casos el entorno gráfico no sólo  no es sustituible
sino que el sistema no puede funcionar sin él.</quote>

<quote>Los sistemas operativos  UNIX existen desde los  tiempos en que
los ordenadores no contaban con otra  cosa que no fuera una consola en
modo texto. Y han evolucionado a  lo largo del tiempo incorporando las
correspondientes innovaciones  tecnológicas debidas a  la implantación
del modo  gráfico por  los ordenadores  de todo el  mundo. A  causa de
dicho  proceso  de evolución,  en  Linux  el  entorno gráfico  es  una
aplicación  más de  las muchas  que pueden  estar ejecutándose,  o no,
en  el  sistema. Por  lo  tanto  puede  ser sustituido  según  nuestra
conveniencia.</quote>

<quote>El  entorno  gráfico  más  ampliamente extendido  en  el  mundo
UNIX/Linux  son  las X-Window,  conocidas  comúnmente  como <bf/X/  a
secas.</quote>

    </sect1>

    <sect1>Arquitectura de las X-Window

<p>
<quote>Las X presentan una arquitectura, en  muchos casos alabada
pero  en  otros muchos  criticada,  que  se  divide en  dos  elementos
fundamentales:</quote>

<descrip>

<tag/Cliente  X./Se puede  denominar así  a todas  y cada  una de  las
aplicaciones que hacen uso del sistema X.

<tag/Servidor  X./Es  la  aplicación  que   gestiona  el  uso  de  los
dispositivos  de  salida  (p.ej.  tarjetas gráficas,  etc)  y  de  los
dispositivos de entrada (p.ej. teclados, ratones, etc)

</descrip>

<quote>Las pulsaciones de  tecla, el movimiento del  ratón o cualquier
otra acción  del usuario en  los dispositivos de entrada  es detectada
por servidor y transferida al cliente. De la misma manera los clientes
transfieren al servidor las peticiones de operaciones a realizar sobre
el dispositivo de  salida (p.ej. trazar un línea  en pantalla, dibujar
un  punto,  volcar un  bitmap,  etc).  La comunicación  entre  cliente
y  servidor  sigue un  protocolo  estandarizado  que corre  sobre  los
servicios  de red  del  sistema.  Esto permite  a  un  usuario con  un
servidor X en funcionamiento trabajar  con aplicaciones cliente que se
ejecutan  en  otro ordenador  sin  por  ello notar  diferencia  alguna
respecto a las  aplicaciones que se están ejecutando en  su máquina. A
parte de eso las X realizan ciertas optimizaciones en los casos en los
que cliente y servidor se encuentran  en la misma máquina. Por ejemplo
se  permite el  acceso  directo al  hardware de  la  tarjeta de  vídeo
ignorando  el  protocolo  descrito,  con  lo  que  se  aprovechan  las
características  de aceleración  3D de  muchas tarjetas  modernas. Con
ello  las X  se convierten  en  una plataforma  potente para  ejecutar
aplicaciones exigentes  desde un punto  de vista gráfico sin  por ello
perder su flexibilidad.</quote>

    </sect1>

    <sect1>Gestores de ventanas y entornos de escritorio

<p>
<quote>En todo buen entorno  gráfico moderno las aplicaciones utilizan
ventanas para  interactuar con el  usuario. Sin embargo el  servidor X
sólo entiende un  número limitado de primitivas  gráficas como dibujar
líneas  y puntos  o copiar  áreas  de la  pantalla. Por  ello se  hace
necesaria la presencia de una  aplicación cliente <em/especial/ que se
encargue  de crear,  destruir, mover,  controlar el  foco y  en general
gestionar  todas las  cuestiones referentes  al comportamiento  de las
ventanas utilizando las primitivas del  servidor X. A dicha aplicación
se la denomina <bf/gestor de ventanas/.</quote>

<quote>En una distribución de Linux  pueden haber cerca de 40 gestores
de ventanas  entre los que un  usuario debe elegir. Cada  uno de ellos
imprime un feeling diferente a nuestro entorno de trabajo. Tengamos en
cuenta  que cada  gestor dibuja  los  elementos del  marco de  nuestra
ventana de  forma diferente (e.j. la  barra de título, los  botones de
control,  los bordes),  dotándolos de  un comportamiento  particular y
característico  según las  preferencias  del  equipo de  programadores
que  lo diseñó.  Empezando por  los estéticamente  mas valorados  como
<bf/Windows Maker/ o <bf/Enlightenment/; pasando  por los que imitan a
otros sistemas  como <bf/AfteStep/ o <bf/F(?)  Virtual Window Manager/
(en una de sus variantes nos proporciona el look de Windows 95); o los
que permiten ser personalizados con <em/temas/ diferentes como <bf/Ice
Windows Manager/  o <bf/Sawfish/; y  terminando por los más  ligeros y
rápidos pero no menos funcionales  como <bf/Fast Light Window Manager/
se cubre toda una variedad de necesidades de usuario</quote>


<quote>Ahora que disponemos de  ventanas se hace necesario rellenarlas
con algo. A  la hora de programar  una aplicación para las  X se suele
recurrir a  los <bf/toolkits/.  Se trata  de librerías  diseñadas para
proporcionar diferentes  tipos de  controles (e.j. botones,  barras de
menús, cuadros de  edición, etc) facilitando su  gestión. Las toolkits
crean  los  controles  allí  donde  le  digamos,  los  destruyen,  los
redibujan cuando se hace necesario,  manejan todas las acciones que se
hagan  sobre ellos  a través  del uso  de alguno  de los  dispositivos
de  entrada posible,  etc.  Trabajar  sin hacer  uso  de las  toolkits
implicaría diseñar y gestionar nuestros propios controles.</quote>

<quote>Es importante destacar  que una aplicación X  funciona sea cual
sea el  gestor de ventanas  seleccionado. Por tanto,  el uso de  uno u
otro es  una elección  personal del  usuario. Sin  embargo, el  uso de
un  toolkit  u otro  en  una  aplicación  es  elección del  equipo  de
programadores que ha  trabajado en ella. Eso unido a  la gran variedad
de toolkits  existente en  Linux convierte  nuestro escritorio  en una
selva donde podemos ver aplicaciones con interfaces gráficas de lo más
variopinto.</quote>

<quote>Para  garantizar que  las aplicaciones  presenten una  interfaz
similar,  reduciendo el  tiempo de  aprendizaje de  los usuarios,  han
aparecido  los <bf/entornos  de escritorio/.  Básicamente se  trata de
establecer una serie de reglas  comunes que suelen incluir: el toolkit
a  utilizar,  el  formato  de  la ayuda,  el  modelo  de  componentes,
librerías de tratamiento  de imágenes y sonido, etc.  Todo ello genera
un marco de  trabajo tanto para los desarrolladores de  nuevas como de
viejas aplicaciones. Si  lo desarrolladores se ciñen a  dicho marco el
resultado es un entorno de trabajo  uniforme y cómodo donde no existen
diferencias  sustanciales en  la interfaz  de una  aplicación a  otra.
</quote>

<quote>Afortunadamente   la   variedad   es  una   característica   de
Linux.  En  la  actualidad  disponemos  de  dos  grandes  entornos  de
escritorio:</quote>

<descrip>

<tag/GNOME/Funciona  sobre  el  toolkit   GTK  que  fue  originalmente
diseñado para GIMP.

<tag/KDE/Funciona  sobre  el toolkit  Qt  y  es probablemente  el  que
dispone de la interfaz más atractiva de los dos.

</descrip>

<quote>Cada uno tiene sus más y sus menos pero la gran realidad es que
presentan una interfaz muy intuitiva que se aprende a manejar desde el
primer momento.</quote>

    </sect1>

    <sect1>Consejos y trucos

<p>
<quote>Debido a  la sencillez de  los entornos de  escritorio, resulta
absurdo  e inútil  intentar  explicar  su manejo.  La  mejor forma  de
aprender  es sentarse  delante  de uno  de ellos,  ser  un poco  osado
probando  cosas y,  ante  todo,  dejar que  nos  guíe procurando  leer
detenidamente los mensajes del sistema.</quote>

<quote>Sin embargo si resulta interesante seguir algunos conseguir que
nos pueden sacar de un apuro en más de una ocasión:</quote>

<itemize>

<item>Mientras que en algunos sistemas Linux el usuario se autentifica
sobre las  X. En  otros es  posible que al  terminar el  arranque sólo
dispongamos de  una consola en  la que autentificarnos. En  esos casos
la  forma  de  iniciar  las  X es  ejecutar  el  comando  <tt/startx/.
Evidentemente al  terminar nuestro  trabajo en  ellas volveremos  a la
consola.

<item>Si  estamos  en  las  X  es posible  cambiar  a  alguno  de  los
terminales  de la  consola,  he incluso  cambiar  a otro  <tt/display/
de  las  X  si  estuviera  disponible.  Para  ello  basta  con  pulsar
<tt/Ctrl+Alt+F?/,  donde   cada  tecla  de  función   es  un  terminal
diferente. Estando en  la consola volver a las X  es tan sencillo como
cambiar  al  terminal  (<tt/Alt+F?/)  asociado al  display  X  al  que
queremos ir (normalmente sólo hay uno pero pueden haber varios).

<item>Sólo cuando veamos un mensaje del tipo <tt/Kernel Panic/ podemos
decir que nuestro Linux se ha  colgado. En cualquier otro caso estamos
frente a sencillos cuelgues de las aplicaciones con las que trabajamos
y Linux  proporciona los  suficientes recursos  como para  que podamos
recuperar  el control  de la  máquina. Por  ejemplo: el  cambiar a  un
terminal diferente de la consola nos permite matar aplicaciones que se
han  quedado  colgadas  impidiendo  nuestro  trabajo.  En  situaciones
críticas puede  ser necesario terminar  con las X de  forma prematura.
Para ello se pulsa la  secuencia <tt/Ctrl+Alt+Backspace/ que cierra el
servidor X  abortando todas  las aplicaciones  gráficas. Evidentemente
los datos no guardados se perderán.

<item>En Linux existen muchos emuladores de terminal. Dichos programas
permiten ejecutar aplicaciones  de modo consola dentro  de una ventana
X.  El más  básico  es  el <tt/xterm/  que  viene  con la  instalación
estándar de  las X,  pero existen  muchos otros  y cada  entorno suele
venir con uno propio. En  ocasiones es posible que intentemos ejecutar
una aplicación que nunca llega a mostrar su ventana principal o que da
algún tipo de  error grave. En esos casos es  recomendable ejecutar el
programa desde  el emulador de  terminal. Como ya hemos  comentado las
aplicaciones para X no son diferentes de otras aplicaciones por lo que
suelen mostrar  información por la  consola, si esta  está disponible.
Esa información puede ser vital para resolver nuestro problema.

<item>Cuando ejecutamos una aplicación X desde el emulador de terminal
vemos que  este se queda  bloqueado a la  espera de que  la aplicación
termine. Es  el mismo comportamiento  que tiene cuando  ejecutamos una
aplicación  de consola,  sólo que  nos  llama más  la atención  porque
estamos  acostumbrados a  que  en  Microsoft&trade; Windows&trade;  la
aplicación gráfica se ejecute  independientemente. Para que eso suceda
debemos añadir un <tt/&amp;/ al final de la línea de comandos o pulsar
<tt/Ctrl+Z/ y ejecutar el comando <tt/bg/ sobre el emulador después de
que la aplicación haya sido iniciada.

<item>En general  el mostrar  el clásico aviso  de que  una aplicación
tiene archivos modificados y va a ser cerrada es responsabilidad de la
aplicación. El  cierre de  la ventana principal  por la  pulsación del
correspondiente botón en  la barra de título es  notificado al proceso
propietario de la ventana. Normalmente  se suele mostrar dicho mensaje
y una vez aceptado se termina el  proceso. Por una lado es posible que
nuestra aplicación no disponga de  esa característica. Por ejemplo: si
cerramos el  emulador de terminal  cuando estamos ejecutando  sobre él
cualquier tipo de aplicación (sea de  consola o de X) dicha aplicación
termina  inmediatamente perdiéndose  los  datos que  no hubieran  sido
guardados. Por otro lado es posible que le proceso esté bloqueado y no
reciba el mensaje.  En ese caso la  ventana no se cerrará  a menos que
forcemos  su destrucción  con la  opción correspondiente.  Entonces el
gestor de ventanas la cerrará  pero la aplicación seguirá ejecutándose
en segundo plano aunque para nosotros  ya no exista. La única solución
será matarla a mano con el comando correspondiente.

<item>A la hora  de aprender a usar  las X no basta con  jugar con los
botones  izquierdo y  derecho  de nuestro  ratón. En  las  X el  botón
central es de gran importancia suele disponer de funciones adicionales
que no  están presentes en  los otros  dos. En entornos  de escritorio
como KDE o GNOME esto suele  implicar un menú de contexto adicional al
que se  muestra usando  el botón derecho;  pero en  otras aplicaciones
podemos  encontrar formas  de manejo  de lo  más curiosas.  Tal es  su
importancia que en caso de no disponer de él se emula por la pulsación
simultanea de ambos botones.

<item>Una aplicación  curiosa del botón  central es su uso  para pegar
texto entre  aplicaciones sea cual sea  la toolkit bajo las  que hayan
sido desarrolladas. Basta con marcar nuestro texto en la aplicación de
origen para que  al pulsar el botón  central en la de  destino este se
pegue a continuación de la posición actual del cursor.

</itemize>

    </sect1>

  </sect>


