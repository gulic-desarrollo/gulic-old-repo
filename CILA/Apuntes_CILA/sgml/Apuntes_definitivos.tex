\documentclass[a4paper,10pt,twoside]{article}
\usepackage{linuxdoc-sgml-cila}
\usepackage{qwertz}
\usepackage{url}
\usepackage[latin1]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage{epsfig}
\usepackage{null}
\def\addbibtoc{
\addcontentsline{toc}{section}{\numberline{\mbox{}}\relax\bibname}
}%end-preamble
\title{I Curso de Introducción a Linux para Alumnos}
\author{{\bfseries G}rupo de {\bfseries U}suarios de {\bfseries Li}nux de {\bfseries C}anarias
   {\ttfamily $<$http://www.gulic.org/$>$}
   \\ 
    Carlos Alberto Morales Díaz {\ttfamily $<$alberto.morales@amena.com$>$}
   \\ 
    Carlos de La  Cruz Pinto {\ttfamily $<$frodo@fmat.ull.es$>$}
   \\ 
    Edin Kozo {\ttfamily $<$alu2450@csi.ull.es$>$}
   \\ 
    Félix J. Marcelo Wirnitzer {\ttfamily $<$fmarcelo@airtel.net$>$}
   \\ 
    Jesús Miguel Torres Jorge {\ttfamily $<$jesus.torres@iname.com$>$}
   \\ 
    Luis Cabrera Saúco {\ttfamily $<$lcabrera@idecnet.com$>$}
   \\ 
    Miguel Ángel Vilela García {\ttfamily $<$miguev@fmat.ull.es$>$}
   \\ 
    René Martín Rodríguez {\ttfamily $<$alu2290@csi.ull.es$>$}
   \\ 
    Teresa González de la Fé {\ttfamily $<$magonfe@gobiernodecanarias.org$>$}
  }
\date{Noviembre de 2001}
\abstract{ Estos apuntes son un complemento del {\itshape CILA 2001\/},
  {\bfseries C}urso de {\bfseries I}ntroducción a {\bfseries L}inux para {\bfseries A}lumnos.
  Los contenidos están adaptados al software disponible en las aulas
  de informática de la Facultad de Matemáticas de la Universidad de
  La Laguna. El objetivo de este curso es proporcionar a los alumnos
  conocimientos básicos suficientes para defenderse en el entorno
  GNU/Linux y realizar sus prácticas académicas. }


\begin{document}
\maketitle
\tableofcontents

\section{Presentación del Curso}

\begin{quotation}
 Bienvenidos  al {\bfseries C}urso  de {\bfseries I}ntroducción  a {\bfseries L}inux
para  {\bfseries A}lumnos,  organizado  por el  {\bfseries G}rupo  de  {\bfseries U}suarios
de {\bfseries Li}nux  de  {\bfseries C}anarias  y  la Facultad  de  Matemáticas  de  
la Universidad  de  La  Laguna,  patrocinado  por  IDE  SYSTEM  Canarias,
S.L.
\end{quotation}


\begin{quotation}
 Este  curso está dirigido  principalmente a los alumnos  de la
Facultad de Matemáticas, con el  objetivo de proporcionarles una breve
toma de contacto tutorizada con  el nuevo entorno de trabajo GNU/Linux
que  la Facultad  pone a  su disposición  para realizar  sus prácticas
académicas. 
\end{quotation}







\section{Introducción a GNU/Linux.
    }


\subsection{Un poco de historia.
      }


\subsubsection{Orígenes de Unix y sus versiones.}

\begin{quotation}
UNIX  es  uno de  los  sistemas  operativos más  populares
del mundo.  Es una  marca registrada  de {\bfseries The  Open Group},
aunque originalmente fue desarrollado por AT\&T.
\end{quotation}


\begin{quotation}
UNIX es un  sistema operativo real. Por  sistema operativo real
se entiende que debe tener como mínimo dos características: más de una
persona  puede acceder  al mismo  tiempo al  ordenador y,  mientras lo
hacen,  cada  una  de  ellas puede  ejecutar  múltiples  aplicaciones.
Esto  se  llama  ser  un  sistema  operativo  {\itshape multiusuario\/}  y
{\itshape multitarea.\/}  UNIX fue diseñado originalmente  para ser  ese
tipo de sistema  multitarea, allá en los años 70,y para que se pudiera
ejecutar en {\itshape mainframes\/} y en miniordenadores.
\end{quotation}


\begin{quotation}
Con UNIX, cada  usuario accede al sistema  utilizando un nombre
de  acceso.  Opcionalmente,  (aunque es  altamente  recomendable),  el
usuario deberá proporcionar una contraseña, que asegura que la persona
que  accede es  quien  dice ser.  Además, los  usuarios  no acceden  a
cualquier ordenador  en caso  de que  estemos hablando  de una  red de
ordenadores.
\end{quotation}


\begin{quotation}
UNIX  funcionará  prácticamente  en  cualquier  plataforma  que
haya  sido  construida. Muchos  fabricantes  han  adquirido el  código
fuente (IBM;  Hewlett-Packard, Sun, etc.) y  desarrollado sus propias
versiones, a las  que han incorporado su toque personal  a lo largo de
los años.  Pero no son los  únicos que continúan modificando UNIX.
Cuando el sistema  se desarrolló por primera vez, el  código fuente se
proporcionó gratuitamente a las universidades  y a los institutos. Dos
de  ellas han  estado en  primera línea  desde el  primer momento:  la
Universidad de  California en Berkeley  y el Instituto  Tecnológico de
Massachussetts.
\end{quotation}


\begin{quotation}
Como nos podemos  imaginar, el desarrollo de UNIX  se produjo de
forma  bastante  desordenada.  Gente  de todo  el  planeta  comenzó  a
desarrollar  herramientas  para  UNIX.  Desgraciadamente,  no  existía
ninguna coordinación  que guiase todo  el desarrollo, lo  cual produjo
grandes diferencias entre las  distintas versiones de UNIX. Finalmente
la  mayoría de  los estándares  se  encuentran bajo  el estándar  IEEE
POSIX.1.
\end{quotation}


\begin{quotation}
El mayor inconveniente de UNIX es que es muy grande. También es
caro, especialmente  en sus versiones  para PC. Aquí es  donde aparece
Linux, pues, como se explica con  más detalle un poco más adelante, se
diseñó para ser pequeño, rápido  y barato. Hasta ahora los diseñadores
han tenido éxito.
\end{quotation}


\begin{quotation}
Linux  fue  creado  originalmente  por  Linus  Torvalds  en  la
Universidad  de  Helsinki,  Finlandia.  Linus basó  el  Linux  en  una
pequeña implementación  de UNIX para  PC con fines  didácticos llamada
{\itshape Minix\/}. A finales de 1991 se hizo público Linux con la versión
0.10. Un  mes después, en  diciembre, apareció la versión  0.11. Linus
hizo que el  código fuente fuera de libre disposición  y animó a otras
personas a colaborar en su  desarrollo. Lo hicieron. Linux continúa su
desarrollo hoy en día gracias a  un equipo mundial dirigido por Linus,
que trabaja a través de Internet. 
\end{quotation}


\begin{quotation}
 Gran  parte del  {\itshape software\/} desarrollado para  Linux es
creado por  el proyecto  GNU de  la {\bfseries Free  Software Fundation}.
\end{quotation}





\subsubsection{El {\itshape Software Libre\/} y la licencia GPL.}

\begin{quotation}
 Llegados a  este punto, nos encontramos con  un nuevo concepto
que es  el {\itshape Software Libre\/}.  Tiene su origen en  el nacimiento
del  {\itshape software\/}  en  EE.UU.,   cuando  la  informática  era  un
feudo  reservado  a  empresas  y universidades,  y  los  programadores
intercambiaban trucos  ({\itshape hacks\/}, en  inglés) que  hacían brotar
chispas en los enormes cerebros electrónicos. Por aquel entonces hacía
sus pinitos digitales  un joven programador, Richard  M. Stallman que,
al igual  que sus compañeros de  profesión, fue testigo de  la primera
gran transformación del mundo de la programación en industria cerrada.
\end{quotation}


\begin{quotation}
 Cuenta este  informático que, un buen día,  aparecieron por la
puerta  abogados  que prohibieron  a  los  programadores compartir  su
código  (el  código  de  sus  programas) y  les  obligaron  a  ocultar
celosamente  cualquier  información  que  pudiera  ser  usada  por  la
competencia.  Además,  decidieron  que las  empresas  guardarían  bajo
llave  el código  fuente de  sus programas  (la secuencia  original de
instrucciones que los hace funcionar de una determinada manera) y sólo
entregarían a sus clientes el código  binario (los unos y ceros que el
ordenador entiende, pero apenas  pueden interpretar las personas). Por
último, obligaron  a los trabajadores a  aceptar la idea de  que quien
violaba estas normas no sólo cometía un delito, sino también un pecado
propio de un loco, o de un {\itshape pirata\/}. 
\end{quotation}


\begin{quotation}
  Años más  tarde,  este dogma  informático  se extendió  hasta
convertirse en el actual  mercado del {\itshape software\/}, donde comprar
un  programa significaba  adquirir  el  derecho a  usarlo,  pero no  a
abrirlo  para  saber cómo  funciona  ni,  mucho  menos, a  copiarlo  o
modificarlo,  una  prerrogativa  que  corresponde en  exclusiva  a  la
empresa fabricante. 
\end{quotation}


\begin{quotation}
 Stallman, convencido  de que a la sociedad se  le había robado
un debate  importante sobre  la evolución de  la tecnología  (la frase
{\tt\char`\"}es como si te vendieran un  coche con el capó sellado, para que
no  puedas ver  el motor{\tt\char`\"}  es una  de las  analogías más  usadas
para  explicar  esta realidad  mercantil),  decidió  dejar su  trabajo
y  emprender  una  tarea  mucho más  altruista:  responder  al  modelo
propietario con un {\itshape software\/} del que nadie pudiera apropiarse,
con un {\itshape software\/} libre. 
\end{quotation}


\begin{quotation}
 Se  trataba, según su  promotor, de  poner en marcha  un nuevo
contrato por el  que los usuarios recibieran siempre  el código fuente
y,  además,  el derecho  inalienable  a  modificarlo  a su  gusto.  El
movimiento  fue  bautizado con  el  críptico  nombre  de GNU,  y  para
defenderlo se creó la Licencia Pública  General (GPL, en sus siglas en
inglés),  un peculiar  contrato  mercantil que,  a  diferencia de  las
licencias de {\itshape software\/} tradicionales,  no sólo no restringe la
posibilidad de copiar  y redistribuir los programas, sino  que anima a
los usuarios a hacerlo.
\end{quotation}


\begin{quotation}
 Este nuevo orden informático fue recibido con entusiasmo en la
entonces  incipiente  comunidad  de  programadores  que  pululaba  por
Internet, pero también  con cierta inquietud. De  hecho, el movimiento
GNU  fue visto  con  recelo  desde algunos  sectores  de la  población
estadounidense, que  lo tacharon de {\tt\char`\"}izquierdoso{\tt\char`\"},  por su
tendencia a  compartir su  trabajo y  por su  aversión al  concepto de
propiedad que  había establecido  la industria  del {\itshape software\/}.
\end{quotation}





\subsubsection{Qué es Linux y GNU/Linux.}

\begin{quotation}
 Con ideología o sin ella, el movimiento GNU se extendió por la
Red y  empezó a  dar sus  frutos, y  así nació  Linux. Línea  a línea,
programa a programa, el sistema  operativo del pingüino (la mascota de
Linux que, por cierto, se llama Tux) se convirtió en poco tiempo en el
producto  más famoso  del  código abierto  y,  paradójicamente, en  la
apuesta de más de una multinacional en el sector informático. 
\end{quotation}


\begin{quotation}
 Lo que realmente se  entiende por Linux es el {\itshape kernel\/},
el  {\tt\char`\"}corazón{\tt\char`\"} de  cualquier sistema  operativo tipo  UNIX.
Pero el  kernel por  sí solo  no forma  todavía un  sistema operativo.
Justamente para  UNIX existe una multitud  de {\itshape software\/} libre,
lo que significa que éstos están  disponibles también para Linux y son
estas  utilidades  las  que  realmente forman  el  sistema  operativo.
Entonces es cuando ya hablamos de {\bfseries GNU/Linux}. 
\end{quotation}


\begin{quotation}
 La  posibilidad de que exista  un gran número de  programas de
{\itshape software\/}  libre permite  la creación  de diferentes  sistemas
Linux, y es cuando aparecen las distribuciones de Linux. Cada una con
su conjunto  de programas, pero que  tienen en común el  kernel, que es
Linux. Por tanto, cuando hablamos  de Linux, nos estamos refiriendo a
cualquiera de sus distribuciones. Las más  conocidas son {\itshape Debian\/},
{\itshape Red Hat\/}, {\itshape SuSE\/}, {\itshape Mandrake\/}. De todas éstas, la
que más se acerca  a la filosofía del movimiento GNU  es Debian ya que
es  producto  de un  gran  conjunto  de programadores  repartidos  por
Internet,  mientras  que  las  otras pertenecen  a  empresas  privadas
dedicadas al desarrollo de Linux. 
\end{quotation}





\subsection{Distribuciones de Linux}

\begin{quotation}
Lo que  vulgarmente  conocemos como  Linux, debiera  llamarse
oficialmente (al menos) como GNU/Linux. El  motivo no es otro sino que
el corazón de  un sistema Linux está formado por  un núcleo (linux) al
que se le han añadido las  utilidades desarrolladas por la gente de la
Free Software  Foundation (GNU), o  al menos  así era en  los primeros
momentos.
\end{quotation}


\begin{quotation}
Hoy en día,  la lista de colaboradores en el  desarrollo de Linux
es inmensa, estando formada tanto por  personas como usted, o como yo,
como  por las  más grandes  compañías del sector informático  actual.
Parece que  ha pasado una eternidad  (5 de Octubre de  1991), desde el
momento que  Linus anunció  la primera versión  {\tt\char`\"}oficial{\tt\char`\"} de
Linux, la  0.02. Ya podía  ejecutar bash (el shell  de GNU) y  gcc (el
compilador de C de GNU), pero no hacía mucho más.
\end{quotation}


\begin{quotation}
En ese anuncio, puso frases como estas:
\end{quotation}

\begin{quotation}
\begin{quotation}
{[}...{]}{\tt\char`\"}¿Suspiráis al recordar  aquellos días de Minix-1.1,
cuando  los  hombres  eran  hombres y  escribían  sus  propios  drivers?
¿Os  sentís  sin  ningún  proyecto   interesante  y  os  gustaría  tener
un  verdadero  S.O.  que  pudierais  modificar  a  placer?  ¿Os  resulta
frustrante  el tener  solo  a  Minix? Entonces,  este  artículo es  para
vosotros.{\tt\char`\"}{[}...{]}
\end{quotation}
\end{quotation}

\begin{quotation}
Hoy día, a partir de esas frases (y de lo que implicaban), han surgido
distribuciones de linux para todos los gustos. Algunas de ellas son las
que figuran en este listado:
\end{quotation}


\begin{itemize}
\item   {\bfseries Conectiva}:  Una  distribución Brasileña  de  Linux.  Url:
{\ttfamily http://www.crhl.com.br}
\item   {\bfseries Debian}: La  distribución  de Linux  más libre  disponible
hoy  día,   mantenida  por   un  gran   grupo  de   voluntarios.  Url:
{\ttfamily http://www.debian.org}

\begin{quotation}
      Como     anécdota      interesante,     comentar      que
{\ttfamily http://www.es.debian.org}   se   encuentra    en   la   misma
Universidad en la que estudian  o han estudiado los autores de este
curso. 
\end{quotation}

\item   {\bfseries Enoch}:  Un  avanzado y  altamente  optimizado  GNU/Linux.
Url: {\ttfamily http://www.swcp.com/\~{}drobbins/enoch/}
\item    {\bfseries e-smith  server   and   gateway}:  Software   Open-source
que  convierte  un   PC  en  un  Servidor  de   Internet  Linux.  Url:
{\ttfamily http://www.e-smith.net}
\item     {\bfseries Linux    Mandrake}:    Una   de    las    distribuciones
más       recientes,       basada       en       Red       Hat       y
KDE. Url: {\ttfamily http://www.linux-mandrake.com}
\item   {\bfseries NoMad}: Su  principal  propósito es  ayudar  a su  creador
a  ser  feliz,  dándole  algo  que hacer  en  su  tiempo  libre.  Url:
{\ttfamily http://www.nomadlinux.com}
\item    {\bfseries Project   Independence}:   Project   Independence   busca
facilitar   la   vida   a   los  recien   llegados   a   Linux.   Url:
{\ttfamily http://independence.seul.org}
\item   {\bfseries Red Hat}:  La primera  distribución Linux  en reorientarse
hacia los usuarios finales. Url: {\ttfamily http://www.redhat.com}
\item  {\bfseries SEUL (Simple End-User Linux)}:  Un proyecto basado en Linux
que  pretende  convertirse en  una  alternativa  viable frente  a  los
sistemas operativos comerciales. Url: {\ttfamily http://www.seul.org}
\item     {\bfseries Slackware}:     Una    distribución     histórica:    La
Distribución. Url: {\ttfamily http://www.slackware.com}
\item   {\bfseries Stampede}: Una  distribución compilada  para Pentium  URL:
{\ttfamily http://www.stampede.org}
\item  {\bfseries S.u.S.E.}:  Una distribución alemana, orientada  al usuario
final. Colaboran  activamente en  el desarrollo del  sistema X-Window.
Url: {\ttfamily "http://www.suse.com}
\item   {\bfseries The LætOS  Project}:  Ofrece una  distribución Linux  para
el  público  en general,  ofreciéndolo  como  alternativa al  software
propietario.   LætOS  incluirá   instalación  gráfica,   detección  de
hardware, etc. Url: {\ttfamily http://www.laetos.org}
\item   {\bfseries Yello  Dog  Linux}:   Una  distribución  para  ordenadores
Macintosh PPC y G3 . Url: {\ttfamily http://www.yellowdoglinux.com}
\end{itemize}


\begin{quotation}
Bueno, para terminar este rápido repaso, comentar que en este listado
no se encuentran, ni muchísimo menos, todas las opciones de las que puede
disfrutar con linux. Basta dar una vuelta por los principales buscadores
de Internet, y se darán cuenta de hasta donde se ha llegado actualmente.
\end{quotation}





\subsection{GNU/Linux: cara y cruz
      }


\subsubsection{La cara. }

\begin{quotation}
Enumeramos las ventajas de Linux a continuación:
\end{quotation}


\begin{itemize}
\item {\bfseries Multitarea total}. Se pueden ejecutar varias tareas y se
puede acceder a varios dispositivos al mismo tiempo.
\item {\bfseries Memoria  virtual}. Linux  puede usar  una porción  de su
disco  duro como  memoria virtual,  lo que  aumenta la  eficiencia del
sistema al mantener los procesos activos  en la memoria física (RAM) y
al colocar  las partes inactivas o  usadas con menos frecuencia  en la
memoria de disco.  La memoria virtual permite utilizar la máxima cantidad 
de memoria posible del sistema ($>$GigaBytes) y no permite que se 
produzca segmentación de la memoria.
\item {\bfseries Soporte multiusuario}. Linux permite que varios usuarios
accedan  a su  sistema simultáneamente  sin que  haya conflicto  entre
ellos y cada uno con su espacio de trabajo.
\item {\bfseries Código  fuente  no  propietario}.  El  kernel  de  Linux
no  utiliza  código  de   {\bfseries AT\&T}  ni  ninguna  otra  fuente
propietaria. Otras organizaciones, como  las compañías comerciales, el
proyecto GNU  y los  programadores de todo  el mundo,  han desarrollado
{\itshape software\/} para Linux.
\item {\bfseries Soporte  mediante  {\itshape software\/} GNU}.  Linux  puede
ejecutar una amplia variedad  de {\itshape software\/}, disponible gracias
al  proyecto  GNU.  Este  {\itshape software\/}  incluye  de  todo,  desde
desarrollo de aplicaciones  (GNU C y GNU C++) a  la administración del
sistema (gawk, groff, etc.) y juegos (GNU Chess, GnuGo, y NetHack).
\item {\bfseries Estabilidad}. Linux presenta una  gran estabilidad en la
gestión de sus procesos internos del sistema. Es muy difícil conseguir
que Linux se  {\tt\char`\"}cuelgue{\tt\char`\"} y, por supuesto, jamás  se verá un
{\tt\char`\"}pantallazo azul{\tt\char`\"} tipo {\itshape Windows\/}.
\item {\bfseries Gran  oferta  de  software}.  Aunque Linux  no  sea  tan
conocido por  el público  como lo es  {\itshape Windows\/}, eso  no quiere
decir  que no  existan  aplicaciones  para el  usuario  medio. Por  el
contrario, cuando uno utiliza Linux, según pasan los días, se tiene la
sensación de que no necesita para nada {\itshape Windows\/} porque todo lo
que éste ofrece ya lo tiene Linux.
\item {\bfseries Defensa contra los virus}. Aunque  la mayor parte de los
virus que rondan por Internet son desarrollados para {\itshape Windows\/},
es cierto  que existen algunos para  Linux, pero son más  difíciles de
crear  debido a  que Linux  emplea un  sistema de  permisos sobre  los
ficheros previendo los posibles desastres que se ven todos los días en 
los entornos de {\itshape Windows\/}. Además,  los virus para 
{\itshape Windows\/} no se pueden ejecutar en Linux salvo contadísimos 
casos.
\item {\bfseries Relación  con  Internet}.  Debido  a  que  Linux  creció
gracias a  Internet, digamos que ambos  hablan en el mismo  lenguaje y
por tanto, se ve claramente que  navegar por Internet con Linux es más
rápido  que  con {\itshape Windows\/}.  Obviamente,  ésta  es una  opinión
personal del  autor de  este documento.  Si alguien  quiere rebatirlo,
está en su derecho ;-)
\item {\bfseries Entornos gráficos}.  Hasta hace  unos años,  trabajar en
Linux sólo era posible desde consola, ese entorno negro con caracteres
blancos (similar  al {\itshape MS-DOS\/}, pero  con más potencia).  Con la
llegada  de {\itshape Windows\/},  la  comunidad Linux  se  vio de forma
obligada a desarrollar nuevos entornos gráficos para no perder  el tren. 
La gran diferencia con {\itshape Windows\/} es que mientras éste  es un sólo
escritorio,  en  Linux  podemos  elegir con  qué  tipo  de  escritorio
queremos  trabajar.  Los  más  conocidos son  KDE,  GNOME,  AfterStep,
Enlightment,  donde  los  dos  primeros son  los  más  populares.  Los
más  curioso  es  que  con  ellos se  ha  iniciado  una  {\tt\char`\"}guerra
dialéctica{\tt\char`\"} sobre cuál es mejor.  Al final, la ventaja de la
variedad es que el usuario puede decidir con cuál se siente más cómodo.
\item {\bfseries Servidores  caseros}.  Parece   mentira,  pero  en  casa
podemos tener  un servidor web, o  un servidor FTP con  nuestro Linux.
Sólo hay que leer la documentación de cómo hay que hacerlo.

\item {\bfseries La comunidad Linux}. A diferencia de {\itshape Windows\/}, Linux
tiene una comunidad de voluntarios con ganas de ayudar a los que les cuesta
adentrarse en este mundo. Y todo por afán de colaborar en este proyecto.
\end{itemize}







\subsubsection{La cruz.}

\begin{quotation}
Obviamente, como  todo sistema operativo, Linux  no está exento
de fallos, como vemos aquí:
\end{quotation}


\begin{itemize}
\item {\bfseries Entorno árido}.  Aunque en los últimos  años el panorama
ha mejorado  considerablemente, no  podemos olvidar que  para trabajar
con  Linux,  sobre todo  si  se  viene  de {\itshape Windows\/},  hay  que
aprender unas cuantas  nociones si no se quiere tener  la sensación de
que se está perdido. Todo ello radica en que Linux no es tan intuitivo
como{\itshape Windows\/},  pero afortunadamente  las diferentes  compañías
comerciales  han aportado  herramientas que  facilitan esas  tareas al
usuario. Sólo hay que cambiar un poco el {\tt\char`\"}chip{\tt\char`\"}.
\item {\bfseries Soporte de hardware}. Por desgracia, como se ve
claramente, el mercado de los sistemas informáticos de escritorio está
orientado a {\itshape Windows\/}. Prueba de ellos es que el 90\% de
los PC lo tienen instalado sin usar otro. Así que, los fabricantes
de hardware sólo se han preocupado de crear los {\itshape drivers\/}
compatibles con {\itshape Windows\/} sin pensar en los restantes sistemas
como Linux, Mac, BeOS y otros. Ello ha obligado a que fueran los
propios usuarios programadores los que desarrollaran sus propios
{\itshape drivers\/}. Con el tiempo, los fabricantes ha atendido a las
demandas de estos últimos.
\item {\bfseries Configuración del sistema operativo}. Hasta hace bien
poco, instalar y configurar Linux en su casa en condiciones era una
tarea ardua y bastante complicada. Ello hacía que mucha gente se
rindiera y siguiera con {\itshape Windows\/}. Las diferentes distribuciones
han tenido en cuenta estos problemas y han aportado herramientas que
ayudan al sufrido usuario a hacerlo todo de forma más intuitiva y
automática. Entre estas herramientas están las encargadas de la parte de
la instalación del {\itshape hardware\/} y {\itshape software\/}.
\item {\bfseries No todo el software necesario está presente}. Es cierto
que casi todo el software que  un usuario necesita ya lo aporta Linux.
Pero hay  situaciones en las  que una persona necesita  una aplicación
concreta  y  ve  que  debe utilizar  {\itshape Windows\/}  para  usar  esa
aplicación. De  todas formas, siempre surgen  desarrolladores con afán
de ayudar y terminan construyendo esas aplicaciones.
\item {\bfseries Administración  de  Linux}.  Como  todo,  si  se  quiere
administrar Linux  de forma profunda,  ya no vale usar  los asistentes
gráficos  como  en  {\itshape Windows\/},  sino que  hay  que  leer  mucha
documentación  y   realizar  experimentos.   A  cambio  se   gana  una
experiencia que en {\itshape Windows\/} es difícil de conseguir.
\end{itemize}





\subsection{Recursos para GNU/Linux
      }


\subsubsection{Software}

\begin{quotation}
Tal vez por  su escasa repercusión en el  ámbito doméstico, uno
pueda pensar que  la cantidad de software es bastante  escasa. Todo lo
contrario. De  hecho se  pueden encontrar  bastantes utilidades  en las
páginas webs propias de las distribuciones.
\end{quotation}


\begin{quotation}
También  se pueden  encontrar aplicaciones  en otras  páginas o
servidores  FTP  con  software  propio,  como  StarOffice,  KDE,  QCAD
y  VariCAD  (éstos últimos  son  aplicaciones  que pretenden  ser  los
correspondientes AutoCAD en los entornos UNIX), etc.
\end{quotation}


\begin{quotation}
Si el  usuario proviene  del entorno {\itshape Windows\/},  tal vez
pueda  tener la  sensación  de que  {\tt\char`\"}Sí,  trabaja como  Windows,
pero  no es  igual que  Windows{\tt\char`\"},  y le  gustaría encontrar  las
herramientas  con el  mismo aspecto  que este  sistema operativo.  Los
desarrolladores han optado  por tres caminos: El primero es  el de dar
las mismas  funcionalidades que las  que tienen esas  aplicaciones que
existen en {\itshape Windows\/},  aunque su aspecto externo  no tenga nada
que ver  con el  Windows. El  segundo camino  añade además  el aspecto
externo original de la aplicación que funciona en {\itshape Windows\/} con
el  fin de  que el  usuario se  encuentre en  un entorno  familiar. El
tercero es el  más drástico ya que se crean  herramientas con aspectos
y  funcionalidades totalmente  diferentes  a  esas aplicaciones.  Para
plasmar en un ejemplo  de lo que se acaba de  decir, basta con nombrar
una de las aplicaciones más  utilizadas en el entorno {\itshape Windows\/}
que  es  {\itshape MS Word\/}.  Del  primer  ejemplo nos  encontramos  con
{\bfseries KWord}, desarrollado por el equipo que creó KDE. El segundo es
{\bfseries AbiWord}.  El autor  reconoce  que es  casi  como utilizar  el
{\itshape MS Word\/}. Y  el tercero es el  {\bfseries {\LaTeX}}, una herramienta
muy  potente, pero  que  quizás desconcierte  a  los usuarios  noveles
debido  a su  complejidad. Al  final  la elección  depende del  propio
usuario.
\end{quotation}


\begin{quotation}
Una  cosa está  clara: {\bfseries Para  Linux hay  suficiente software
para detener un tren.}
\end{quotation}





\subsubsection{Documentación}

\begin{quotation}
La    documentación    básica     sobre    Linux    se    puede
encontrar    en     {\ttfamily \onlynameurl{http://lucas.hispalinux.org/}}(en               castellano)
y              {\ttfamily \onlynameurl{http://www.linuxdoc.org/}} (en inglés).  En ellos se pueden
encontrar  tutoriales y  cursos que  pueden  ayudar a  los usuarios  a
adentrarse en el mundo Linux.
\end{quotation}


\begin{quotation}
Cabe  destacar  que los  documentos  más  utilizados los  COMOs
({\itshape HOW-TO\/}  en inglés)  que  son una  guía  bastante útil  sobre
alguna cosa en concreto que se quiere hacer.
\end{quotation}


\begin{quotation}
Otra  forma  de  encontrar   información  es  buscando  en  las
múltiples páginas webs referidas al tema, sin olvidar también echar un
vistazo a los servidores  de noticias ({\itshape newsgroups\/}, en inglés)
\end{quotation}


\begin{quotation}
Por último, si  se quiere información rápida  de algún programa
en  concreto, no  hay  más que  utilizar los  manuales,  es decir,  el
comando {\ttfamily man}, las páginas info  con el comando {\ttfamily info} o
buscar en la  documentación del programa en cuestión  en el directorio
{\ttfamily /usr/share/doc/} (en Debian). 
\end{quotation}





\section{El entorno de intérprete de comandos.}


\subsection{Qué es un intérprete de comandos.}

\begin{quotation}
 Si bien manejarse en Linux es cada vez más fácil, debido a la
proliferación  de escritorios,  los  comienzos no  siempre fueron  así
de  fáciles. De  hecho,  puede  ocurrir que  nos  encontremos con  una
emergencia  en el  que  no  nos quede  más  remedio  que trabajar  con
comandos.
\end{quotation}


\begin{quotation}
Un  intérprete de  comandos tiene  el aspecto  de una  pantalla
llena de letras, generalmente con fondo  negro y letras blancas, y que
en la última línea inferior, se suele ver lo siguiente:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
En este  entorno es donde  introduciremos los comandos  con los
que trabajaremos,  y coloquialmente diremos que  estamos trabajando en
una consola. Estos comandos pueden ser de diferentes clases:
\end{quotation}


\begin{itemize}
\item  Programas ejecutables.
\item  Scripts del intérprete.
\item  Scripts de lenguajes de script como Perl, Tcl, etc.
\item  Macros del intérprete.
\end{itemize}


\begin{quotation}
Todos tienen en  común que son ficheros: al  cargar un programa
en Linux, se ordena al intérprete  que busque el fichero con el nombre
del programa y una vez encontrado,  lo ejecute, si éste da permisos de
ejecución al usuario.
\end{quotation}


\begin{quotation}
Los comandos tienen el siguiente aspecto:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ fdisk
[felix@localhost Comandos]$ lsmod
[felix@localhost Comandos]$ ls
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
También funcionan con opciones:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ fdisk -v
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Y con parámetros:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ fdisk /dev/hda
[felix@localhost Comandos]$ ls /tmp
[felix@localhost Comandos]$ ls *.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Con opciones y parámetros:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ rpm -qpl joe-1.0.3.rpm
[felix@localhost Comandos]$ gcc -o suma suma.c
[felix@localhost Comandos]$ ls -al /tmp
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Al    ser    Linux    un    sistema    {\ttfamily multitarea}    y
{\ttfamily multiusuario}, se aportan ventajas que se agradecen incluso en
un sistema  PC {\ttfamily monousuario}. Una  de estas ventajas es  que se
puede trabajar con seis consolas  virtuales, que es como si pudiéramos
trabajar con  varias sesiones  simultáneas, entendiendo por  sesión el
tiempo de trabajo desde que el  usuario entra tras identificarse en el
{\ttfamily login}  de  entrada hasta  que  abandona  el sistema.  Lo  que
significa realmente que el mismo  usuario puede entrar varias veces al
mismo tiempo.
\end{quotation}


\begin{quotation}
Para alternar entre estas  consolas virtuales, basta con pulsar
las  cobinaciones  de  la  teclas {\tt\char`\"}{\bfseries Alt  +  F1}{\tt\char`\"}  a
{\tt\char`\"}{\bfseries Alt + F6}{\tt\char`\"}
\end{quotation}


\begin{quotation}
Si se  quiere acceder a  una consola desde un  entorno gráfico,
entonces  se   pulsan  las  combinaciones  {\tt\char`\"}{\bfseries Ctrl   +  Alt  +
F1}{\tt\char`\"} a {\tt\char`\"}{\bfseries Ctrl + Alt + F6}{\tt\char`\"}
\end{quotation}





\subsection{Directorios y nombres de ficheros.}


\subsubsection{Trabajando con directorios.}

\begin{quotation}
Toda  la  información  -ya  sean  textos,  imágenes,  bases  de
datos   o  información   para   la  configuración   del  sistema-   se
almacena  en  {\tt\char`\"}ficheros{\tt\char`\"},  que  a su  vez  se  guardan  en
{\tt\char`\"}directorios{\tt\char`\"}.  Con  todas  las herramientas  y  programas
existentes se puede acceder a estos  ficheros para ver su contenido o
modificarlo.
\end{quotation}


\begin{quotation}
A diferencia  del los sistemas MS-DOS/Windows,  en los sistemas
UNIX  no  se dividen  los  directorios  entre las  distintas  unidades
físicas (C:, D:,  etc.). Al contrario, para UNIX todos  son ficheros y
directorios.  Éste  considerará  un  disco  duro,  un  scanner  o  una
disquetera como directorios.  Por tanto, no tiene  sentido escribir en
la  consola  {\tt\char`\"}C:{\tt\char`\"},  sino  que  nos  iremos  al  directorio
asociado a esa partición que para MS-DOS es {\tt\char`\"}C:{\tt\char`\"}.
\end{quotation}


\begin{quotation}
Todos los ficheros y directorios  de un sistema UNIX cuelgan de
un directorio principal llamado  {\tt\char`\"}raíz{\tt\char`\"}, que se representa
como {\tt\char`\"}/{\tt\char`\"}.
\end{quotation}


\begin{quotation}
Hay que  destacar que  cuando el usuario  accede a  una sesión,
Linux {\tt\char`\"}envía{\tt\char`\"}  al usuario a  su directorio de  trabajo. Es
decir, si  yo entro como el  usuario {\ttfamily felix}, en el  momento de
entrar me encontraré en  el directorio {\ttfamily /home/felix}. Éste será
mi directorio personal, en donde tengo libertad absoluta para hacer lo
que quiera con mis ficheros y directorios ubicados ahí. Sin embargo no
podré hacer todo lo que quiera en el directorio {\ttfamily /home/miguel}.
¿Por qué? Pues por la sencilla razón  de que Linux tiene un sistema de
permisos que  concede o restringe  libertades sobre los  directorios y
ficheros que hay en Linux. ¿Significa eso que puede existir un usuario
{\tt\char`\"}dios{\tt\char`\"} en Linux que puede hacer totalmente cualquier cosa en
Linux?  Sí, ese  es el  usuario {\ttfamily root}.  Sin embargo,  para los
propósitos de este curso, sólo nos  remitiremos a la cuenta de trabajo
del propio lector ;-)
\end{quotation}


\begin{quotation}
¿Cómo sé yo en qué  directorio me encuentro? Basta con escribir
el comando {\ttfamily pwd} (Print Work Directory).
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost felix]$ pwd
/home/felix/
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Y la salida que obtendré es:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
/home/felix
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Para cambiar de directorio,  emplearemos el comando {\ttfamily cd}
(Change Directory) 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ cd /etc
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Es decir, nos vamos al directorio {\ttfamily /etc}
\end{quotation}


\begin{quotation}
Si simplemente escribimos {\ttfamily cd} sin especificar el nombre
del directorio, esto será igual que escribir {\ttfamily cd /home/felix} o
{\ttfamily cd  \~{}}, es  decir,  me  manda a  {\bfseries mi  propio directorio  de
trabajo}.
\end{quotation}


\begin{quotation}
¿Cómo veo los ficheros y directorios de un directorio? Escribimos
{\ttfamily ls $<$Nombre del directorio$>$}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ ls /home/felix/apuntes/apuntes/
Apuntes_CILA_2001.dvi   CVS/           introduccion.sgml  programando.sgml 
 xwindow.sgml
Apuntes_CILA_2001.sgml  editores.sgml  LEEME              recursos.sgml
cabecera.sgml           final.sgml     Makefile          
 resumen_temario.txt
comandos.sgml           graficos.sgml  matematicas.sgml   sobre.sgml
compila*                internet.sgml  presentacion.sgml  temario.estado
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si   escribimos   {\ttfamily ls}   entonces  se   nos   mostrará
el   contenido   del   directorio    en   el   que   nos   encontramos
actualmente.
\end{quotation}


\begin{quotation}
El  comando {\ttfamily ls}  admite parámetros  tales como  {\ttfamily -a,
-l}
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost Comandos]$ ls -a -l
[felix@localhost Comandos]$ ls -al
[felix@localhost Comandos]$ ls -la
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Obsérvese  que  ambas formas  de  escribir  los parámetros  son
igualmente  válidas. Como  anotación, si  queremos ver  que parámetros
se  pueden utilizar  en  un comando,  normalmente  basta con  escribir
{\ttfamily $<$Nombre del comando$>$ {--}{--}help}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuSUX nor --sort.

  -a, --all                  do not hide entries starting with .
  -A, --almost-all           do not list implied . and ..
  -b, --escape               print octal escapes for nongraphic characters
      --block-size=SIZE      use SIZE-byte blocks
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of
 last
                               modification of file status information)
                               with -l: show ctime and sort by name
                               otherwise: sort by ctime
  -C                         list entries by columns
      --color[=WHEN]         control whether color is used to distinguish
 file
                               types.  WHEN may be `never', `always', or
 `auto'
  -d, --directory            list directory entries instead of contents
  -D, --dired                generate output designed for Emacs' dired mode
  -f                         do not sort, enable -aU, disable -lst
  -F, --classify             append indicator (one of */=@|) to entries
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            list both full date and full time
  -g                         (ignored)
  -G, --no-group             inhibit display of group information
  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M
 2G)
      --si                   likewise, but use powers of 1000 not 1024
  -H                         same as `--si' for now; soon to change
                               to conform to POSIX
      --indicator-style=WORD append indicator with style WORD to entry
 names:
                               none (default), classify (-F), file-type
 (-p)
  -i, --inode                print index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell
 PATTERN
  -k, --kilobytes            like --block-size=1024
  -l                         use a long listing format
  -L, --dereference          list entries pointed to by symbolic links
  -m                         fill width with a comma separated list of
 entries
  -n, --numeric-uid-gid      list numeric UIDs and GIDs instead of names
  -N, --literal              print raw entry names (don't treat e.g.
 control
                               characters specially)
  -o                         use long listing format without group info
  -p, --file-type            append indicator (one of /=@|) to entries
  -q, --hide-control-chars   print ? instead of non graphic characters
      --show-control-chars   show non graphic characters as-is (default
                             unless program is `ls' and output is a
 terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always, c,
 escape
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print size of each file, in blocks
  -S                         sort by file size
      --sort=WORD            extension -X, none -U, size -S, time -t,
                               version -v
                             status -c, time -t, atime -u, access -u, use
 -u
      --time=WORD            show time as WORD instead of modification
 time:
                               atime, access, use, ctime or status; use
                               specified time as sort key if --sort=time
  -t                         sort by modification time
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time
                               with -l: show access time and sort by name
                               otherwise: sort by access time
  -U                         do not sort; list entries in directory order
  -v                         sort by version
  -w, --width=COLS           assume screen width instead of current value
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -1                         list one file per line
      --help                 display this help and exit
      --version              output version information and exit

By default, color is not used to distinguish types of files.  That is
equivalent to using --color=none.  Using the --color option without the
optional WHEN argument is equivalent to using --color=always.  With
--color=auto, color codes are output only if standard output is connected
to a terminal (tty).

Comunicar `bugs' a <bug-fileutils@gnu.org>.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Disculpe  el lector  semejante ejemplo,  pero era  para que  se
viera  la información  que  se  puede obtener  de  primera mano.  Para
consultar con detenimiento esta ayuda, el autor recomienda usar {\ttfamily ls
{--}{--}help  $|$  more},  y  que según  se  avanza  con  la
información, se pulsa la barra espaciadora.
\end{quotation}




\begin{quotation}
Obsérvese que se pueden escribir  los parámetros de dos formas:
una  corta ({\ttfamily -l,  -a}) y  otra larga  ({\ttfamily {--}{--}all,
{--}{--}help}). 
\end{quotation}


\begin{quotation}
Para  crear un  directorio, usaremos  {\ttfamily mkdir $<$nombre  del
nuevo directorio$>$}, y para  eliminarlo {\ttfamily rmdir $<$nombre del
directorio a  eliminar$>$}. {\bfseries ¡Atención!  El directorio  que se
quiere eliminar debe  estar vacío y no debe haber  nadie trabajando en
él en  ese momento.}  Evidentemente, podemos  crear y  destruir un
directorio dando su ruta completa o  sólo su nombre si nos encontramos
en el directorio que lo contiene. En  caso de querer borrar de un sólo
golpe un directorio y todo su contenido disponemos del comando {\ttfamily rm}
con las  opciones {\ttfamily -rf}.  {\bfseries Mucho cuidado con  borrar directorios
enteros sin  comprobar lo que se  hace, pues no hay  marcha atrás}
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ mkdir pepe
[felix@localhost apuntes]$ mkdir tmp
[felix@localhost apuntes]$ rmdir pepe
[felix@localhost apuntes]$ rm -rf tmp
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
en el directorio actual, o también,
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ mkdir /home/felix/pepe
[felix@localhost apuntes]$ rmdir /home/felix/pepe
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
desde cualquier directorio.
\end{quotation}





\subsubsection{Trabajando con ficheros}

\begin{quotation}
Antes que nada, hay que entender  el sistema de permisos de los
ficheros y directorios. Si  escribimos {\ttfamily ls -l}, nos encontramos
con la siguiente salida:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ ls -l
total 468
-rw-rw-r--    1 felix    felix      163004 oct 29 10:05
 Apuntes_CILA_2001.dvi
-rw-rw-r--    1 felix    felix      119151 oct 29 10:05
 Apuntes_CILA_2001.sgml
-rw-rw-r--    1 felix    felix        1617 oct 28 22:15 cabecera.sgml
-rw-rw-r--    1 felix    felix       13329 oct 29 10:05 comandos.sgml
-rwx------    1 felix    felix          33 oct 29 00:32 compila*
drwxrwxr-x    2 felix    felix        4096 oct 28 23:20 CVS/
-rw-rw-r--    1 felix    felix       17250 oct 28 12:11 editores.sgml
-rw-rw-r--    1 felix    felix          12 oct 27 23:10 final.sgml
-rw-rw-r--    1 felix    felix         157 oct 27 23:10 graficos.sgml
-rw-rw-r--    1 felix    felix        2816 oct 28 21:51 internet.sgml
-rw-rw-r--    1 felix    felix       23308 oct 28 23:05 introduccion.sgml
-rw-rw-r--    1 felix    felix         402 oct 27 23:10 LEEME
-rw-rw-r--    1 felix    felix        2295 oct 28 22:19 Makefile
-rw-rw-r--    1 felix    felix       13087 oct 28 17:30 matematicas.sgml
-rw-rw-r--    1 felix    felix         652 oct 28 21:56 presentacion.sgml
-rw-rw-r--    1 felix    felix       34797 oct 28 21:56 programando.sgml
-rw-rw-r--    1 felix    felix          47 oct 28 21:56 recursos.sgml
-rw-rw-r--    1 felix    felix        1320 oct 25 13:35 resumen_temario.txt
-rw-rw-r--    1 felix    felix        4662 oct 28 22:17 sobre.sgml
-rw-rw-r--    1 felix    felix        5247 oct 28 22:19 temario.estado
-rw-rw-r--    1 felix    felix        7417 oct 27 23:10 xwindow.sgml
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
La  primera letra  a  la  izquierda de  cada  línea nos  indica
si  se   trata  de  un   fichero  ({\tt\char`\"}-{\tt\char`\"})  o   un  directorio
({\tt\char`\"}d{\tt\char`\"}).
\end{quotation}


\begin{quotation}
Después  nos  encontramos  con   tres  grupos  de  tres  letras
({\tt\char`\"}rwx{\tt\char`\"}), que según estén  activados (la propia letra, r,w,x)
o  desactivados  (un guión,  -)  nos  concede  o deniega  permisos  de
lectura ({\ttfamily r}), escritura ({\ttfamily w}) y ejecución ({\ttfamily x}).
\end{quotation}
  
\begin{quotation}
¿Y  por   qué  son  tres  grupos?   Pues  porque  las
tres  primeras  letras  se  refieren  al  propio  usuario  que  es  el
dueño  de esos  ficheros,  el segundo  grupo se  refiere  al grupo  de
usuario  que  pertenece ese  usuario,  y  el  tercero a  los  usuarios
{\tt\char`\"}extraños{\tt\char`\"} o  {\tt\char`\"}ajenos{\tt\char`\"} al  usuario. Por  tanto, si
leemos
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
-rw-rw-r--
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
vemos que se trata de un  fichero (-) con permisos de lectura y
escritura  para el  usuario y  el grupo  al que  pertenece, y  de sólo
lectura para un {\tt\char`\"}extraño{\tt\char`\"}.
\end{quotation}




\begin{quotation}
El siguiente sería un fichero de lectura, escritura y ejecución
únicamente para el usuario propietario del fichero.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
-rwx------
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Este  último  ejemplo es  un  directorio  (d) con  permisos  de
lectura,  escritura y  ejecución  para el  usuario y  el  grupo, y  de
lectura  y  ejecución  para  el {\tt\char`\"}extraño{\tt\char`\"}.  En  el  caso  de
directorios, el  permiso de  ejecución es  equivalente a  permiso para
{\tt\char`\"}entrar{\tt\char`\"} en el directorio. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
drwxrwxr-x
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
En el ejemplo del listado anterior vemos dos veces el nombre de
{\tt\char`\"}felix{\tt\char`\"}. El  de la primera  columna se refiere  al usuario
propietario,  y el  segundo es  el nombre  del grupo,  que casualmente
coincide con  el nombre  del usuario.  Esto es  importante recordarlo,
porque  debemos tener  en cuenta  que {\bfseries jamás  podremos eliminar  un
fichero o retocarlo si no tenemos permisos de escritura sobre él}.
Esto es impensable en algunas versiones de {\ttfamily Windows}. 
\end{quotation}


\begin{quotation}
El  comando para  copiar un  fichero es  {\ttfamily cp $<$fichero  de
origen$>$ $<$fichero de destino$>$},  es decir, que copiamos el
fichero {\bfseries pepe.txt} en {\bfseries juan.txt}. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ cp pepe.txt juan.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




\begin{quotation}
El  comando  para  mover  o  renombrar  un  fichero  es  {\ttfamily mv
$<$fichero de  origen$>$ $<$fichero de destino$>$},  es decir,
que copiamos  el fichero {\bfseries pepe.txt} en  {\bfseries juan.txt}, pero
{\bfseries pepe.txt} deja de existir físicamente. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ mv pepe.txt juan.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
{\bfseries NOTA: El intérprete de  comandos SÍ distingue en mayúsculas
y minúsculas,  tanto en  el caso  de los  comandos como  en el  de los
ficheros y directorios. Esto significa que el comando mv es totalmente
diferente a Mv, mV y MV. Asimismo,  el fichero pepe.txt no es el mismo
fichero que Pepe.txt, ni que PEPE.TXT, etc. }
\end{quotation}




\begin{quotation}
Un  último punto  a esta  sección. Si  queremos que  un fichero
cambie de propietario, lo haremos, con {\ttfamily chown}: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ chown miguel pepe.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
si antes, {\bfseries pepe.txt} era de {\ttfamily felix}, ahora pasa a
ser de {\ttfamily miguel}.
\end{quotation}


\begin{quotation}
De   igual   forma,   para   cambiarlo   de   grupo,   usaremos
{\ttfamily chgrp}. Si {\bfseries pepe.txt} era  del grupo de los profesores,
y  queremos que  sea  del grupo  de los  estudiantes,  sólo habrá  que
escribir lo siguiente:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ chgrp estudiantes pepe.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Finalmente,  para  cambiar  los  permisos  de  un  fichero,  lo
haremos con {\ttfamily chmod},  indicando a que tipo  de usuario queremos
asignarlos y sobre qué permisos.  Para indicar el usuario propietario,
usaremos el  parámetro {\ttfamily u},  el de grupo  será {\ttfamily g}  y el
ajeno será  {\ttfamily o}, (de {\ttfamily otros}).  Para indicar el  tipo de
permiso,  usaremos  las  letras  {\ttfamily r},  {\ttfamily w},  {\ttfamily x},
según  sean  de  lectura,  escritura o  ejecución  respectivamente.  Y
para  conceder  o denegar,  usaremos  los  símbolos {\tt\char`\"}+{\tt\char`\"}  y
{\tt\char`\"}-{\tt\char`\"}:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ chmod u+rwx pepe.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Este ejemplo sirve para dar todos los permisos al usuario.
\end{quotation}


\begin{quotation}
En el siquiente ejemplo daremos permisos de lectura y ejecución al
usuario y al grupo, pero no de escritura sobre el fichero {\bfseries compila}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ chmod ug+r-x compila
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O quitar el  permiso de ejecución a todos los  usuarios sin que
se vean afectados los otros tipos de permisos: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ chmod -x probar
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Comandos básicos para sobrevivir}

\begin{itemize}
\item {\ttfamily clear}: limpia la  pantalla de la consola  (teclas CTRL+L)
\item {\ttfamily top}: muestra los  procesos que se ejecutan  en ese momento,
sabiendo los recursos que se están consumiendo.
\item {\ttfamily locate}: es la orden de  búsqueda más rápida y sencilla para
localizar un archivo.
\item {\ttfamily whoami}: de  (Who am  I?, ¿Quién soy?),  que indica  con qué
nombre de usuario se entró en esa consola. Puede parecer una tontería,
pero si una persona entra en dos  sesiones, en una como root y en otra
como usuario  normal, si no se  sabe quién es en  ese momento, podrían
ocurrir accidentes catastróficos.
\item {\ttfamily reset}:  si  observamos  que  escribimos en  pantalla  y  no
aparece  el  texto  pero  al   pulsar  {\ttfamily enter}  realmente  se  está
escribiendo,  o  que  los  colores  o los  textos  de  la  consola  se
corrompen,  puede  ser  que  alguna  aplicación  en  modo  texto  haya
finalizado  bruscamente  no restaurando  los  valores  estándar de  la
consola  al  salir.  Con  esto  forzamos  unos  valores  por  defecto,
regenerando la pantalla.
\end{itemize}





\subsection{El comando {\ttfamily man}}

\begin{quotation}
 Este  comando es muy útil,  ya que nos dará  mucha información
sobre  la mayoría  de  los  comandos con  los  que  vamos a  trabajar.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[felix@localhost apuntes]$ man bash
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Omitmos la información de salida  ya que puede ser muy extensa
e invita al lector a que lo pruebe él mismo. 
\end{quotation}





\subsection{Unidades de disco}

\begin{quotation}
  Como  hemos dicho  anteriormente,  en  Linux no  existen  las
unidades  {\ttfamily A}:   ni  {\ttfamily C:}   sino  que  todos   los  dispositivos
{\tt\char`\"}cuelgan{\tt\char`\"} del directorio raíz  {\ttfamily /}. Para acceder a un
disco  es necesario  primero {\itshape montarlo\/},  esto es  asignarle un
lugar dentro del árbol de directorios del sistema. Por ejemplo podemos
asignar a la  disquetera el directorio {\ttfamily /floppy},  al CD-ROM el
directorio  {\ttfamily /cdrom} o  a  la grabadora  de  CDs el  directorio
{\ttfamily /grabata}. Normalmente los directorios para la disquetera y el
lector de  CD-ROM están ya asignados  desde el momento de  instalar el
sistema,  aunque se  puede  cambiar  a voluntad  (si  somos root  ;-).
\end{quotation}


\begin{quotation}
  Para montar  un  disco utilizamos  el comando  {\ttfamily mount}
indicándole como parámetros  el dispositivo al que  queremos acceder y
el  directorio  en  el  que  lo queremos  montar.  Sin  embargo  estas
precisiones suelen ser responsabilidad  del administrador (root) y los
usuarios tienen  que conformarse  montar lo que  root les  permita. En
nuestro  caso el  señor  root  ha determinado  que  los usuarios  sólo
podemos  montar  la  disquetera  en  el  directorio  {\ttfamily /floppy}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[miguev@euler apuntes]$ mount /dev/fd0 /floppy
mount: only root can do that
[miguev@euler apuntes]$ mount /floppy
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Una vez montado el  disquete en el directorio {\ttfamily /floppy}
ya podemos acceder a  él y trajinar sus ficheros como  nos dé la gana.
Pero  ahora viene  el  pero:  pobre de  quien  saque  el disquete  sin
desmontarlo. ¿Por qué? Pues por tres razones: 
\end{quotation}


\begin{enumerate}
\item  Existe  el riesgo  de que perdamos  la información  que hayamos
grabado en el disquete.
\item  Ningún otro usuario podrá usar la disquetera hasta que se reinicie
el ordenador, lo cual no le hará gracia a nadie.
\item  El Sr.  root puede mosquearse con  quien lo haga, y  a nadie le
conviene que el tiener mosqueado al Sr. root.
\end{enumerate}


\begin{quotation}
Para desmontar  el diquete  simplemente utilizamos  el sencillo
comando: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[miguev@euler apuntes]$ umount /floppy
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Para comprobar en un momento  dado si el disquete está montado
podemos  usar  el  comando  {\ttfamily df}, que  nos  informa  sobre  los
{\tt\char`\"}sistemas de  ficheros{\tt\char`\"} que  están montados  y su  estado de
almacenamiento. La  opción {\ttfamily -h}  nos muestra las  cantidades en
cifras {\tt\char`\"}{\bfseries h}umanas{\tt\char`\"}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
[miguev@euler apuntes]$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda2             1.9G  1.8G   80M  96% /
euler:/home            20G  3.2G   16G  17% /home
euler:/usr/soft       3.9G  5.4M  3.7G   0% /usr/soft
/dev/fd0              1.4M  758k  665k  53% /floppy
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Aquí  vemos  que  la   segunda  partición  del  primer  disco
duro  {\ttfamily /dev/hda2} está  montada  en  el directorio  {\ttfamily /},
los  directorios  {\ttfamily /home}  y  {\ttfamily /usr/soft}  del  servidor
{\ttfamily euler}   están  montados   en  sus   equivalente  locales,   y
el   disquete  {\ttfamily /dev/fd0}   está  montado   en  el   directorio
{\ttfamily /floppy}. 
\end{quotation}









\section{Editores de texto
      }


\subsection{Joe}

\begin{quotation}
 El  primer editor que  suele aprenderse en Linux  es {\ttfamily Joe},
por  ser muy  sencillo y  rápido. Puede  usarse para  editar cualquier
fichero,  pero aquí  trataremos  su uso  básico  para editar  pequeños
textos,  ficheros de  configuración, pequeños  programas. Todos  estos
ficheros pueden editarse  con más comodidad con  editores más potentes
como  Emacs o  VIM  pero para  ello es  necesario  aprender a  usarlos
primero,  lo  cual  puede  no  resultar  tan  sencillo  como  aprender
{\ttfamily Joe}.
\end{quotation}


\begin{quotation}
 Veremos sólo un par  de comandos de {\ttfamily Joe}, simplemente como
editar un  fichero existente o  nuevo, guardarlo sin salir,  salir sin
guardarlo  y salir  guardándolo.  Para obtener  más información  sobre
otras opciones del editor existe  el comando de ayuda que explicaremos
luego. 
\end{quotation}


\begin{quotation}
 El manejo  de {\ttfamily Joe} se basa en combinaciones  de teclas con
la tecla {\ttfamily Control}. Denotaremos por  {\ttfamily $<$Ctrl$>$x y} a la combinación de
teclas que  se obtiene al  pulsar la tecla  {\ttfamily Control}, seguidamente
(sin soltar la primera) pulsar la tecla {\ttfamily x} y después (soltando las
teclas anteriores)  pulsar la tecla  {\ttfamily y}. Veamos un  rápido ejemplo
del uso de este editor. En un terminal ejecutamos: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ joe prueba.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Escribimos una frase sencilla, tal como:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Si algo funciona, no lo toques.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Para  guardar el fichero  utilizamos la combinación  de teclas
{\ttfamily $<$Ctrl$>$k s}  y entonces {\ttfamily Joe}  nos preguntará  el nombre con  el que
queremos guardar el fichero. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Name of file to save (^C to abort): hola.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Si pulsamos  ahora ahora  {\ttfamily $<$Ctrl$>$c} simplemente  cancelamos la
orden  de guardar  el fichero,  pero  no perdemos  su contenido.  Para
guardar  el fichero  pulsamos  {\ttfamily Enter}, modificando  el nombre  del
fichero si lo deseamos. Ahora añadimos otra línea:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Si algo funciona, no lo toques.
Si algo funciona, y no sabes porqué, úsalo siempre.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Ahora  saldremos  del   editor  {\bfseries guardando  los  cambios},
mediante  la  combinación  de  teclas   {\ttfamily $<$Ctrl$>$k  x}.  De  esta  manera
volveremos al prompt  del sistema siendo informados de  que el fichero
ha sido guardado. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
File prueba.txt saved.
$
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Como última maniobra, abrimos de nuevo el fichero, borramos la
última línea y salimos sin guardar los cambios. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ joe prueba.txt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Boramos la  última línea  como haríamos  en el  {\ttfamily edit} del
{\ttfamily DOS}, y pulsamos  {\ttfamily $<$Ctrl$>$c} para salir sin guardar  los cambios. El
editor nos pedirá  confirmación antes de salir.  Podemos responder que
sí  queremos salir  pulsando {\ttfamily y},  o por  el contrario  cancelar la
maniobra  pulsando  {\ttfamily n}  o  {\ttfamily $<$Ctrl$>$c}. Decimos  que  sí  ({\ttfamily y})  y
volvemos al prompt del sistema.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Lose changes to this file (y,n,^C)? 
File hola.txt not saved.
$
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Esto es lo mínimo que  debemos saber para editar con {\ttfamily Joe},
y con esto  nos conformaremos aquí pues en lo  sucesivo aprenderemos a
hacer operaciones más avanzadas con otros editores. Para conocer sobre
otras opcioens de este editor, se peude utilizar la opción {\ttfamily $<$Ctrl$>$k h}.
\end{quotation}





\subsection{Emacs }

\begin{quotation}
 {\ttfamily Emacs},  junto con  {\ttfamily VI}, ha  sido uno  de los  primeros
editores  de texto  para UNIX.  A  pesar de  visualmente presentar  un
interfaz similar al de un editor  de texto corriernte, como podría ser
{\ttfamily joe}, el  {\ttfamily edit} de MS-DOS, o  similar, lo cierto es  que tiene
muchisimas posibilidades que uno no atribuiría a un editor de texto en
modo consola. Por  ejemplo, el indentado automático  de código Pascal,
Java, C, o cualquier lenguaje para  el que haya escrito un módulo para
Emacs de  asistencia a  la programación,  nos ofrece  posibilidades de
trabajar con  CVS, enviar correo  electrónico, y un largo  etcétera de
posibilidades. Como anécdota cabe contar,  para que se hagan una idea,
el  manual de  GNU Emacs,  en  formato ASCII  ocupa cerca  de 1.1  MB.
\end{quotation}


\begin{quotation}
Hablemos  de cómo  manejarse con  los menús  de Emacs.  Existen
cientos de  combinaciones de  teclas en Emacs  que nos  permiten hacer
cualquier cosa sin ver un menú. Los usuarios expertos de Emacs valoran
esta posibilidad, pues a la hora de escribir con prisas, un menú puede
ser  algo  muy  incómodo.  Pero  para  ustedes  que  están  empezando,
recuerden: la tecla {\ttfamily $<$F10$>$} es su amiga.
\end{quotation}


\begin{quotation}
La tecla  {\ttfamily $<$F10$>$} nos da  acceso a todos los  menús de
Emacs, menu archivo,  edición, cambio entre las  distintas ventanas de
edición de texto, etc.
\end{quotation}


\begin{quotation}
Empezemos viendo como editar un  fichero de texto básico. En la
consola ponemos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ emacs prueba.c
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
y escribimos un programa común y corto:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#include <stdio.h>
int
main()
{
  printf("\nHola Mundo\n\n";
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Como  podemos  apreciar, Emacs  hace  retroceder  el cursor  al
cerrar  los corchetes  y  los paréntesis,  para  indicarnos donde  los
abrimos  y tener  una  referencia  de cuáles  quedan  aún por  cerrar.
Probemos  ahora  a  guardar  nuestro pequeño  programa  C.  Para  ello
pulsamos {\ttfamily $<$F10$>$} y una vez pulsada {\ttfamily $<$F10$>$} vemos que
la tecla {\ttfamily B} nos daría acceso al menú buffers (que no son otra cosa
que las distintas ventanas que  tenemos abiertas), la {\ttfamily F} nos daría
acceso  al  menú  {\ttfamily files}  (el cual  hace  practicamente  lo  mismo
que  el  menú archivo  de  cualquier  editor  de  texto, etc...  y  la
tecla  {\ttfamily C} nos  daría  acceso,  si las  tenemos  instaladas, a  las
posibilidades que  ofrece emacs para la  edición de código en  C. Como
solo queremos  guardar, pulsamos después de  {\ttfamily $<$F10$>$}, {\ttfamily S}.
Ya  lo tendríamos  guardado. Otra  cosa muy  importante, en  cualquier
programa es saber salir. Esto se hace con {\ttfamily $<$F10$>$}, {\ttfamily F} y a
continuación la tecla  {\ttfamily S}. Nos pregunta, si no lo  hemos hecho ya,
que  si  deseamos guardar.  Escribimos  {\ttfamily yes}  (hay que  escribirlo
entero) o {\ttfamily no}, y a continuación nos pregunta si realmente queremos
salir, a lo cual ahora si,  responderemos {\ttfamily y} para {\ttfamily si} o {\ttfamily n}
para {\ttfamily no}. 
\end{quotation}


\begin{quotation}
Una   función  muy   básica   tambien  es   la   de  buscar   y
reemplazar texto.  Esto puede  hacerse cómodamente con  la combinación
{\ttfamily $<$Ctrl$>$-s}, dejando  pulsado la tecla  {\ttfamily $<$Control}$>$ y
pulsando la  {\ttfamily s}, y a  continuación poniendo que queremos  buscar y
pulsando {\ttfamily Enter}. Una vez  encuentre la primera coincidencia, puede
seguir  buscándose  el  mismo  patrón pulsando  de  nuevo  simplemente
{\ttfamily $<$Ctrl$>$-s}. 
\end{quotation}


\begin{quotation}
Podemos saber  en todo momento que  estamos haciendo fijándonos
en la linea inferior de la pantalla de Emacs.
\end{quotation}


\begin{quotation}
Para reemplazar trozos de texto, cosa también de supervivencia,
podemos hacerlo fácilmente de la siguiente forma:
\end{quotation}


\begin{enumerate}
\item  Pulsamos $<$F10$>$.
\item  Pulsamos la S, que corresponde al menú Search.
\item  Nos sale el siguiente menú:
\end{enumerate}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Possible completions are:
S==>Search...                      R==>Regexp Search...
B==>Search Backwards...            0==>Regexp Search Backwards...
1==>Repeat Search                  2==>Repeat Regexp
3==>Repeat Backwards               4==>Repeat Regexp Backwards
5==>Bookmarks                      F==>Find Tag...  (M-.)
Q==>Query Replace...  (M-%)        6==>Query Replace Regexp...
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Pulsamos {\ttfamily Q} y nos dice:
\end{quotation}


\begin{quotation}
{\ttfamily Query replace:}  donde escribiremos lo que  queremos buscar
para ser reemplazado, y pulsamos {\ttfamily Enter}.
\end{quotation}


\begin{quotation}
Luego,  emacs nos  pregunta:  {\ttfamily query replace  with: }  donde
escribiremos el  texto con  el cual  queremos sustituir,  y pulsaremos
enter.
\end{quotation}


\begin{quotation}
En este menú,  encontramos también una serie  de comandos, como
{\ttfamily query  regexp}, {\ttfamily query  replace  regexp}, etc.,  que aunque  no
entraremos en ellos,  son muy interesantes, pues  nos permiten buscar,
no  ya patrones  de  texto concretos,  sino un  tipo  de búsqueda  más
avanzada por  medio de  expresiones regulares (regular  expressions en
inglés),  esto es,  {\tt\char`\"}todas  las  palabras que  empiecen  por c  y
terminen  por  j{\tt\char`\"} o  {\tt\char`\"}todas  las  mayúsculas cambiarlas  por
minúsculas{\tt\char`\"} en el caso de {\ttfamily query replace regexp}.
\end{quotation}





\subsection{VI y VIM}

\begin{quotation}
 {\ttfamily VI}  es un editor  de texto visual, de  pantalla completa,
basado en  el editor de línea  {\ttfamily ex}. Es un editor  poco intuitivo y
con mala  prensa entre los estudiantes  que dan sus primeros  pasos en
UNIX/Linux, pero por otra parte es  el editor favorito de los usuarios
avanzados y de muchos programadores. Es  además un editor que se puede
encontrar  en cualquier  sistema UNIX,  desde antiguas  estaciones Sun
Solaris o HP-UX hasta las  más recientes distribuciones de GNU/Linux o
FreeBSD, OpenBSD,  etc. {\ttfamily VI} es  además un editor muy  potente, que
permite  hacer complicadas  operaciones en  grandes ficheros  con unos
pocos  comandos, por  lo  que su  aprendizaje  puede ahorrarnos  mucho
tiempo. Otra  ventaja de  {\ttfamily VI} es  que al  ser tan  corriente suele
encontrarse incluso en disquetes de rescate. Lógicamente poco se puede
rescatar  si no  se  sabe manejar  el único  editor  disponible en  un
momento de emergencia. Pero el manejo de {\ttfamily VI} es realmente incómodo
si nos enfrentamos  a la versión clásica. Por ejemplo  no podemos usar
los  cursores para  movernos por  el texto,  debemos pasar  al llamado
{\tt\char`\"}modo comando{\tt\char`\"} y utilizar letras para movernos. 
\end{quotation}


\begin{quotation}
  En  este  curso  utilizaremos el  editor  {\ttfamily VIM}.  {\ttfamily VIM}
significa {\tt\char`\"}{\bfseries V}i  {\bfseries IM}proved{\tt\char`\"} ({\bfseries VI M}ejorado{\tt\char`\"}),
y como su  nombre indica es un clon (muy)  mejorado del clásico editor
{\ttfamily VI}. {\ttfamily VIM} es bastante más amigable que {\ttfamily VI}, ya que permite
un uso más intuitivo (p.ej. los cursores y otras teclas para moverse).
\end{quotation}


\begin{quotation}
 Lo primero que debe aprenderse con {\ttfamily VIM} es la filosofía de
los dos modos de trabajo: el modo {\ttfamily comando} y el modo {\ttfamily edición}.
El  modo comando  se utiliza  sólamente  para dar  órdenes al  editor,
decirles que haga cosas como borrar  una línea, buscar un patrón, ir a
una  determinada  línea,  guardar  el fichero,  salir,  etc.  El  modo
{\ttfamily edición} se utiliza  sólamente para escribir texto  en el fichero.
Es muy importante familiarizarse con esta filosofía de funcionamiento,
ya que resulta  imprescindible para cualquier operación  que se quiera
realizar con {\ttfamily VIM}. 
\end{quotation}


\begin{quotation}
 Para ejecutar este editor el comando es: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
   $ vi
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Aunque  conserva el nombre  de {\ttfamily VI} estamos  trabajando con
{\ttfamily VIM}. Este comando  admite varias opciones que se  le pueden pasar
como  parámetros, p.ej.  el nombre  del fichero  que queremos  editar:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
   $ vi fichero
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 {\ttfamily VIM} comienza siempre en modo {\ttfamily comando}, preparado para
realizar operaciones  sobre el  fichero. Una  de estas  operaciones es
pasar al modo  {\ttfamily edición} pulsando la tecla  {\ttfamily i} (Insertar). Para
pasar del modo  {\ttfamily edición} al como {\ttfamily comando} basta  con pulsar la
tecla de escape, que llamaremos {\ttfamily $<$ESC$>$}. A continuación vamos
a editar  un pequeño  fichero de prueba  para familiarizarnos  con sus
comandos básicos. 
\end{quotation}


\begin{quotation}
 Comenzamos invocando al editor desde la línea de comandos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
   $ vi prueba.txt
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Veremos que  en  la última  línea de  la  consola aparece  lo
siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
"prueba.txt" [New File]                                        0,0-1 All
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Esta  línea  es  la  {\ttfamily barra  de  estado}  del  editor.  Es
aquí  donde  teclearemos algunos  comandos  y  donde aparecerá  cierta
información como, como  el modo en el que estamos,  la línea y columna
en la que estamos, el porcentaje del documento en el que estamos, etc.
\end{quotation}


\begin{quotation}
 A  continuación pulsamos  la tecla {\ttfamily i}  para pasar  al modo
{\ttfamily edición}. Observamos que la barra  de estado se muestra diferente:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
-- INSERT --                                                     0,1 All
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Tecleamos por ejemplo lo siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 Lo pequeño es bello.  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Cuando  tenemos algo  escrito, pulsamos  {\ttfamily $<$ESC$>$} para
pasar  al modo  {\ttfamily comando}. Entonces  tecleamos la  orden {\ttfamily :w}  y
pulsamos {\ttfamily $<$Enter$>$}. Veremos como  la orden {\ttfamily :w} aparece en
la barra  de estado mientras  la tecleamos,  y luego al  ejecutarla se
muestra información sobre el resultado, en este caso información sobre
el fichero que acabamos de guardar. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
"prueba.txt" [New] 1L, 21C written                              1,20 All
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Pasamos  nuevamente  al  modo  {\ttfamily edición}  pulsando  {\ttfamily a}
(observamos   la  diferencia   con   pulsar   {\ttfamily i})  y   continuamos
escribiendo: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
   ---
   Lo pequeño es bello.
   ---
   La  medida de programar es programar sin medida.
   ---
   Software is like sex, it's better when it's free.
   ---
   
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Observamos  como podemos movernos  libremente por el  texto en
modo {\ttfamily edición} utilizando los cursores,  las teclas de Inicio, Fin,
Av. Pag, Re.  Pag., etc. Esto no puede hacerse  en el {\ttfamily VI} clásico.
Volvemos a guardar el fichero con la orden {\ttfamily :w}. 
\end{quotation}


\begin{quotation}
  Ahora pensemos  que  queremos eliminar  esas  líneas de  tres
guiones y  cambiarlas por líneas  de cinco asteriscos. Pasamos  a modo
{\ttfamily comando},  situamos el  cursor en  una  de esas  línas y  pulsamos
{\ttfamily dd}. Veremos como  la línea entera desaparece.  Repetimos lo mismo
con  las otras  líneas.  Ahora  nos situamos  en  la  primera línea  y
pasamos a  modo {\ttfamily edición},  escribimos cinco asteriscos  y pulsamos
{\ttfamily $<$Enter$>$}. Volvemos al modo  {\ttfamily comando}, situamos el cursor
en la  nueva línea de  asteriscos y  pulsamos de nuevo  {\ttfamily dd}, vemos
como la  línea desaparece. Situamos  el cursor  en el principio  de la
línea y pulsamos  {\ttfamily P}, vemos como la línea que  habíamos borrado se
inserta {\itshape antes\/} del  cursor. Si situamos el cursor  al principio de
la tercera  línea y  pulsamos {\ttfamily p}  vemos como  la línea  se inserta
{\itshape después\/} del  cursor. Añadimos las restantes  líneas de asteriscos
donde estaban las de guiones. 
\end{quotation}


\begin{quotation}
 Para  deshacer cualquier operación realizada  pulsamos en modo
{\ttfamily comando} la tecla  {\ttfamily u}. Para salir del  editor {\itshape sin\/} guardar
el fichero se usa la orden  {\ttfamily :q!}. Esta operación se suele realizar
con mucha frecuencia al principio,  cuando se comete algún error grave
como teclear  una palabra sin pasar  al modo {\ttfamily edición}. En  el modo
{\ttfamily comando} cada  tecla tiene  su función, y  es diferente  además si
está en  mayúsculas que si  está en minúsculas.  Una regla de  oro con
{\ttfamily VIM} es: cuando no se sabe con qué comando se hace algo, no probar
teclas  al  azar.  Y  por  supuesto,  cuando  se  está  editando  algo
importante  guardar  el  fichero  cada con  frecuencia  con  la  orden
{\ttfamily :w}, sobretodo en las primeras semanas de uso. 
\end{quotation}




\begin{quotation}
 Con estos pocos comandos  es suficiente para la edición básica
de  textos  y programas.  En  la  tabla 1  se  resumen  estos y  otros
comandos: 
\end{quotation}


\begin{table}[hbtp]
\begin{center}
\begin{tabular}{lll}
Comando & Descripción\\ 
{\ttfamily $<$ESC$>$} & Mientras se teclea un comando, lo cancela\\ 
{\ttfamily i} & Inserta en la posición del cursor (pasa a modo comando)\\ 
{\ttfamily a} & Inserta tras la posición del cursor (pasa a modo comando)\\ 
{\ttfamily I} & Inserta al inicio de la línea (pasa a modo comando)\\ 
{\ttfamily A} & Inserta al final de la línea (pasa a modo comando)\\ 
{\ttfamily x} & Borra un caracter\\ 
{\ttfamily r} & Reemplaza un carater\\ 
{\ttfamily u} & Deshace la última operación realizada (se puede repetir paradeshacer varias operaciones)\\ 
{\ttfamily U} & Deshace los cambios efectuados sobre la línea actual\\ 
{\ttfamily :q} & Salir del editor\\ 
{\ttfamily :x} & Salir del editor {\bfseries guardando} el fichero\\ 
{\ttfamily :q!} & Salir del editor {\bfseries sin guardar} el fichero\\ 
{\ttfamily :w} & Guardar el fichero\\ 
{\ttfamily :w nombrefichero} & Guardar el fichero con nombre {\bfseries nombrefichero}\\ 
{\ttfamily nG} & Ir a la línea {\ttfamily n}\\ 
{\ttfamily \$G} & Ir al final del fichero\\ 
{\ttfamily v} & Activa el modo de selección (utiliza los cursores paraseleccionar texto\\ 
{\ttfamily y} & Copia en memoria (buffer) el texto seleccionado\\ 
{\ttfamily d} & Borra el texto seleccionado, y lo copia en memoria (buffer)\\ 
{\ttfamily p} & Pega el texto copiado en memoria, tras la posición del cursor\\ 
{\ttfamily P} & Pega el texto copiado en memoria, en la posición del cursor\\ 
{\ttfamily :syntax on} & Activa el coloreado de sintaxis\\ 
{\ttfamily :syntax off} & Desactiva el coloreado de sintaxis\\ 
{\ttfamily /palabra} & Busca la cadena {\ttfamily palabra} hacia adelante\\ 
{\ttfamily ?palabra} & Busca la cadena {\ttfamily palabra} hacia atrás\\ 
{\ttfamily n} & Muestra la siguiente conicidencia de la última búsqueda
\end{tabular}
\end{center}
\caption{Comandos básicos del VI.}
\end{table}





\subsection{Otros editores }

 
\begin{quotation}
 Los tres editores de texto que
hemos visto hasta ahora trabajan  en modo consola, sin entorno gráfico
ni ventanas, ni siquiera utilizan el ratón. Obviamente hay disponibles
muchos  más editores  de  texto en  Linux, tanto  de  consola como  de
entornos gráficos. Veamos dos editores  de entorno gráfico que vale la
pena presentar. 
\end{quotation}









\subsubsection{Kwrite}

\begin{quotation}
 {\ttfamily Kwrite} es un potente editor de textos para KDE que cuenta
con  todo  lo  necesario  para  editar cualquier  tipo  de  texto,  es
configurable en todos los aspectos, desde  el tipo de letra con la que
se nos presentará el texto editado hasta las teclas de acceso rápido a
las funciones que implementa este editor. 
\end{quotation}


\begin{quotation}
 Entre las características  que tiene destaca el reconocimiento
de la  sintaxis de muchos  lenguajes de programación (C,  C++, PASCAL,
FORTRAN, LATEX,  etc ...) el indentado  automático, deshacer, rehacer,
copiar, pegar, buscar, reemplazar y  un largo excétera de herramientas
útiles para la edición. 
\end{quotation}





\subsubsection{gnotepad+}

\begin{quotation}
  {\ttfamily Gnotepad+} es  un  editor con  prácticamentes las  mismas
capacidades que  el kwrite  de KDE solo  que en este  caso es  para el
entorno  de GNOME  y no  tiene  tantas opciones  de reconocimiento  de
sintaxis como el kwrite, en  cambio tiene algunas herramientas para la
edición de código HTML interesantes  para el desarrollo de un proyecto
para la web de poca complejidad, como son la posibilidad de visualizar
como va quedando el código que vamos haciendo, botones que simplifican
la inserción  de ciertos elementos del  lenguaje html, etc ...  Una de
las  capacidades  interesantes del  gnotepad  es  la de  poder  editar
simutáneamente  varios ficheros  fuente con  un solo  editor y  varias
pestañas  de edición,  lo cual  resulta interesante  para no  tener el
escritorio lleno de ventanas y la memoria del sistema desperdiciada en
llevar cuatro procesos exactamente iguales. 
\end{quotation}





\section{El entorno X-Window
    }


\subsection{Qué es X-Window}

\begin{quotation}
En algunos sistemas operativos el entorno gráfico, más conocido
como  {\bfseries GUI  (Graphic  User   Interface)}  es  una  parte  inherente
del  sistema.  Los  diseñadores  de dichos  sistemas  no  conciben  el
funcionamiento de la  máquina en situaciones donde el GUI  no sólo sea
inútil  sino  que  incluso  implique  un  desperdicio  innecesario  de
recursos. En esos  casos el entorno gráfico no sólo  no es sustituible
sino que el sistema no puede funcionar sin él.
\end{quotation}


\begin{quotation}
Los sistemas operativos  UNIX existen desde los  tiempos en que
los ordenadores no contaban con otra  cosa que no fuera una consola en
modo texto. Y han evolucionado a  lo largo del tiempo incorporando las
correspondientes innovaciones  tecnológicas debidas a  la implantación
del modo  gráfico por  los ordenadores  de todo el  mundo. A  causa de
dicho  proceso  de evolución,  en  Linux  el  entorno gráfico  es  una
aplicación  más de  las muchas  que pueden  estar ejecutándose,  o no,
en  el  sistema. Por  lo  tanto  puede  ser sustituido  según  nuestra
conveniencia.
\end{quotation}


\begin{quotation}
El  entorno  gráfico  más  ampliamente extendido  en  el  mundo
UNIX/Linux  son  las X-Window,  conocidas  comúnmente  como {\bfseries X}  a
secas.
\end{quotation}





\subsection{Arquitectura de las X-Window}

\begin{quotation}
Las X presentan una arquitectura, en  muchos casos alabada
pero  en  otros muchos  criticada,  que  se  divide en  dos  elementos
fundamentales:
\end{quotation}


\begin{description}


\item[Cliente  X.] \mbox{}

Se puede  denominar así  a todas  y cada  una de  las
aplicaciones que hacen uso del sistema X.



\item[Servidor  X.] \mbox{}

Es  la  aplicación  que   gestiona  el  uso  de  los
dispositivos  de  salida  (p.ej.  tarjetas gráficas,  etc)  y  de  los
dispositivos de entrada (p.ej. teclados, ratones, etc)



\end{description}


\begin{quotation}
Las pulsaciones de  tecla, el movimiento del  ratón o cualquier
otra acción  del usuario en  los dispositivos de entrada  es detectada
por servidor y transferida al cliente. De la misma manera los clientes
transfieren al servidor las peticiones de operaciones a realizar sobre
el dispositivo de  salida (p.ej. trazar un línea  en pantalla, dibujar
un  punto,  volcar un  bitmap,  etc).  La comunicación  entre  cliente
y  servidor  sigue un  protocolo  estandarizado  que corre  sobre  los
servicios  de red  del  sistema.  Esto permite  a  un  usuario con  un
servidor X en funcionamiento trabajar  con aplicaciones cliente que se
ejecutan  en  otro ordenador  sin  por  ello notar  diferencia  alguna
respecto a las  aplicaciones que se están ejecutando en  su máquina. A
parte de eso las X realizan ciertas optimizaciones en los casos en los
que cliente y servidor se encuentran  en la misma máquina. Por ejemplo
se  permite el  acceso  directo al  hardware de  la  tarjeta de  vídeo
ignorando  el  protocolo  descrito,  con  lo  que  se  aprovechan  las
características  de aceleración  3D de  muchas tarjetas  modernas. Con
ello  las X  se convierten  en  una plataforma  potente para  ejecutar
aplicaciones exigentes  desde un punto  de vista gráfico sin  por ello
perder su flexibilidad.
\end{quotation}





\subsection{Gestores de ventanas y entornos de escritorio}

\begin{quotation}
En todo buen entorno  gráfico moderno las aplicaciones utilizan
ventanas para  interactuar con el  usuario. Sin embargo el  servidor X
sólo entiende un  número limitado de primitivas  gráficas como dibujar
líneas  y puntos  o copiar  áreas  de la  pantalla. Por  ello se  hace
necesaria la presencia de una  aplicación cliente {\itshape especial\/} que se
encargue  de crear,  destruir, mover,  controlar el  foco y  en general
gestionar  todas las  cuestiones referentes  al comportamiento  de las
ventanas utilizando las primitivas del  servidor X. A dicha aplicación
se la denomina {\bfseries gestor de ventanas}.
\end{quotation}


\begin{quotation}
En una distribución de Linux  pueden haber cerca de 40 gestores
de ventanas  entre los que un  usuario debe elegir. Cada  uno de ellos
imprime un feeling diferente a nuestro entorno de trabajo. Tengamos en
cuenta  que cada  gestor dibuja  los  elementos del  marco de  nuestra
ventana de  forma diferente (e.j. la  barra de título, los  botones de
control,  los bordes),  dotándolos de  un comportamiento  particular y
característico  según las  preferencias  del  equipo de  programadores
que  lo diseñó.  Empezando por  los estéticamente  mas valorados  como
{\bfseries Windows Maker} o {\bfseries Enlightenment}; pasando  por los que imitan a
otros sistemas  como {\bfseries AfteStep} o {\bfseries F(?)  Virtual Window Manager}
(en una de sus variantes nos proporciona el look de Windows 95); o los
que permiten ser personalizados con {\itshape temas\/} diferentes como {\bfseries Ice
Windows Manager}  o {\bfseries Sawfish}; y  terminando por los más  ligeros y
rápidos pero no menos funcionales  como {\bfseries Fast Light Window Manager}
se cubre toda una variedad de necesidades de usuario
\end{quotation}




\begin{quotation}
Ahora que disponemos de  ventanas se hace necesario rellenarlas
con algo. A  la hora de programar  una aplicación para las  X se suele
recurrir a  los {\bfseries toolkits}.  Se trata  de librerías  diseñadas para
proporcionar diferentes  tipos de  controles (e.j. botones,  barras de
menús, cuadros de  edición, etc) facilitando su  gestión. Las toolkits
crean  los  controles  allí  donde  le  digamos,  los  destruyen,  los
redibujan cuando se hace necesario,  manejan todas las acciones que se
hagan  sobre ellos  a través  del uso  de alguno  de los  dispositivos
de  entrada posible,  etc.  Trabajar  sin hacer  uso  de las  toolkits
implicaría diseñar y gestionar nuestros propios controles.
\end{quotation}


\begin{quotation}
Es importante destacar  que una aplicación X  funciona sea cual
sea el  gestor de ventanas  seleccionado. Por tanto,  el uso de  uno u
otro es  una elección  personal del  usuario. Sin  embargo, el  uso de
un  toolkit  u otro  en  una  aplicación  es  elección del  equipo  de
programadores que ha  trabajado en ella. Eso unido a  la gran variedad
de toolkits  existente en  Linux convierte  nuestro escritorio  en una
selva donde podemos ver aplicaciones con interfaces gráficas de lo más
variopinto.
\end{quotation}


\begin{quotation}
Para  garantizar que  las aplicaciones  presenten una  interfaz
similar,  reduciendo el  tiempo de  aprendizaje de  los usuarios,  han
aparecido  los {\bfseries entornos  de escritorio}.  Básicamente se  trata de
establecer una serie de reglas  comunes que suelen incluir: el toolkit
a  utilizar,  el  formato  de  la ayuda,  el  modelo  de  componentes,
librerías de tratamiento  de imágenes y sonido, etc.  Todo ello genera
un marco de  trabajo tanto para los desarrolladores de  nuevas como de
viejas aplicaciones. Si  lo desarrolladores se ciñen a  dicho marco el
resultado es un entorno de trabajo  uniforme y cómodo donde no existen
diferencias  sustanciales en  la interfaz  de una  aplicación a  otra.
\end{quotation}


\begin{quotation}
Afortunadamente   la   variedad   es  una   característica   de
Linux.  En  la  actualidad  disponemos  de  dos  grandes  entornos  de
escritorio:
\end{quotation}


\begin{description}


\item[GNOME] \mbox{}

Funciona  sobre  el  toolkit   GTK  que  fue  originalmente
diseñado para GIMP.



\item[KDE] \mbox{}

Funciona  sobre  el toolkit  Qt  y  es probablemente  el  que
dispone de la interfaz más atractiva de los dos.



\end{description}


\begin{quotation}
Cada uno tiene sus más y sus menos pero la gran realidad es que
presentan una interfaz muy intuitiva que se aprende a manejar desde el
primer momento.
\end{quotation}





\subsection{Consejos y trucos}

\begin{quotation}
Debido a  la sencillez de  los entornos de  escritorio, resulta
absurdo  e inútil  intentar  explicar  su manejo.  La  mejor forma  de
aprender  es sentarse  delante  de uno  de ellos,  ser  un poco  osado
probando  cosas y,  ante  todo,  dejar que  nos  guíe procurando  leer
detenidamente los mensajes del sistema.
\end{quotation}


\begin{quotation}
Sin embargo si resulta interesante seguir algunos conseguir que
nos pueden sacar de un apuro en más de una ocasión:
\end{quotation}


\begin{itemize}
\item Mientras que en algunos sistemas Linux el usuario se autentifica
sobre las  X. En  otros es  posible que al  terminar el  arranque sólo
dispongamos de  una consola en  la que autentificarnos. En  esos casos
la  forma  de  iniciar  las  X es  ejecutar  el  comando  {\ttfamily startx}.
Evidentemente al  terminar nuestro  trabajo en  ellas volveremos  a la
consola.
\item Si  estamos  en  las  X  es posible  cambiar  a  alguno  de  los
terminales  de la  consola,  he incluso  cambiar  a otro  {\ttfamily display}
de  las  X  si  estuviera  disponible.  Para  ello  basta  con  pulsar
{\ttfamily Ctrl+Alt+F?},  donde   cada  tecla  de  función   es  un  terminal
diferente. Estando en  la consola volver a las X  es tan sencillo como
cambiar  al  terminal  ({\ttfamily Alt+F?})  asociado al  display  X  al  que
queremos ir (normalmente sólo hay uno pero pueden haber varios).
\item Sólo cuando veamos un mensaje del tipo {\ttfamily Kernel Panic} podemos
decir que nuestro Linux se ha  colgado. En cualquier otro caso estamos
frente a sencillos cuelgues de las aplicaciones con las que trabajamos
y Linux  proporciona los  suficientes recursos  como para  que podamos
recuperar  el control  de la  máquina. Por  ejemplo: el  cambiar a  un
terminal diferente de la consola nos permite matar aplicaciones que se
han  quedado  colgadas  impidiendo  nuestro  trabajo.  En  situaciones
críticas puede  ser necesario terminar  con las X de  forma prematura.
Para ello se pulsa la  secuencia {\ttfamily Ctrl+Alt+Backspace} que cierra el
servidor X  abortando todas  las aplicaciones  gráficas. Evidentemente
los datos no guardados se perderán.
\item En Linux existen muchos emuladores de terminal. Dichos programas
permiten ejecutar aplicaciones  de modo consola dentro  de una ventana
X.  El más  básico  es  el {\ttfamily xterm}  que  viene  con la  instalación
estándar de  las X,  pero existen  muchos otros  y cada  entorno suele
venir con uno propio. En  ocasiones es posible que intentemos ejecutar
una aplicación que nunca llega a mostrar su ventana principal o que da
algún tipo de  error grave. En esos casos es  recomendable ejecutar el
programa desde  el emulador de  terminal. Como ya hemos  comentado las
aplicaciones para X no son diferentes de otras aplicaciones por lo que
suelen mostrar  información por la  consola, si esta  está disponible.
Esa información puede ser vital para resolver nuestro problema.
\item Cuando ejecutamos una aplicación X desde el emulador de terminal
vemos que  este se queda  bloqueado a la  espera de que  la aplicación
termine. Es  el mismo comportamiento  que tiene cuando  ejecutamos una
aplicación  de consola,  sólo que  nos  llama más  la atención  porque
estamos  acostumbrados a  que  en  Microsoft\texttrademark{} Windows\texttrademark{}  la
aplicación gráfica se ejecute  independientemente. Para que eso suceda
debemos añadir un {\ttfamily \&} al final de la línea de comandos o pulsar
{\ttfamily Ctrl+Z} y ejecutar el comando {\ttfamily bg} sobre el emulador después de
que la aplicación haya sido iniciada.
\item En general  el mostrar  el clásico aviso  de que  una aplicación
tiene archivos modificados y va a ser cerrada es responsabilidad de la
aplicación. El  cierre de  la ventana principal  por la  pulsación del
correspondiente botón en  la barra de título es  notificado al proceso
propietario de la ventana. Normalmente  se suele mostrar dicho mensaje
y una vez aceptado se termina el  proceso. Por una lado es posible que
nuestra aplicación no disponga de  esa característica. Por ejemplo: si
cerramos el  emulador de terminal  cuando estamos ejecutando  sobre él
cualquier tipo de aplicación (sea de  consola o de X) dicha aplicación
termina  inmediatamente perdiéndose  los  datos que  no hubieran  sido
guardados. Por otro lado es posible que le proceso esté bloqueado y no
reciba el mensaje.  En ese caso la  ventana no se cerrará  a menos que
forcemos  su destrucción  con la  opción correspondiente.  Entonces el
gestor de ventanas la cerrará  pero la aplicación seguirá ejecutándose
en segundo plano aunque para nosotros  ya no exista. La única solución
será matarla a mano con el comando correspondiente.
\item A la hora  de aprender a usar  las X no basta con  jugar con los
botones  izquierdo y  derecho  de nuestro  ratón. En  las  X el  botón
central es de gran importancia suele disponer de funciones adicionales
que no  están presentes en  los otros  dos. En entornos  de escritorio
como KDE o GNOME esto suele  implicar un menú de contexto adicional al
que se  muestra usando  el botón derecho;  pero en  otras aplicaciones
podemos  encontrar formas  de manejo  de lo  más curiosas.  Tal es  su
importancia que en caso de no disponer de él se emula por la pulsación
simultanea de ambos botones.
\item Una aplicación  curiosa del botón  central es su uso  para pegar
texto entre  aplicaciones sea cual sea  la toolkit bajo las  que hayan
sido desarrolladas. Basta con marcar nuestro texto en la aplicación de
origen para que  al pulsar el botón  central en la de  destino este se
pegue a continuación de la posición actual del cursor.
\end{itemize}





\section{Usando Internet con GNU/Linux
    }


\subsection{Navegadores web
      }


\subsubsection{Netscape Communicator 4 }

\begin{quotation}
Durante algunos años, Netscape ha sido el único navegador
multiplataforma real, dando cobertura a muchos de los
distintos Unix comerciales existentes.
Casi desde que Linux tiene interfaz gráfico, ha existido una
versión del navegador Netscape para este sistema operativo.
\end{quotation}


\begin{quotation}
{\itshape Netscape Communicator 4\/} proporciona soporte para
navegación de páginas web con JavaScript y Flash 5, 
permite visualizar documentos PDF dentro del navegador 
(mediante un plugin para el {\itshape Adobe Acrobat Reader\/}).
También nos permite gestionar el correo electrónico y
componer páginas web.
\end{quotation}


\begin{quotation}
Los Linuxeros siempre hemos considerado que el navegador
Netscape consumía demasiados recursos en Linux, además de
tener bastantes problemas de estabilidad.
Debido a este, y a otros factores importantes, como fueron la
forma de competir con las casa MicroSoft, Netscape llegó a la
sana conclusión de que la mejor manera de mantener su
navegador en el mercado, era liberando su código fuente. Así
nació {\bfseries Mozilla}
\end{quotation}


\begin{quotation}
Como debe ser, dentro de la comunidad del Software Libre, se
alzaron voces en contra de ese desperdicio de recursos,
proponiendo la creación de navegadores alternativos.
Aquí listamos algunas de las alternativas que podemos encontrar
en el área de los navegadores web dentro del Software Libre:
\begin{itemize}
\item {\bfseries chimera2} - Navegador web para las X
\item {\bfseries communicator} - Netscape Communicator 4.77
\item {\bfseries dillo} - Navegador web basado en las GTK
\item {\bfseries encompass} - Un navegador libre para GNOME
\item {\bfseries galeon} - Navegador basado en Mozilla, con el aspecto y la apariencia de las aplicaciones GNOME
\item {\bfseries konqueror} - El gestor de ficheros, navegador web y visor de documentos del KDE
\item {\bfseries links} - Navegador web en modo caracter
\item {\bfseries lynx} - Navegador web en modo caracter
\item {\bfseries mozilla} - Un navegador Open Source para las X's. Es el heredero de Netscape.
\item {\bfseries OpenOffice} - Suite ofimática que incluye un buen navegador web
\item {\bfseries w3m} - Visor web con un excelente soporte para tablas y marcos
\end{itemize}

Bueno, seguro que en el momento de leer este apartado, habrán
surgido nuevos navegadores web dentro del mundillo del
Software Libre
\end{quotation}





\subsection{Transferencia de ficheros (FTP)}

\begin{quotation}
 FTP  (File Transfer Protocol)  es un protocolo que  se utiliza
para transferir  información, almacenada  en ficheros, de  una máquina
remota a otra  local, o viceversa. Para poder  realizar esta operación
es necesario conocer la {\itshape dirección IP\/} (o el {\tt\char`\"}nombre{\tt\char`\"}) de
la máquina a la que nos  queremos conectar para realizar algún tipo de
transferencia. Es fundamental distinguir entre máquina local y máquina
remota:
\end{quotation}


\begin{description}


\item[Máquina local] \mbox{}

Es  aquella desde donde nos  conectamos para hacer
la taransferencia, es decir, donde ejecutamos ftp.



\item[Máquina  remota] \mbox{}

Es  aquella  a   la  que  nos  conectamos  para
transferir información.



\end{description}





\subsubsection{Inicio de sesión FTP}

\begin{quotation}
  Para realzar  transferencias  de ficheros  por protocolo  FTP
se  establecen  conexiones (sesiones)  entre  la  máquina local  y  la
remota. Estas sesiones comienzan por  la autentificación del usuario y
prosiguen  con las  transferencias.  Finalmente la  sesión se  cierra.
Veamos un breve ejemplo. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ftp euler
Connected to euler.fmat.ull.es.
220 ProFTPD 1.2.0pre10 Server (Debian) [euler.fmat.ull.es]
Name (euler:miguev): 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  El   servidor  nos  preguntará   un  nombre  de   usuario,  y
seguidamente la contraseña. El nombre  que daremos debe ser una cuenta
de  usuario válida  en el  servidor al  que intentamos  acceder, y  la
contraseña  lógicamente debe  ser  la de  ese  usuario. En  servidores
públicos suele existir una cuenta de  acceso anónima sólo para leer (o
tal vez una carpeta donde poner cosas pero no leer). Para acceder a un
FTP  como usuario  anónimo se  utiliza el  nombre {\itshape anonymous\/}  y se
proporciona  la  dirección  de  correo  electrónico  como  contraseña.
\end{quotation}


\begin{quotation}
 Una vez introducido el nombre  y la contraseña el servidor nos
recibirá  y  el  programa  cliente  de FTP  nos  mostrará  un  prompt,
manifestando así que  está preparado para ejecutar las  órdenes que le
demos. A  partir de aquí  se realizan las maniobras  posibles mediante
los comándos de FTP que veremos más adelante. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ftp euler
Connected to euler.fmat.ull.es.
220 ProFTPD 1.2.0pre10 Server (Debian) [euler.fmat.ull.es]
Name (euler:miguev): miguev
331 Password required for miguev.
Password:
230 User miguev logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp>
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsubsection{Comandos del FTP}

\begin{quotation}
El protocolo FTP dispone de unos comandos estándares suficientes 
para las operaciones de transferencia de ficheros, de los cuales
vemos a continuación un resumen.
\end{quotation}


\begin{description}


\item[help] \mbox{}

Proporciona una lista de los comandos del FTP de la máquina
local



\item[help   comando] \mbox{}

Proporciona   información  sobre   el   comando
especificado, correspondeinte a la máquina local



\item[lcd directorio-local] \mbox{}

Para moverse de  un directorio a otro en la
máquina local



\item[lcd unidad:] \mbox{}

Para cambiar de una  unidad de disco a  otra, en el
caso particular de que la máquina local esa un PC con Windows o MS-DOS



\item[cd directorio-remoto] \mbox{}

Para moverse de un directorio a otro en la máquina remota



\item[lls directorio-local] \mbox{}

Para listar el contenido  de un directorio
en la máquina local



\item[{[}ls$|$dir{]} directorio-remoto] \mbox{}

Para listar el contenido de un directorio en la máquina remota



\item[! comando] \mbox{}

Para ejecutar un comando en la máquina local



\item[delete fichero-remoto] \mbox{}

Para borrar un fichero en la máquina remota



\item[delete  ficheros-remotos] \mbox{}

Para  borrar  varios  ficheros  en  la
máquina remota



\item[rmdir directorio-remoto] \mbox{}

Para borrar  un directorio en la máquina
remota



\item[mkdir directorio-remoto] \mbox{}

Para crear un directorio  en la máquina
remota



\item[pwd] \mbox{}

Para  saber el directorio en  el que se está,  en la máquina
remota



\item[ascii] \mbox{}

Para hacer la transferencia  en formato ascii (lo hace por
defecto)



\item[binary] \mbox{}

Para  hacer  la  transferencia en  formato  binario,  se
utiliza el comando:



\item[get      fichero-remoto     fichero-local] \mbox{}

Transfiere     el
{\ttfamily fichero-remoto}  desde  la  máquina  remota a  la  máquina  local,
guardándolo con el nombre {\ttfamily fichero-local} en la máquina local



\item[mget lista-ficheros-remotos] \mbox{}

Transfiere los ficheros listados desde
la máquina remota a la máquina local.



\item[prompt] \mbox{}

(Des)activa el modo  interactivo de las transferencias de
ficheros múltiples.



\item[put      fichero-local     fichero-remoto] \mbox{}

Transfiere     el
{\ttfamily fichero-local}  desde  la  máquina  local  a  la  máquina  remota,
guardándolo con el nombre {\ttfamily fichero-remoto} en la máquina remota



\item[mput  lista-ficheros-locales] \mbox{}

Transfiere los  ficheros  listados
desde la máquina local a la máquina remota.



\end{description}


\begin{quotation}
 Obvimante, el comando {\ttfamily ftp} no es el único programa cliente
de  FTP disponible.  Existen multitud  de programas  clientes de  FTP,
tanto para GNU/Linux como para  otras plataformas, como p.ej. el gFTP.
\end{quotation}





\subsection{Acceso remoto (SSH)}



\begin{quotation}
  En muchas  ocaciones  resulta interesante  acceder a  una
máquina  remota  y  trabajar   sobre  ella  como  si  estubieramos
físicamente frente a su consola. Es decir, poder ejecutar comandos
en dicha  máquina sin tener  que trasladarnos a escribirlos  en su
teclado.  Este tipo  de  acceso  entraña sus  riesgo  dado que  es
necesaria la autentificación del usuario pero este no puede enviar
sin  más su  contraseña  por la  red pues  pondría  en peligro  la
seguridad  del sistema.  Además puede  resultar peligroso  que los
comandos que enviemos,  así como la salida por  pantalla de dichos
comandos, viajen por la red desprotegidos.
\end{quotation}


\begin{quotation}
 Secure  Shell (SSH) es  un programa que  resuelve nuestros
problemas puesto que encripta tanto  la información que es enviada
a la máquina  remota, como la que es envía  por esta. El resultado
es que  aunque la  comunicación pueda  ser interceptada  los datos
resultarán ininteligibles.
\end{quotation}


\begin{quotation}
  La forma  más sencilla  de utilización  es la  siguiente:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 $ ssh <usuario>@<máquina_remota> 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Por  ejemplo si el  usuario {\ttfamily miguev} quiere  acceder al
servidor {\ttfamily euler.fmat.ull.es} ejecutaría lo siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 $ ssh miguev@euler.fmat.ull.es 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 La primera vez que accedamos a una máquina el programa nos
mostrará la {\itshape huella dactilar\/} de dicha máquina y nos preguntará
si estamos seguros de que es a ella a quien queremos acceder. Esto
permite utilizar políticas de seguridad que eviten que una máquina
suplante a otra y nos engañe. Si estamos seguros y contestamos que
sí, el sistema nos pedirá la password de acceso, de la misma forma
que lo hará todas la veces que queramos acceder a ella. En caso de
ser  autentificados dispondremos  del  tan  ansiado acceso  remoto
sobre el citado sistema.
\end{quotation}


\begin{quotation}
 En caso de no especificar el nombre de usuario
({\ttfamily ssh euler.fmat.ull.es}) el programa utilizará nuestro
nombre en la máquina desde la que lo estamos ejecutando.
\end{quotation}


\begin{quotation}
 Debido a que el caracter {\ttfamily \~{}} tiene un significado
especial para el {\ttfamily ssh}, si queremos escribirlo en la máquina
remota tendremos que pulsar {\ttfamily \~{}\~{}} en nuestro teclado.
\end{quotation}


\begin{quotation}
 Aunque {\ttfamily ssh} garantiza el acceso remoto seguro
no proporciona por si sólo la transferencia segura de archivos.
Para ello se utiliza el comando {\ttfamily scp} que tiene la siguiente forma:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
      $ scp <usuario>@<máquina_origen>:<archivo_origen>
            <usuario>@<máquina_destino>:<archivo_destino>
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 El cual copia {\ttfamily archivo\_origen} desde la {\ttfamily máquina\_origen}
hasta el {\ttfamily archivo\_destino} en la {\ttfamily máquina\_destino}. Si no se
especifica alguno de los nombres de máquina, el {\ttfamily scp} asume que
estamos hablando del sistema local. El siguiente comando copia
el archivo {\ttfamily miarchivo} desde la máquina local hasta
{\ttfamily euler.fmat.ull.es}:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
      $ scp miarchivo euler.fmat.ull.es:
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Mientras que el siguiente comando hace lo contrario:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
      $ scp euler.fmat.ull.es:miarchivo .
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Correo electrónico
      }


\subsubsection{Mutt }



\begin{quotation}
 Mutt  es un programa  cliente de correo  electrónico, lo
que en  inglés se denomina  un MUA  (Mail User Agent,  agente de
correo del  usuario). Es un programa  {\tt\char`\"}de consola{\tt\char`\"}, lo
que  significa  que no  necesita  un  entorno de  ventanas  para
ejecutarse. Al igual que  otros programas basados en pulsasiones
de  teclas,  Mutt  resulta  ser  poco  intuitivo  al  principio.
Afortunadamente,  se encuentra  traducido  al  castellano y  eso
ayuda bastante. 
\end{quotation}


\begin{quotation}
 Vamos a usar mutt  para familirizarnos un poco él, verán
que es  simple. Abrimos  una ventana de  emulador de  terminal y
ejecutan el comando {\ttfamily mutt}. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
      $ mutt
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Si nos fijamos en la  primera línea de la pantalla vemos
que  aparecen listadas  una  serie de  teclas  con sus  acciones
asociadas, {\ttfamily q:Salir}, para salir, {\ttfamily d:Sup} para suprimir un
mensaje, etc. Vemos un ejemplo de  uso para hacernos una idea de
las funciones básicas. 
\end{quotation}


\begin{quotation}
 El  que se haya fijado  en las dos últimas  líneas habrá
visto que aparece lo siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
---Mutt: (ningún buzón) [Msgs:0]---(threads/date)-----------------------(all)---
/var/spool/mail/miguev: No existe el fichero o el directorio (errno = 2)
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Esto significa  que mutt  está buscando  el correo  del
usuario  en  {\ttfamily /var/spool/mail/miguev}  (en  el  caso  del
usuario miguev).  No se asusten.  Lo que  pasa es que  el correo
está en esa carpeta pero no en el terminal donde están sentados,
sino en  el servidor de  correo. Para  poder usar el  correo con
Mutt hay que entrar primero en el servidor, lo que podemos hacer
rápidamente  con  lo que  ya  sabemos  de  SSH. Entramos  en  el
servidor y ejecutamos mutt allí: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
      $ ssh euler.fmat.ull.es
      miguev@10.0.1.2's password: 
      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Una vez  dentro del servidor podemos ya  ejecutar mutt y
utilizar  el correo  directamente  desde el  servidor. Esto  que
parece  inútil  tiene  su  utilidad. Imagina  que  estás  en  un
ordenador en cualquier  lugar del mundo (con  acceso a internet)
y  quieres  leer tu  correo  en  la  facultad, pero  no  quieres
bajártelo. Utilizas un programa cliente de SSH para entrar en el
servidor  y desde  dentro usas  el  correo como  si lo  tuvieras
delante, aunque estés dentro del servidor. El mayor problema que
esto  presenta  es  la  lentitud del  protocolo  SSH  cuando  la
conexión es a través de un módem de línea telefónica. 
\end{quotation}


\begin{quotation}
 Ejecutamos el  comando {\ttfamily mutt} y vemos  en el terminal
un programa casi todas las líneas vacías, salvo la primera y las
dos últimas.  Probablemente en el  momento de abrir  mutt por
primera vez  no veamos  nada interestante,  pero aquí  tienen un
ejemplo de una lista de mensajes vista desde mutt. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
q:Salir  d:Sup.  u:Recuperar  s:Guardar  m:Nuevo  r:Responder  g:Grupo  ?:Ayuda
  43     Oct 27 Teresa Gonzalez (   0)  *>Re: [l-gulic] CILA LLENO
  44     Oct 27 Lucas Gonzalez  (   0)   >cvs
  45     Oct 27 Miguel Ángel Vi (   0) Bienvenido al calendario de la Universida
  46     Oct 28 Teresa Gonzalez (   0) Re: [l-gulic] Cambios en el CVS de CILA
  47     Oct 28 Pedro Gonzalez  (   0)  *>
  48     Oct 28 Carlos de la Cr (   0) La pu~etera introduccion :-)
  49     Oct 28 carlos de       (   0) maldito texto sobre java
  50     Oct 28 frodo@fmat.ull. (   0) MUY IMPORTANTE!!
  51     Oct 28 frodo@fmat.ull. (   0) ahora te llega?
  52     Oct 28 frodo@fmat.ull. (   0) ¡como no te llegue! ..grrr
  53     Oct 28 Administrador d (   0) Re: instala esto










---Mutt: /var/spool/mail/miguev [Msgs:53 425K]---(threads/date)---------(end)---

      
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Vamos a enviar un email a  alguien que esté con nosotros en el
aula, de esa forma cada uno  enviamos un correo y recibimos otro. Para
ello pulsamos  la tecla {\ttfamily m} y  veremos como en la  última línea nos
pregunta por el destinatario  del mensaje ({\ttfamily To:}{$>$}. Introducimos ahí
la dirección de email a la que enviaremos el mensaje: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
To: frodo@fmat.ull.es
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Seguidamante  mutt nos  preguntará por  el asunto  del mensaje
({\ttfamily Subject:}). Es importante poner un asunto al mensaje, para que el
destinatario  pueda tener  una idea  de qué  es ese  mensaje antes  de
abrirlo.  En  un  tiempo  en  que el  contagio  de  virus  por  correo
eletrónico es preocupantemente frecuente,  resulta muy molesto recibir
un mensaje de email sin asunto. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Subject: Hola pringao :-P
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Una  vez que  mutt ya  sabe el destinatario  del mensaje  y el
asunto,  ejecuta el  editor que  tengamos  definido en  el fichero  de
configuración {\ttfamily \~{}/.muttrc}. Editamos el  mensaje que queramos y
salimos del  editor {\bfseries guardando el mensaje},  importante esto último
ya que si salimos del editor  sin guardar el mensaje mutt cancelará el
envío. Una vez que salimos del  editor mutt está preparado para enviar
el mensaje, pero nos ofrece la  posibilidad de hacer aún varias cosas.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
y:Mandar  q:Abortar  t:To  c:CC  s:Subj  a:Adjuntar archivo  d:Descrip  ?:Ayuda
    From: Miguel Ángel Vilela <miguev@fmat.ull.es>
      To: frodo@fmat.ull.es
      Cc:
     Bcc:
 Subject: Hola pringao
Reply-To: Miguel Ángel Vilela <miguev@fmat.ull.es>
     Fcc:
     Mix: <no chain defined>
     PGP: En claro

-- Archivos adjuntos
- I     1 /tmp/mutt-euler-19795-2          [text/plain, 8bit, iso-8859-1, 0,1K] 








-- Mutt: Crear mensaje
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Como podemos  apreciar en el ejemplo,  tenemos varias opciones
con  sus  teclas  asociadas  en  la primera  línea.  Para  cambiar  el
destinatario  pulsaríamos  {\ttfamily t}, para  enviar  una  copia a  alguien
pulsaríamos  {\ttfamily c},  para  editar  el mensaje  de  nuevo  pulsaríamos
{\ttfamily e}, etc. Para enviar el mensaje pulsamos {\ttfamily y}. Entonces mutt nos
devolverá a  la primera pantalla,  pero mostrando en la  primera línea
información acerca del envío del mensaje. Debería aparecer
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Mensaje enviado.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 El resto del manejo  básico de {\ttfamily mutt} es bastante intuitivo
y  no   presenta  dificultades.  Si  en   cualquier  momento  deseamos
información  más  detallada  hacerca   de  las  opciones  disponibles,
pulsamos {\ttfamily ?}. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
i:Salir  -:PágAnt  <Space>:PróxPág  ?:Ayuda 
^B          M |urlview\n           call urlview to extract URLs out of a message
^D          delete-thread          suprimir todos los mensajes en este hilo
^E          edit-type              editar el tipo de archivo adjunto
^F          forget-passphrase      borrar contraseña PGP de la memoria
<Tab>       next-new               saltar al próximo mensaje nuevo
<Return>    display-message        mostrar el mensaje
^K          extract-keys           extraer claves PGP públicas 
^N          next-thread            saltar al próximo hilo
^P          previous-thread        saltar al hilo anterior
^R          read-thread            marcar el hilo actual como leído
^T          untag-pattern          quitar marca de los mensajes que coincidan   +                                  con un patrón
^U          undelete-thread        restaurar todos los mensajes del hilo
<Esc><Tab>  previous-new           saltar al mensaje nuevo anterior
<Esc>C      decode-copy            crear copia decodificada (text/plain)
<Esc>V      collapse-all           colapsar/expander todos los hilos
<Esc>b      M /~b                  search in message bodies
<Esc>c      change-folder-readonly abrir otro buzón en modo de sólo lectura
<Esc>d      delete-subthread       suprimir todos los mensajes en este subhilo
<Esc>e      resend-message         usar el mensaje actual como base para uno
+                                  nuevo
Ayuda para index                                                       -- (15%) 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsubsection{Kmail }



\begin{quotation}
 Kmail es el programa cliente de correo para KDE, fácil de usar
y a la vez muy versátil y  configurable. Dada su facilidad de manejo y
la premura  de tiempo en  el curso  actual, no entraremos  en detalles
sobre su manejo y configuración. Sólo les animaremos a que sean osados
y exploren libremente sus opciones de configuración. 
\end{quotation}







\section{Programando con GNU/Linux
    }


\subsection{C/C++ (GNU C Compiler)
      }


\subsubsection{Compilado y enlazado}

\begin{quotation}
A la hora  de generar un programa  en C se suele  pasar por dos
fases:
\end{quotation}


\begin{description}


\item[Compilar] \mbox{}

Traduce cada archivo de C {\ttfamily (*.c)} de nuestro programa
a lenguaje máquina almacenando la traducción en los archivos de código
objeto {\ttfamily (*.o)}.  Para ello  usamos el {\bfseries GCC  (GNU C  Compiler)} a
través del comando {\ttfamily gcc}



\item[Enlazar] \mbox{}

Une todos los archivos de código objeto para fundirlos en
el ejecutable de la aplicación. Se usa el comando {\ttfamily ld}.



\end{description}


\begin{quotation}
Por fortuna para nosotros {\ttfamily gcc}  llama por defecto a {\ttfamily ld}
ahorrándonos  tener que  realizar los  dos  pasos a  mano. Tomemos  el
siguiente programa:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  /* holamundo.c .- Ejemplo 1 para el CILA 2001 */

  #include <stdio.h>

  int
  main (void)
  {
    puts ("El que a buen árbol se arrima, buena sombra lo cobija.\n");
    return 0;
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Y ejecutemos el comando: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 
  $ gcc holamundo.c 
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si listásemos el contenido del directorio actual con el comando
{\ttfamily ls}  veríamos  un  nuevo  archivo con  el  nombre  de  {\ttfamily a.out}.
Ese  archivo  contiene  nuestro   programa  y  puede  ser  fácilmente
ejecutado.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ ./a.out
  El que a buen árbol se arrima, buena sombra lo cobija.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Es probable  que pocos programadores consideren  que {\ttfamily a.out}
sea un  nombre apropiado para el  ejecutable de su aplicación.  Con el
fin  de  cambiar dicho  nombre  se  puede  utilizar la  opción  {\ttfamily -o
$<$nombre\_ejecutable$>$}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -o holamundo holamundo.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Como podemos apreciar el ejecutable de nuestra aplicación ahora
se denomina {\ttfamily holamundo}.
\end{quotation}


\begin{quotation}
Una práctica muy habitual en la programación es dividir nuestro
código  en  varios  archivos,  cada  uno  especializado  en  un  tarea
determinada. Supongamos que disponemos del siguiente programa:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  /* main.c .- Ejemplo 2 para el CILA 2001 */

  #include "holafunc.h"

  int
  main (void)
  {
    holafunc ("buena sombra lo cobija");
    return 0;
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  /* holafunc.h .- Ejemplo 2 para el CILA 2001 */

  int holafunc (const char *str);
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  /* holafunc.c .- Ejemplo 2 para el CILA 2001 */

  #include <stdio.h>
  #include "holafunc.h"

  int
  holafunc (const char *str)
  {
    return printf ("El que a buen árbol se arrima, %s.\n\n", str);
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Para generar nuestro programa  sólo debemos listar los archivos
que lo forman en la línea de comandos del {\ttfamily gcc}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -o holamundo main.c holafunc.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Cuando  {\ttfamily gcc} llama  a {\ttfamily ld}  no solo  se están  enlazando
a  nuestro  programa   el  código  objeto  de  {\ttfamily main.c}   y  el  de
{\ttfamily holafunc.c}.  El compilador  sabe  que para  que nuestro  programa
funcione es  necesario que  esté enlazado a  una serie  de bibliotecas
estándar del sistema, así que las incluye automáticamente. Una de esas
bibliotecas es la {\ttfamily libc} cuya  documentación podemos obtener con el
comando:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ info libc
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Funciones  como  {\ttfamily fopen},   {\ttfamily malloc},  {\ttfamily printf}  y  en
general  todas las  del  C estándar  y  muchas más  se  definen en  la
{\ttfamily libc}. Evidentemente  en nuestro sistema existen  bibliotecas para
toda clase de  tareas cuya documentación se  puede obtener recurriendo
a  la  ayuda  del  sistema.  Sin  embargo,  la  mayor  parte  de  esas
bibliotecas no se  enlazan automáticamente, así que nos  queda la duda
de  como  resolver  este  problema.  Por  ejemplo  vamos  a  modificar
{\ttfamily holafunc.c}:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  /* holafunc3.c .- Ejemplo 3 para el CILA 2001 */
  #include <math.h>
  #include <stdio.h>
  #include "holafunc.h"

  int
  holafunc (const char *str)
  {
    float a, b;

    printf ("El que a buen árbol se arrima, %s,\n", str);

    a = 0.5;
    b = cos (a);
    return printf ("y el coseno de %f es %f.\n\n", a, b);
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si  generamos {\ttfamily holamundo}  veremos el  siguiente mensaje  de
error:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -o holamundo main.c holafunc3.c
  /tmp/ccKSzM6q.o: In function `holafunc':
  /tmp/ccKSzM6q.o(.text+0x30): undefined reference to `cos'
  collect2: ld returned 1 exit status
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Ese mensaje nos indica que  la función {\ttfamily cos()} llamada desde
{\ttfamily holafunc()}  no  está definida  puesto  que  se encuentra  en  una
biblioteca que no está siendo enlazada al programa. Para resolverlo se
emplea la opción {\ttfamily -l$<$nombre\_biblioteca$>$} con la que se indica
la biblioteca adicional que debe ser enlaza al programa.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -lm -o holamundo main.c holafunc3.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija,
  y el coseno de 0.500000 es 0.877583.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Al especificar {\ttfamily -lm} se enlaza la biblioteca {\ttfamily libm} (como
vemos no hace falta poner el {\ttfamily lib} cuando se indica el nombre de la
biblioteca)  que contiene  la defunción  de {\ttfamily cos()}.  Es importante
destacar  que  el  enlazador  sólo  busca  bibliotecas  en  una  serie
de  directorios estándar  de  nuestro sistema.  Por ejemplo  {\ttfamily libm}
se  encuentra en  {\ttfamily /usr/lib/}  que es  un directorio  estándar.
Si  deseamos  enlazar  bibliotecas   situadas  en  otros  directorios,
como  por  ejemplo  el  directorio  actual,  debemos  usar  la  opción
{\ttfamily -L$<$ruta\_biblioteca$>$}.  Por  ejemplo   el  siguiente  comando
enlaza a nuestro programa una  biblioteca de nombre {\ttfamily libpropia} que
se encuentra en el directorio actual:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -L. -lm -lpropia -o holamundo main.c holafunc3.c
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
En  caso  de  que  prefiramos  utilizar  el  enlazador  {\ttfamily ld}
directamente se utiliza la opción  {\ttfamily -c} con el compilador {\ttfamily gcc}.
De esa manera le informamos de  que sólo queremos que genere el código
objeto. Probemos a generar el código objeto para cada archivo:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -c main.c
  $ gcc -c holafunc3.c
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Ahora  tenemos  dos  nuevos  archivos  denominados  {\ttfamily main.o}
y  {\ttfamily holafunc3.o}  que  se  corresponden  con  el  código  objeto  de
{\ttfamily main.c} y  {\ttfamily holafunc3.c} respectivamente.  La parte  positiva de
esto es que ahora podemos  enlazar en nuestra aplicación código objeto
generado  por  otros lenguajes  como  {\ttfamily Fortran}  o {\ttfamily Pascal}.  El
lado  complicado  es que  debemos  indicarle  a  mano al  {\ttfamily ld}  que
enlace  a  nuestro  programa  las bibliotecas  estándar  del  sistema,
puesto  que él  no  lo  hace automáticamente.  Dado  que  se trata  de
un  aspecto  avanzado  del  uso   del  compilador  nos  quedaremos  en
saber  que si  generamos  la  primera aplicación  de  ejemplo de  este
capítulo,  o cualquier  otra  aplicación  sencilla, añadiendo  {\ttfamily -v}
a  la  línea  de  comandos  del {\ttfamily gcc}  dispondremos,  al  final  de
la  salida por  pantalla  del  programa, de  la  lista de  bibliotecas
estándar. En cualquier caso el proceso está perfectamente explicado en
{\ttfamily http://www.chiralcomp.com/support/mixing\_f77\_c\_cpp/}. 
\end{quotation}


\begin{quotation}
Otro  uso  interesante  del  {\ttfamily ld} es  para  generar  nuestras
propias bibliotecas  de enlace  dinámico. Ahora  que disponemos  de un
archivo {\ttfamily holafunc.o} ejecutemos lo siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ ld -shared -lm -o libholafunc.so holafunc3.o
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si listamos  el contenido del directorio  observaremos un nuevo
archivo  denominado {\ttfamily libholafunc.so}  que  es  nuestra librería  de
enlace  dinámico. Dicha  biblioteca puede  se utilizada  por cualquier
aplicación del sistema si la enlazamos como hemos aprendido.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gcc -L. -lholafunc -o holamundo main.c
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
A  diferencia  de  ejemplos  anteriores,  nuestro  programa  no
funcionará  si  no  disponemos  de  {\ttfamily libholafunc.so}.  Sin  embargo
cualquier  programa futuro  podrá  utilizar las  funciones de  nuestra
biblioteca. El  inconveniente de crear bibliotecas  de enlace dinámico
es que hay que instalarlas en  algún directorio donde {\ttfamily ld} sepa que
hay bibliotecas (p.ej. {\ttfamily /usr/lib}), pero la labor de instalar o
desinstalar  bibliotecas en  el  sistema, así  como  la de  configurar
{\ttfamily ld} para que las busque es  del Sr. root. Por ello si ejecutáramos
ahora nuestro programa,  este no funcionaría puesto  que sería incapaz
de encontrar  {\ttfamily libholafunc.so}. Para  que esto  no sea  así debemos
definir la variable de entorno \$LD\_LIBRARY\_PATH con la ruta de nuestra
biblioteca.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ export LD_LIBRARY_PATH=./
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija,
  y el coseno de 0.500000 es 0.877583.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsubsection{Introducción al Make}

\begin{quotation}
Es evidente que  utilizar la línea de  comandos resulta molesto
incluso cuando  se dispone  de unos pocos  archivos de  código fuente.
Para ayudar en  dichas tareas se utiliza el comando  {\ttfamily make}. Con el
objetivo  de que  funcione  es  necesario disponer  de  un archivo  de
nombre {\ttfamily Makefile}  en el  directorio de  nuestro código  fuente. El
archivo  debe  contener  reglas  que le  indiquen  al  {\ttfamily make}  como
generar  la  aplicación. Un  ejemplo  de  {\ttfamily Makefile} puede  ser  el
siguiente:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  # Makefile .- Ejemplo para el CILA 2001.

  CC = gcc
  CFLAGS = -g -Wall
  LFLAGS = -lm

  OBJECTS = main.o holafunc3.o
  INCLUDES = holafunc.h

  holamundo: $(OBJECTS)
        $(CC) $(LFLAGS) -o $@ $^

  $(OBJECTS): %.o : %.c $(INCLUDES)
        $(CC) -c $(CFLAGS) -o $@ $<
        
  clean:
        rm -f *~ $(OBJECTS)

  clean_all: clean
        rm -f holamundo
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Las  primeras líneas  se  utilizan para  definir variables  que
serán  utilizadas  en  el  resto de  nuestro  programa.  Por  ejemplo,
definimos en {\ttfamily CC}  el compilador a utilizar, es  decir el {\ttfamily gcc},
mientras que  las variables {\ttfamily CFLAGS} y  {\ttfamily LFLAGS} especifican las
opciones para el compilador y el enlazador respectivamente. En nuestro
caso indicamos con  {\ttfamily -lm} que queremos enlazar  la biblioteca libm,
con  {\ttfamily -g}  que deseamos  incluir  el  código  de depuración  en  el
ejecutable de nuestro programa y con {\ttfamily -Wall} que el compilador debe
avisarnos a la más mínima sospecha de un posible error en el programa.
Por  último  se listan  en  {\ttfamily OBJECTS}  el  nombre de  los  archivos
de  código objeto  {\ttfamily (*.o)}  que formarán  nuestra  aplicación y  en
{\ttfamily INCLUDE}  los includes  {\ttfamily (*.h)} de  nuestro código  fuente. Las
siguientes líneas  del {\ttfamily Makefile}  especifican los  {\itshape targets\/} u
objetivos de la ejecución del {\ttfamily make}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  holamundo: $(OBJECTS)
        $(CC) $(LFLAGS) -o $@ $^
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Indica que  el programa  {\ttfamily holamundo} depende de  disponer de
los  archivos de  código objeto  listados en  {\ttfamily OBJECTS} y  que para
generarlo debemos enlazarlos con el programa especificado en {\ttfamily CC} y
con las opciones de {\ttfamily LFLAGS}. Para generar {\ttfamily holamundo} basta con
ejecutar: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ make holamundo
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Puesto que {\ttfamily holamundo} es el primer target del {\ttfamily Makefile}
también  es el  target por  defecto. Así  que se  obtienen los  mismos
resultados si ejecutamos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ make
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Aunque ya  hemos especificado la dependencia  de {\ttfamily holamundo}
respecto de  los archivos de  código objeto se hace  necesario indicar
como  se obtienen  dichos  archivos. El  siguiente  target indica  ese
proceso.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $(OBJECTS): %.o : %.c $(INCLUDES)
        $(CC) -c $(CFLAGS) -o $@ $<
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
El último target permite  borrar todos los archivos intermedios
presentes  en el  directorio. Eso  incluye  a los  archivos de  código
objeto, que  una vez creada  la aplicación  ya no tiene  utilidad, así
como los archivos temporales que dejan algunos editores. Se ejecuta de
la siguiente manera:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 $ make clean 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
También podemos borrar todos los archivos generados por nuestro
{\ttfamily Makefile}, incluida la aplicación.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 $ make clean_all 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Evidentemente  este {\ttfamily Makefile}  puede extenderse  con nuevos
targets que  se encarguen  de generar la  documentación de  ayuda, que
generen bibliotecas  de enlace dinámico  con las funciones de  uso más
frecuente,  que  generen otros  ejecutables  que  formen parte  de  la
aplicación e incluso que empaqueten  nuestro programa y lo dejen listo
para su instalación en cualquier sistema.
\end{quotation}





\subsubsection{Depurando la aplicación}

\begin{quotation}
Se suele decir que el 10\% del tiempo de desarrollo de un programa
se dedica a la codificación y el 90\% restante a la depuración. Al margen
de que sea cierto o no la verdad es que es de vital importancia disponer
de las herramientas adecuadas para corregir los errores del software en
un tiempo razonable.
\end{quotation}


\begin{quotation}
La  primera  recomendación  es dejar  que  {\ttfamily lclint}  analice
nuestro  código para  que busque  y notifique  cualquier inconsistencia.
Es  importante  destacar  que  dicho programa  es  mucho  más  potente
detectando posibles errores que  el analizador sintáctico del {\ttfamily gcc}
debido  a  que  el  compilador  asume  que  ya  hemos  pasado  nuestro
código por  un programa  como {\ttfamily lclint}.  Esa suposición  permite al
{\ttfamily gcc} realizar  ciertas optimizaciones que mejoran  su velocidad de
compilación.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ lclint main.c holafunc.c
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si  disponemos de  nuestro programa  perfectamente compilado  y
observamos que presenta  algún error del que no  sabemos determinar su
origen,  significa que  ha llegado  la hora  del depurador.  GNU/Linux
dispone del  GNU Debugger bajo  el comando {\ttfamily gdb}. Para  usarlo sólo
debemos ejecutarlo  especificando el nombre  del programa en  la línea
de  comandos;  y  haber  compilado  nuestro  programa  con  la  opción
{\ttfamily -g}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ gdb holamundo
  GNU gdb 19990928
  Copyright 1998 Free Software Foundation, Inc.
  GDB is free software, covered by the GNU General Public License, and you are
  welcome to change it and/or distribute copies of it under certain conditions.
  Type "show copying" to see the conditions.
  There is absolutely no warranty for GDB.  Type "show warranty" for details.
  This GDB was configured as "i686-pc-linux-gnu"...
  (gdb) 
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
En ese  momento tendremos al  {\ttfamily gdb} esperando alguno  de los
comandos de depuración. A continuación  disponemos de una lista de los
comandos más básicos. 
\end{quotation}


\begin{description}


\item[break] \mbox{}

Situa un  punto de ruptura  en la línea o  función indicada
como argumento.



\item[continue] \mbox{}

Continua  la ejecución  de un  programa que  está siendo
depurado y se encuentra detenido en un punto de ruptura.



\item[display  $<$exp$>$] \mbox{}

Muestra el  valor de  la expresión  {\ttfamily exp}
cada vez que el programa se detiene.



\item[help] \mbox{}

Lista las clases  de comandos disponibles. Si  el comando va
seguido por un nombre de clase  se listan los comandos de dicha clase.
Si va seguido  por un nombre de comando se  muestra una ayuda completa
del comando indicado.



\item[list] \mbox{}

Lista   una   línea   o    función   especificada.   Si   el
comando   va  seguido   del  nombre   de  una   función,  el   comando
muestra   dicha   función.   Si   va   seguido   de   un   número   de
línea,  muestra  esa  línea.  En   programas  de  varios  archivos  se
puede  utilizar  {\ttfamily $<$nombre\_archivo$>$:$<$nombre\_funcion$>$}  o
{\ttfamily $<$nombre\_archivo$>$:$<$numero\_línea$>$}   para   listar   los
contenidos de un  archivo particular. Si no  se especificar argumentos
se  lista desde  la última  línea mostrada;  y si  se especifican  dos
números  de línea  separados  por  una coma,  se  muestran las  líneas
comprendidas en el intervalo.



\item[next] \mbox{}

Ejecución  paso  a  paso   pero  ignorando  las  llamadas  a
funciones.



\item[print $<$exp$>$] \mbox{}

Muestra el valor de la expresión {\ttfamily exp} en el
punto actual.



\item[quit] \mbox{}

Salir del {\ttfamily gdb}.



\item[run] \mbox{}

Inicia la ejecución del  programa. Los argumentos del comando
son los argumentos que se le pasan al programa.



\item[step] \mbox{}

Ejecución paso a paso incluso  de las funciones llamadas por
el programa.



\item[undisplay $<$exp$>$] \mbox{}

Deja  de mostrar  el valor de  la expresión
{\ttfamily exp} cada vez que el programa se detiene.



\end{description}


\begin{quotation}
El número  de comandos es mucho  más grande pero basta  con los
anteriores para agilizar enormemente  nuestro trabajo. Una alternativa
a  todo  esto  es  usar  el {\ttfamily ddd}  que  se  puede  considerar  como
una  interfaz  gráfica  para  el  {\ttfamily gdb}. Funciona  sobre  las  X  y
su  uso  es  semejante  a  de  los  depuradores  existentes  en  otras
plataformas.
\end{quotation}





\subsubsection{¿Y que pasa con el C++?}

\begin{quotation}
A  la hora  de compilar  código en  C++ {\ttfamily (*.C,  *.cc, *.cpp,
*.c++, *.cp,  *.cxx)} se utiliza  el comando {\ttfamily g++}.  Básicamente se
encarga de ejecutar  el {\ttfamily gcc} habilitando el C++  como lenguaje por
defecto y  añadiendo las bibliotecas  estándar del  C++ en la  fase de
enlazado. Por tanto todo lo  explicado para {\ttfamily gcc} es aplicable para
el {\ttfamily g++}. Y si no veamos el siguiente código de ejemplo:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  // main.cc .- Ejemplo 5 para el CILA 2001

  #include "saludo.h"

  int
  main (void)
  {
    saludo hola ("El que a buen árbol se arrima, buena sombra lo cobija.\n\n");
  
    hola.print ();
    return 0;
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  // saludo.h .- Ejemplo 5 para el CILA 2001

  class saludo
  {
  public:
    saludo (const char *str);
     ~saludo ();

    void print (void);

  private:
    const char *msg;
  };
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  // saludo.cc .- Ejemplo 5 para el CILA 2001

  #include <iostream.h>
  #include "saludo.h"

  saludo::saludo (const char *str):
  msg (str)
  {
  }

  saludo::~saludo ()
  {
  }

  void
  saludo::print (void)
  {
    cout << msg;
  }
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
El cual  se genera de  forma semejante  al caso de  trabajar en
leguaje C.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ g++ -o holamundo main.cc saludo.cc
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Con  todo  esto se  puede  decir  que  ya estamos  hechos  unos
{\itshape Linux Programmers\/} por lo que  sólo queda navegar un poco, escoger
el {\itshape proyecto de software libre\/} que  más nos guste, o disguste, y a
colaborar {\ttfamily :D}
\end{quotation}





\subsection{Pascal (FreePascal)}

\begin{quotation}
  El lenguaje  de programación  Pascal es  sencillo y  bastante
didáctico, por  lo que se  suele enseñar en  el primer año  de algunas
carreras técnicas como Matemáticas,  Física o Informática. Normalmente
estos  cursos  o asignaturas  de  programación  tratan de  enseñar  al
estudiante los  conceptos básicos  de la programación  de computadores
sin entrar en demasiados detalles acerca del funcionamiento interno de
los mismos. En este capítulo aprenderemos las herramientas básicas que
se encuentran  disponibles en GNU/Linux  para programar en  Pascal. El
compilador que  utilizaremos está siendo desarrollado  por el proyecto
{\bfseries Free Pascal}, que proporciona  un buen compilador de Pascal
para múltiples plataformas, entre éstas GNU/Linux, MS-DOS, MS Windows,
Amiga, MaC OS y otras.
\end{quotation}


\begin{quotation}
 Comenzaremos  escribiendo un ejemplo muy  sencillo de programa
en  Pascal,  el típico  {\tt\char`\"}Hola  Mundo{\tt\char`\"}.  En cualquier  editor
escribimos  el  siguiente   código  y  lo  guardamos   con  el  nombre
{\ttfamily HolaMundo.pas} 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
{ Ejemplo 1 de Pascal para CILA }

Program HolaMundo;

Begin
  writeln ('Hola Mundo');
End.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Para compilar un programa  escrito en Pascal con el compilador
de FreePascal  utilizamos el  comando {\ttfamily ppc386} del  siguiente modo:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ppc386 HolaMundo.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo.pas
Assembling holamundo
Linking holamundo
7 Lines compiled, 0.3 sec

$ ls
holamundo2    HolaMundo2.pas  holamundo2.o
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Como podemos  apreciar  en los  mensajes  del compilador,  él
mismo  se  encarga  de  compilar,  ensamblar  y  enlazar  el  programa
para  generar  el  fichero  ejecutable  {\ttfamily holamundo}.  Para  cambiar
el   nombre   del  ejecutable   resultante   se   utiliza  la   opción
{\ttfamily -o$<$nombredelejecutable$>$} (sin dejar  espacio entre la {\ttfamily o}
y el nombre del ejecutable.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ppc386 -oHolaMundo HolaMundo.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo.pas
Assembling HolaMundo
Linking HolaMundo
7 Lines compiled, 0.3 sec

$ ls
HolaMundo    HolaMundo2.pas  holamundo2.o
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Para ejecutar  el programa  resultante, recordar  que debemos
poner {\ttfamily ./} delante del nombre del ejecutable: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ HolaMundo
bash: HolaMundo: command not found
$ ./HolaMundo
Hola Mundo
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Veamos ahora un ejemplo del uso de las {\tt\char`\"}unidades{\tt\char`\"} en
Pascal.  El  concepto de  unidades  en  Pascal  es equivalente  al  de
librerías en C,  se trata de ficheros binarios que  obtenemos a partir
de código fuente separado y luego enlazamos con el programa principal.
Esto permite  dividir el código  de un  programa en varios  ficheros y
evita tener que compilar todo el programa cada vez que se modifica una
función. Con el  uso de unidades basta con recompilar  la unidad en la
que se modifica el código fuente y volverla a enlazar con el programa.
A diferencia del Borland Pascal,  el compilador Free Pascal utiliza la
extensión {\ttfamily ppu} (en  lugar de {\ttfamily tpu}) para  los ficheros binarios
de unidades. 
\end{quotation}


\begin{quotation}
Tenemos para este ejemplo dos ficheros de código fuente en Pascal, 
{\ttfamily HolaMundo2.pas} y {\ttfamily saludos.pas}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
{ Ejemplo 2 de Pascal para CILA }
{    Fichero: HolaMundo2.pas    }

Program HolaMundo2;
Uses
  Crt, Saludos ;
Var
  nombre : string ;
Begin
  TextColor(13) ;
  write ('¿Cómo te llamas? ') ;
  TextColor(15) ;
  readln (nombre) ;
  TextColor(14) ;
  Saluda (nombre) ;
  TextColor(7) ;
End.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
{ Ejemplo 2 de Pascal para CILA }
{    Fichero: saludos.pas       }

Unit Saludos ;

Interface

Uses Crt ;

Procedure Saluda ( mensaje : string ) ;

Implementation

Procedure Saluda ( mensaje : string ) ;
Begin
  writeln('Hola ', mensaje);
End;

Begin
End.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Cuidado  con un  detalle:  Los nombres  de  las unidades  deben
coincidir  con  el  nombre  del  fichero en  el  que  están  escritas,
i.e.  la  unidad {\ttfamily Saludos}  no  se  puede  escribir en  un  fichero
llamado  {\ttfamily Otronombre.pas}.  Además,  los  ficheros en  los  que  se
implementan las  unidades conviene que tengan  el nombre completamente
en  {\bfseries minúsculas}.  De  lo  contrario el  compilador  FreePascal  no
encontrará  la  unidad  al  compilar  un programa  que  la  use,  pero
podremos aún  compilarla manualmente. El siguiente  ejemplo ilustra la
situación:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ls
HolaMundo2.pas  saludos.pas

$ mv saludos.pas otronombre.pas

$ ls
HolaMundo2.pas  otronombre.pas

$ ppc386 otronombre.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling otro.pas
otro.pas(4,6) Error: Illegal unit name: SALUDOS
otro.pas(10,1) Fatal: There were 1 errors compiling module, stopping

$ mv otronombre.pas Saludos.pas

$ rm *.o *.ppu

$ ls
HolaMundo2.pas  Saludos.pas

$ ppc386 HolaMundo2.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
HolaMundo2.pas(6,16) Fatal: Can't find unit SALUDOS

$ ppc386 Saludos.pas 
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling Saludos.pas
Assembling saludos
18 Lines compiled, 0.0 sec

$ ppc386 HolaMundo2.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
Assembling holamundo2
Linking holamundo2
17 Lines compiled, 0.0 sec

$ ls
holamundo2    HolaMundo2.pas  Saludos.pas
holamundo2.o  saludos.o       saludos.ppu

$ ./holamundo2
¿Cómo te llamas? Pepe
Hola Pepe

$ mv Saludos.pas saludos.pas

$ rm *.o *.ppu

$ ls
HolaMundo2.pas  saludos.pas

$ ppc386 HolaMundo2.pas 
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
Assembling holamundo2
Linking holamundo2
18 Lines compiled, 0.0 sec

$ ls
holamundo2    HolaMundo2.pas  Saludos.pas
holamundo2.o  saludos.o       saludos.ppu

$ ./holamundo2
¿Cómo te llamas? Pepe
Hola Pepe
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Con esta  breve presentación  ya sabemos  lo suficiente  para
compilar prácticas en Pascal, sólo  queda aprender el lenguaje y pasar
muchas  horas  escribiendo  programas  para llegar  a  ser  auténticos
programadores ;-) 
\end{quotation}





\subsection{Fortran 77 (GNU Fortran) }

 
\begin{quotation}
El  lenguaje de programación {\ttfamily Fortran}  estaba orientado
puramente  al   cálculo  matemático,   y  sigue  siendo   un  lenguaje
importante en  entornos científicos.  Su nombre viene  de {\bfseries For}mula
{\bfseries Tran}slator,  ya que  su mayor  uso era  traducir las  fórmulas de
cálculo matemático al lenguaje de  las máquinas. Desde sus principios,
el lenguaje Fortran ha tenido una sintaxis particular, adaptada al uso
de  tarjetas  perforadas. En  la  actualidad,  Fortran se  utiliza  en
asignaturas de Cálculo en carreras técnicas como Matemáticas, Física y
algunas ingenierías. 
\end{quotation}


\begin{quotation}
  Utilizaremos   aquí  el   compilador  {\bfseries GNU   Fortran  77},
compatible  con  la  mayoría  del   lenguaje  básico  de  Fortran  77,
suficiente para las  prácticas de programación en  Fortran. Veamos una
vez más el  típico ejemplo de {\tt\char`\"}HolaMundo{\tt\char`\"}. En  el editor que
más nos guste, escribiremos el siguiente código Fortran: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
* Ejemplo 1 de Fortran 77 para CILA

      Program HolaMundo
      
      write(*.5) Hola Mundo
      
 5    format(//,2x,a,/)

      stop
      end
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Para compilar el programa  utilizamos el comando {\ttfamily g77} como
si fuera el {\ttfamily gcc}. El compilador {\ttfamily g77} también produce la salida
por defecto  en un ejecutable  llamado {\ttfamily a.out}, opción  que podemos
modificar con la opción {\ttfamily -o nombredelejecutable}. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ls
HolaMundo.for

$ g77 HolaMundo.for

$ ls
a.out  HolaMundo.for

$ g77 -o HolaMundo HolaMundo.for

$ ls
HolaMundo  HolaMundo.for

$ ./HolaMundo


  Hola Mundo
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Veamos  ahora  también   como  podemos  dividir  un  programa
en  varios  ficheros  de  código   fuente.  En  el  editor  escribimos
los   siguientes  códigos   fuente  Fortran   y  los   guardamos  como
{\ttfamily HolaMundo2.for} y {\ttfamily Saludos.for} respectivamente. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
* Ejemplo 2 de Fortran para CILA
* Fichero: HolaMundo2.for

      Program HolaMundo2
      character(10) saludo

      saludo = 'Mundo'

      call saluda (saludo)

      stop
      end
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
* Ejemplo 2 de Fortran para CILA
* Fichero: saludos.for

      Subroutine saluda(mensaje)
      character(10) mensaje

      print 5, 'Hola ', mensaje

 5    format (//,2x,a,a,/)

      return
      end
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Para  generar  ahora  el  ejecutable  utilizamos  el  comando
{\ttfamily g77}  dándole ambos  ficheros  como argumentos.  En general,  para
compilar un  programa Fortran escrito  en varios ficheros  bastará con
utilizar el comando de la forma {\ttfamily g77 -o ejecutable fichero1.for ...
ficheroN.for} 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ls
HolaMundo2.for  Saludos.for

$ g77 -o HolaMundo2 HolaMundo2.for Saludos.for

$ ls
HolaMundo2  HolaMundo2.for  Saludos.for

$ ./HolaMundo2


  Hola Mundo
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Estos  pocos  comandos  serán  suficientes  para  compilar  y
ejecutar las  prácticas de Fortran  77 que podamos necesitar,  pero no
piensen  que  es  verdad  eso  de  que  {\itshape {\tt\char`\"}Real  programers  do
Artificial Inteligence programs in Fortran{\tt\char`\"}\/} ;-)
\end{quotation}





\subsection{Java (JDK 1.3) }

\begin{quotation}
 Java  es un  lenguaje de  alto nivel  y de  propósito general.
Al  principio   fue  desarrollado  en  los   laboratorios  de  {\itshape Sun
Microsystems\/} para servir en aparatos  de electrónica de consumo, como
videoteléfonos,  set boxes  (descodificadores), o  aparatos similares,
pues pretendía hacerse un lenguaje  lo más independiente posible de la
plataforma en la que fueran a  ser ejecutados los programas hechos con
él. 
\end{quotation}


\begin{quotation}
  A  diferencia  de   otros  muchos  lenguajes  compilados,  el
compilador  de  java  no  genera  ficheros  ejecutables.  Genera  unos
ficheros  con  extensión  {\ttfamily .class} llamados  {\itshape bytecodes\/}.  Estos
ficheros posteriormente podrán ser  ejecutados mediante la {\itshape Máquina
Virtual Java\/}  (JVM en inglés),  que es  la encargada de  ejecutar los
programas de java. 
\end{quotation}


\begin{quotation}
 Esto, que  a primera vista puede parecer tedioso  e inútil, es
una gran ventaja para la portabilidad del código, pues cada plataforma
tiene su  propia Máquina Virtual Java:  Apple Mac OS tiene  una, Linux
tiene otra, Windows  otra, Amiga OS también, etc. Esto  implica que si
desarrollamos un programa en un iMac  con Linux, el amigo que tenga un
potente servidor SUN podrá ejecutar  nuestra aplicación hecha en Java,
al  igual que  nosotros podremos  utilizar el  complicado programa  de
calculo de estructuras  que otra persona ha desarrollado en  su Pc con
Windows en el trabajo. 
\end{quotation}


\begin{quotation}
 Realmente, Java no es tan bonito como lo estamos pintando. Uno
de sus principales puntos débiles es  que no es demasiado rápido, y es
bastante  caprichoso en  cuestiones de  recursos de  hardware. Ademas,
existen  dos maquinas  virtuales Java,  la de  Microsoft y  la de  SUN
Microsystems, que presentan algunas incompatibilidades. 
\end{quotation}


\begin{quotation}
 Pero  su principal  ventaja es la  impresionante portabilidad,
así como su utilidad en  campos como Internet (donde principalmente se
usa en la actualidad), en servidores web. 
\end{quotation}


\begin{quotation}
  Los  programas  java  podemos  clasificarlos  basicamente  en
tres categorias: {\itshape applets\/},  {\itshape servlets\/} y aplicaciones {\itshape stand
alone\/}. 
\end{quotation}


\begin{itemize}
\item   Los  {\itshape applets\/} son  pequeñas  aplicaciones  creadas con  el
proposito de ser incluidas en paginas web. Cuando el cliente, desde su
navegador web con  java incorporado pide esa pagina web,  el applet se
descarga  a su  ordenador donde  comienza su  ejecución. El  navegador
tiene la maquina virtual java incorporada.  Los applets son el tipo de
aplicaciones  java que  mas restricciones  de seguridad  presentan. No
pueden acceder  al sistema de  archivos local fuera del  directorio en
que  se  ejecutan,  no  pueden  abrir  ventanas  adicionales  sin  que
estas aparezcan  señalizadas con el indicativo:  {\tt\char`\"}Warning: applet
window{\tt\char`\"}, ni hacer muchas cosas que podrian ser perjudiciales para
nuestro ordenador.
\item   Las  aplicaciones  que  a  nivel  de  seguridad  permiten  mas
libertades que los applets 
\item  Los  {\itshape servlets\/} son una  especie de applets que  se ejecutan
solo en  el servidor  web cuando  uno pide una  pagina, y  que generan
dinamicamente  paginas  a  partir  de fuentes  como  bases  de  datos,
terceros programas que recopilan informacion, etcetera.
\end{itemize}


\begin{quotation}
 A nivel visual, java tiene dos grupos de controles, widgets, o
como prefiramos llamarlos  (no son otra cosa que los  campos de texto,
formularios, botones, etc.): 
\end{quotation}


\begin{itemize}
\item  El  Java AWT, (Advanced  Window Toolkit), obsoleto  y mantenido
solo por compatibilidad en versiones actuales de java.
\item   El conjunto  de  widgets {\bfseries Java  Swing},  que presenta  unos
controles mucho mas esteticos y es mucho mas flexible.
\end{itemize}


\begin{quotation}
  Ambos  conjuntos  de widgets  proporcionan  una  presentación
uniforme  independiente  de  la  plataforma en  que  sean  ejecutados.
Además,  otro  de  los  principales  atractivos  de  java  es  que  el
compilador no nos cuesta nada. Se encuentra disponible para bajarlo de
java.sun.com  para cualquiera  de las  plataformas mas  comunes en  el
mercado. 
\end{quotation}


\begin{quotation}
 Veamos cómo  se generan programas básicos en  java mediante un
ejemplo. En  un editor escribimos  el siguiente código y  lo guardamos
con el nombre de fichero {\ttfamily Prueba.java}. 
\end{quotation}




\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
// Ejemplo 1 de Java para CILA
// Fichero: HolaMundo.java

public class HolaMundo {
       public static void main(String[] argv){
              System.out.println("Hola mundo");
}
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Es de vital importancia que el nombre del fichero coincida con
lo  que  escribimos  despues  de  {\tt\char`\"}{\ttfamily public  class}{\tt\char`\"}.  Así
mismo, Java  es un lenguaje  muy exigente  en materia de  mayúsculas y
minúsculas,  como de  de espacios  y tabuladores.  Para compilar  este
programa utilizamos el siguiente comando: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ls
HolaMundo.java

$ javac HolaMundo.java

$ ls
HolaMundo.java  HolaMundo.class
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Obtendremos un fichero con extension {\ttfamily .class} que es el
{\itshape bytecode\/}, el fichero que ejecutaremos con el siguiente comando:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ java HolaMundo
Hola Mundo
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Es importante  no  poner {\tt\char`\"}{\ttfamily java  Prueba.class}{\tt\char`\"},
pues no funcionaria, devolviendo el siguiente error:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ java HolaMundo.class
Can't find class HolaMundo.class
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ java HolaMunco.class
Exception in thread "main" java.lang.NoClassDefFoundError: HolaMundo/java
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Veamos ahora un ejemplo de {\itshape applet\/}. Tecleamos el siguiente
código y lo guardamos como {\ttfamily HolaMundo2.java}. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
// Ejemplo 2 de Java para CILA
// Fichero: HolaMundo2.java

import java.applet.Applet;
import java.awt.*;

public class HolaMundo2 extends Applet {
    public Button botonUno = new Button ("Hola Mundo");
    public void init() {
    add ( botonUno );
    }
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Compilamos el applet del mismo modo que hicimos con el ejemplo
anterior: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ javac HolaMundo.java
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Con  esto  generamos  el  fichero  {\ttfamily HolaMundo2.class}  que
contiene  el applet.  Ahora necesitamos  una página  web que  carge el
applet.  Creamos  el  fichero {\ttfamily HolaMundo2.html}  con  el  siguiente
código: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
<html>
<head>
<title> Ejemplo 2 de Java para CILA </title>
</head>
<body>
<center>
<applet code="HolaMundo2.class" width="300" height="300" ></applet>
</center>
</body>
</html>
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Para  probar el applet  utilizaremos el método  que utilizaría
cualquier visitante, cargarlo  desde la página web que  hemos creado a
tal efecto. Esto lo hacemos con cualquier navegador que soporte, Java,
entre los que recomendamos Netscape. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ netscape HolaMundo2.html
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Veremos  como el applet  se ejecuta  dentro de la  página web.
Otra forma de  ejecutar un applet de Java, por  ejemplo cuando estamos
programando  y  sólo  deseamor  probarlo  pero  no  queremos  ejecutar
netscape, es el programa appletviewer que proporciona el JDK. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ appletviewer HolaMundo2.html
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Podemos apreciar  la  diferencia entre  un {\itshape applet\/},  cuya
ejecución está controlada por el navegador y se limita a la página web
desde el que es cargado, y una aplicación intependiente que se ejecuta
directamente en  la consola del  sistema sin más intermediario  que la
Máquina Virual Java. 
\end{quotation}





\subsection{Bash (Unix shell) }

\begin{quotation}
En  capítulos  anteriores  hemos  visto  algunos  aspectos  del
intérprete de comandos (shell). Como en muchos otros casos la variedad
de intérpretes de comandos existente es muy amplia. Sin embargo existe
uno que ha destacado sobre los demás,  o al menos que ha sabido ocupar
el puesto de estándar de facto en el mundo GNU/Linux. Estamos hablando
del {\ttfamily bash}  que suele ser  el intérprete de comandos  instalado por
defecto en nuestro sistema.
\end{quotation}


\begin{quotation}
En general esto no desmerece en nada las posibilidades de otros
intérpretes de  comandos como  pueden ser el  {\ttfamily tsh} o  el {\ttfamily ash}.
Todo  lo  contrario,  los  intérpretes  de  comandos  del  mundo  UNIX
presentan una  potencia sin igual,  en especial si los  comparamos con
sus equivalentes  en Microsoft\texttrademark{}  Windows\texttrademark{} (o sea  el viejo
{\ttfamily COMMAND.COM} o el nuevo {\ttfamily CMD.EXE}).  Esto es natural si tenemos
en cuenta que por la consola  de los sistemas UNIX han pasado millones
de  profesionales que  han contribuido  con sus  comentarios o  con su
esfuerzo  a  que haya  ido  ganando  en potencia  a  lo  largo de  los
años.
\end{quotation}


\begin{quotation}
En general  cada usuario  puede tener  su propio  intérprete de
comando,  pero  por sencillez,  y  puesto  que  es el  intérprete  por
defecto en muchos sistema  GNU/Linux, no centraremos exclusivamente en
el  {\ttfamily bash}. En  realidad  ya  hemos pasado  por  un capítulo  donde
aprendimos los principios básicos del  uso del intérprete de comandos,
ahora se trata  de utilizarlo para generar pequeños  programas que nos
ayuden en el trabajo diario.
\end{quotation}


\begin{quotation}
El {\ttfamily bash} no  sólo permite la ejecución  de las aplicaciones
instaladas en el  sistema; sino que proporciona una  serie de comandos
internos  así  como  estructuras   sintácticas  de  control  de  flujo
semejantes a las existentes en muchos lenguajes de programación (p.ej:
{\ttfamily for}, {\ttfamily case}, {\ttfamily while}, {\ttfamily until}).
\end{quotation}





\subsubsection{Ficheros de comandos}

\begin{quotation}
Todos  estos recursos  pueden  ser utilizados  interactivamente
introduciendo  los comandos  directamente  desde la  consola. Esto  es
práctico para realizar tareas  sencillas. Sin embargo, para desarrollar
programas  extensos o  rutinas  ampliamente utilizadas  suele ser  más
interesante  escribir  nuestro  programa  en  un  archivo  a  modo  de
{\itshape script\/}.
\end{quotation}


\begin{quotation}
En   este  último   caso  podemos   invocar  nuestro   programa
escribiendo el comandos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ bash prueba
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
De esa manera  se iniciará la ejecución de una  nueva copia del
{\ttfamily bash}  que  abrirá el  script  y  lo  ejecutará. En  los  sistemas
Linux  suele haber  un comando  llamado {\ttfamily sh}.  Dicho comando  suele
corresponderse con  el intérprete de  comandos por defecto  de nuestro
sistema.  Por lo  tanto, podemos  sustituir {\ttfamily bash}  por {\ttfamily sh}  si
estamos seguros de que el  {\ttfamily bash} es nuestro intérprete por defecto
o  de  que  nuestro  script  utiliza  comandos  estándares  entre  los
diferentes  intérpretes disponibles.  Si  queremos  garantizar que  la
interpretación de nuestro script la realice el {\ttfamily bash} es conveniente
indicarlo explícitamente en lugar  de utilizar el {\ttfamily sh}. Resumiendo,
podemos invocar nuestro programa de la siguiente manera:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ sh prueba
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
La verdad es  que resulta muchos más profesional  y sencillo si
nuestro script se  ejecuta de formar semejante a la  de cualquier otro
ejecutable.  Es  decir,  escribiendo  directamente  su  nombre  en  el
intérprete de  comandos. Para  ello sólo es  necesario que  la primera
línea de nuestro script sea así:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  #!/bin/bash
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O sustituimos {\ttfamily bash}  por {\ttfamily sh} si se  dan las condiciones
comentadas anteriormente. El  último paso es habilitar  los permisos de
ejecución y ya podemos utiliza nuestro script.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ chmod u+x mi_programa
  $ ./mi_programa
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Cada línea de nuestro archivo contiene un comando a ejecutar
por nuestro intérprete. Si deseamos poner varios comandos en una
misma línea debemos usar {\ttfamily {\tt\char`\"};{\tt\char`\"}} para separarlos. Por lo tanto
la siguiente secuencia de comandos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  who am I
  pwd
  date
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Es equivalente a:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  who am I; pwd; date
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
A la hora  de mostrar texto por pantalla se  utiliza el comando
{\ttfamily echo}. Veamos el siguiente script:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#!/bin/sh
# whoami .- Ejemplo 1 para el CILA 2001.
 
echo Usted es:
who am I
echo Su directorio actual es:
pwd
echo La fecha de hoy:
date
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Varios  son  los  elementos  nuevos que  podemos  ver  en  este
programa, a parte del uso del {\ttfamily echo}:
\end{quotation}


\begin{enumerate}
\item Cuando  el  intérprete  encuentra  un {\ttfamily "\#"}  ignora  todo  el
contenido de la línea a partir de ese punto.
\item El  comando  {\ttfamily who}  muestra información  sobre  los  usuarios
autentificados en el sistema. Al añadir las opciones {\ttfamily am I} estamos
indicando  que  queremos  que  sólo muestre  información  referente  a
nosotros como usuarios.
\item El comando {\ttfamily pwd} informa del directorio actual de trabajo.
\item El  comando  {\ttfamily date}  muestra  la fecha  y  hora  actual  del
sistema.
\end{enumerate}


\begin{quotation}
En este  punto es  importante recordar que  todo lo  que veamos
aquí se cumple  tanto cuando trabajamos con ficheros  de comandos como
cuando trabajamos interactivamente desde la consola.
\end{quotation}


\begin{quotation}
Existen una serie de variables predefinidas que contienen información
sobre la línea de comandos que se le ha pasado a nuestro script:
\end{quotation}


\begin{table}[hbtp]
\begin{center}
\begin{tabular}{lll}
Variable & Contenido\\ 
{\ttfamily \$0} & Nombre del fichero de comandos\\ 
{\ttfamily \$1-\$9} & Argumentos del 1º al 9º. El primero es \$1, el segundo \$2...\\ 
{\ttfamily \$*} & Línea de comandos completa exceptuando \$0\\ 
\end{tabular}
\end{center}
\caption{Variables de la línea de comandos.}
\end{table}


\begin{quotation}
Veamos un ejemplo sencillo de lo anterior:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#!/bin/sh
# yorecuerdo .- Ejemplo 2 para el CILA 2001.

echo El comando es $0
echo El primer argumento es $1
echo El tercer argumento es $3
echo Todos los argumentos son $*
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Al ejecutarlo obtenemos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ./yorecuerdo A B C
El comando es ./yorecuerdo
El primer argumento es A
El tercer argumento es C
Todos los argumentos son A B C
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsubsection{Variables de entorno}

\begin{quotation}
El intérprete  de comandos  permite la definición  de variables
que  puedan  ser  utilizadas  en  nuestros  script.  Algunas  de  esas
variables tienen  un significado  particular en nuestro  sistema. Para
conocer  las variables  actualmente  definidas  utilizamos el  comando
{\ttfamily set}.
\end{quotation}


\begin{quotation}
Si lo usásemos seguramente  veríamos variables como {\ttfamily \$HOME},
que define nuestro directorio personal de usuario (la ruta ~/ tiene el
mismo significado), o {\ttfamily \$PATH}, que contiene la lista de directorios
por donde el  intérprete buscará los ejecutables  cuando le indiquemos
el nombre de alguno.
\end{quotation}


\begin{quotation}
Definir  nuevas  variables es  tan  sencillo  como realizar  una
asignación:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ EDAD=65;
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Mientras que acceder  a su valor se hace  precediendo al nombre
de la variable con el caracter {\ttfamily \$}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
 $ echo Mi edad es $EDAD 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Toda variable definida en un {\ttfamily bash} es local a esa copia del
{\ttfamily bash} y por tanto invisible para el resto. Si tenemos en cuenta que
cada  vez que  ejecutamos  un  script se  inicia  un {\ttfamily bash}  nuevo,
resulta evidente que todas las  variables definidas en el script serán
destruidas  cuando este  termine.  Además si  un  script ejecuta  otro
script, padre  e hijo no pueden  ver las variables del  otro. Para que
esté garantizado que una variable  pueda ser vista fuera del {\ttfamily bash}
donde fue definida es necesario exportarla. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ EDAD=65
$ export EDAD
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
A continuación vamos a añadir una nueva ruta al {\ttfamily \$PATH}:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ PATH=$HOME/bin:$PATH
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O a modificar nuestro prompt:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ PS1='Le obedezco amo: '
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Como  vemos hemos  puesto la  frase  entre comillas.  Si no  lo
hubiéramos hecho así obtendríamos un  error. Esto nos lleva a intentar
conocer algunos  caracteres que en  el entono del {\ttfamily bash}  tienen un
significado especial.
\end{quotation}





\subsubsection{Metacaracteres}

\begin{quotation}
Para nuestro intérprete de comandos algunos caracteres tienen un
significado especial:
\end{quotation}





\paragraph{Sustitución: {\ttfamily * ?}}

\begin{quotation}
El primero puede ser sustituido por un numero indeterminado
de cualquier combinación de caracteres. El segundo sólo representa
a {\bfseries un} caracter cualquiera. Se explican por si mismos si vemos el
siguiente código de ejemplo en el que se listan todos lo archivos
del directorio actual:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo Ingrese un *
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O todos los que empiecen por {\ttfamily a} y terminen por {\ttfamily b}:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo Ingrese un a*b
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O sencillamente todos los que empiecen por {\ttfamily a} y terminen
por {\ttfamily b} pero que sólo tengan tres letras:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo Ingrese un a?b
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\paragraph{Redirección: {\ttfamily $>$ $>$$>$ $<$ $|$}}

  
\begin{quotation}
Podemos volcar  la  salida  de un  comando  a un  archivo,
borrándolo y creándolo de nuevo si éste existe.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ ls > lista_archivos
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O bien si preferimos añadir la salida del comando a un fichero ya existente,
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ls -al >> lista_archivos
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Pasar dicha salida como entrada a otro comando:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ ls | less
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
O usar como entrada de un comando el contenido de un archivo:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ less < miarchivo
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\paragraph{Ejecutar en segundo plano: {\ttfamily \&}}

\begin{quotation}
Si al final de un comando añadimos \& este se ejecutará en
segundo plano. Es decir, el {\ttfamily bash} no esperará a que el comando
termine, permitiéndonos seguir ejecutando nuevos comandos mientras
este se ejecuta en paralelo. Evidentemente resulta muy práctico
cuando suponemos que un comando va ha llevar un tiempo de
de ejecución prolongado y nosotros deseamos poder seguir
utilizando el sistema.
\end{quotation}





\paragraph{Separado de comando: {\ttfamily ;}}

\begin{quotation}
Como ya hemos visto, permite indicar varios comandos en una
misma línea.
\end{quotation}





\paragraph{Continuación de línea}

\begin{quotation}
Permite dividir una línea en varias si por algún motivo no podemos
escribirla de una sola vez.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo Quiero vivir en \
  > canarias
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\paragraph{Valor de una variable: {\ttfamily \$}}

\begin{quotation}
Como ya hemos visto, precede al nombre de una variable para
que el intérprete sepa que debe sustituir su valor.
\end{quotation}





\paragraph{Otros: {\ttfamily [ ] `}}

 
\begin{quotation}
La segunda ejecuta el comando entre las comillas invertidas
(tildes  francesas) y  sustituye  la  cadena por  la  salida de  dicho
comando. Por ejemplo, si ejecutamos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo date
  date
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Pero si ejecutamos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo `date`
  mar oct 30 23:51:08 WET 2001
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Si  deseamos escribir  estos  metacaracteres  de forma  literal deben ir
precedidos de {\ttfamily $\backslash$}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo \* \\ \[
  * \ [
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
También podemos  evitar la sustitución si  los escribimos entre
comillas simples o dobles:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ echo "Enviar $100?"
  Enviar $100?

  $ echo "`minombre` es dulce"
  `minombre` es dulce
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
La diferencia  entre las comillas  simples y las dobles  es que
las  segunda  eliminan todas  las  sustituciones  excepto las  de  los
metacaracteres {\ttfamily \$} y {\ttfamily `}.
\end{quotation}





\subsubsection{Ficheros de comandos interactivos}

\begin{quotation}
A parte  de ejecutar  una secuencia predeterminada  de comandos
nuestros scripts  pueden ser interactivos.  Es decir solicitar  y leer
datos desde  la consola de  usuario. Para  ello se utiliza  el comando
{\ttfamily read} seguido por uno o más nombre de variables.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  $ read NAME1 NAME2 NAME3
  $ echo $NAME1
  $ echo $NAME2
  $ echo $NAME3
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
El  comando  {\ttfamily read}  lee  desde la  entrada  estándar  hasta
encontrar  un espacio  y  almacena  lo leído  en  la primera  variable
indicada. A  continuación sigue leyendo  hasta el siguiente  espacio y
almacena la nueva  lectura en la segunda  variable. Así sucesivamente,
excepto que la última variable  siempre almacena desde el último punto
guardado en la variable anterior hasta el final de la línea. 
\end{quotation}





\subsubsection{Control de flujo del programa}

\begin{quotation}
Al  igual  que  en  muchos  otros  lenguajes  de  programación,
disponemos de  sentencias de  control de  flujo del  programa. Algunos
ejemplos son: 
\end{quotation}


\begin{description}
\item[{\ttfamily if}] \mbox{}

{\ttfamily if $<$comando$>$; then $<$comando$>$;
[ elif $<$comando$>$; then $<$comando$>$; ] ...
[ else $<$comando$>$; ] fi}

\item[{\ttfamily while}] \mbox{}

{\ttfamily while $<$comando$>$; do $<$comando$>$;
done}

\item[{\ttfamily until}] \mbox{}

{\ttfamily until $<$comando$>$; do $<$comando$>$;
done}

\end{description}


\begin{quotation}
La verificación  de la condición  para determinar el  flujo del
programa se realiza sobre el código de error devuelto por cada comando
o aplicación. Para  conocer las condiciones en las que  se devuelve un
código de  error u otro se  hace necesario consultar la  ayuda de cada
comando en particular.
\end{quotation}


\begin{quotation}
Otras  sentencias son  {\ttfamily case}  {\ttfamily select}  y {\ttfamily for}.  Una
forma interesante de esta última es:
\end{quotation}


{\ttfamily for $<$variable$>$ in $<$lista$>$; do comando; done}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  for a in pato gallo perro
  do
    echo yo tenía un $a
  done
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Este ejemplo puede parecer inútil pero es el paso previo a:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  for a in *
  do
    cat $a
  done
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
El  cual  muestra   en  la  consola  todos   los  archivos  del
directorio. Otra de las característica  del lenguaje es la posibilidad
de crear funciones cuyo valor de retorno es el mismo que el del último
comando ejecutado:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  function mifunc ()
  {
    echo La fecha de hoy:
    date
  }

  echo Veamos que hace esta función...
  mifunc
  
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
En general el  {\ttfamily bash} es un programa  demasiado potente como
para poder  ser explicado en  unas pocas líneas. Probablemente  con lo
que  hemos  comentado  sea  posible  crear  nuestros  pequeños  script
para  automatizar algunas  tareas  tediosas, pero  en  caso de  querer
profundizar más lo mejor es recurrir  a la propia ayuda del intérprete
({\ttfamily man bash}). Un tema interesante a consulta es sobre el uso de los
archivos  {\ttfamily .bash\_profile}  y  {\ttfamily .bashrc}  de  nuestro  directorio
personal, y sobre como usarlos para personalizar la consola.
\end{quotation}





\section{Matemáticas en GNU/Linux
    }


\subsection{Documentos y fórmulas matemáticas
      }


\subsubsection{{\LaTeX} }

\begin{quotation}
 {\TeX}  (pronunciado  {\tt\char`\"}Tek{\tt\char`\"})  es el  más
potente procesador de {\ttfamily textos} orientados a documentos científicos,
aunque puede ser  usado para cualquier tipo de documento.  {\LaTeX} es un
lenguaje estructurado para la elaboración de documentos, desde apuntes
(quedan muy  bien) hasta libros completos,  problemas, boletines, etc.
Una de las  principales diferencias entre {\LaTeX} y  los procesadores de
texto al uso es que a diferencia  de estos últimos {\LaTeX} no cuenta con
una interface WYSWYG, sino que por el contrario, un domumento en {\LaTeX}
ha de ser escrito en forma de fichero fuente para luego ser compilado.
Esto se  puede interpretar de dos  maneras, o un gran  inconveniente o
una gran ventaja. 
\end{quotation}


\begin{quotation}
 La  primera versión  de {\TeX},  obra de  Donald E.  Knuth (DEK),
nació a  principios de  los años  ochenta. Esta  versión, si  bien muy
potente, era extremadamente  dificil de usar, por lo que  el mismo DEK
desarrolló la primera ampliación de {\TeX}, el plain {\TeX}. 
\end{quotation}


\begin{quotation}
 El Plain {\TeX} introducía gran  número de órdenes de alto nivel,
pero seguía  estando más  orientado a aspectos  tipográficos que  a la
estructura de  los documentos como un  todo Por ello, en  1985, Leslie
Lamport  desarrolló un  lenguaje  construido sobre  el  Plain {\TeX}  que
recibió  el  nombre  de  {\LaTeX}  dirigidos  a  confeccionar  documentos
completos (artículos o libros). Desde  su aparición, {\LaTeX} ha conocido
una  gran  difusión  en  el  ámbito  científico,  siendo  hoy  día  el
procesador  más  usado  por  matemáticos, físicos  y  gran  número  de
ingenieros. 
\end{quotation}




\begin{quotation}
 El futuro  del {\LaTeX} depende no sólo de  si mismo sino también
de  los avances  en  otros procesadores,  en la  medida  en que  estos
incorporen  las herramientas  y  la flexibilidad  de este  procesador,
podrán sustituirlo. Dada la desatención  de las grandes compañías a la
comunidad científica internacional, parece que  el futuro del {\LaTeX} es
todavía prometedor. Aparte de por una gran ventaja que lo distingue de
AmiPro, Word o WordPerfect. El {\LaTeX} es freeware. 
\end{quotation}




\begin{quotation}
 Veamos  la versatilidad de  {\LaTeX} aplicada a  las matemáticas,
con  un  ejemplo  no  demasiado sencillo.  Las  líneas  que  comienzan
por  el  caracter  {\ttfamily \%}  (porcentaje) son  comentarios,  y  explican
suficientemente el contenido del  fichero. Veamos cómo podemos obtener
distintos  ficheros de  salida,  en formatos  PostScript  y PDF  entre
otros.  En el  fichero {\ttfamily ejemplo.tex}  tenemos el  siguiente código:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
% BEGIN: Ejemplo 1 de {\LaTeX} para CILA

% Define el  tipo de documento  como "article" (artículo)  y especifica
% las opciones "a4paper" (tamaño de  papel A4), "12pt" (tamaño de letra
% a 12 puntos) y "twoside" (para imprimir a doble cara)
\documentclass[a4paper,12pt,twoside]{article}

% Utiliza  el  paquete "inputenc"  con  la  opción "latin1",  esto  nos
% permite teclear  las "ñ" y las  tildes sin tener que  preocuparnos de
% nada, porque el charset que estamos  usando el latin1 y se lo decimos
% a {\LaTeX}
\usepackage[latin1]{inputenc}

% Utiliza el  paquete "babel" con  la opción "spanish", lo  que incluye
% entre  otras  cosas  patrones  de silabeo,  traducción  de  elementos
% insertados  automáticamente,  como  "Índice   general"  en  lugar  de
% "Contents"
\usepackage[spanish]{babel}

% Utiliza el  paquete amssymb,  American Mathematical  Society SYMbols,
% (símbolos de  la Sociedad Matemática  Americana). Es este  paquete se
% encuentra  por ejemplo  el símbolo  de "isomorfo  a" utilizado  en el
% Teorema de Isomorfía.
\usepackage{amssymb}

% Utiliza el paquete  "eurosym" para proporcionar el  símbolo del euro.
% Con este  paquete podemos escribir el  símbolo del euro con  la orden
% \euro
\usepackage{eurosym}

% Ordenamos a {\LaTeX} que no numere  las páginas, ya que tenemos una sóla
% página y un "1" solitario no queda muy bien.
\pagestyle{empty}

% Evita que  {\LaTeX} introduzca  espacios mayores de  lo normal  tras los
% finales de las oraciones. Una pijada.
\frenchspacing

\begin{document} % Comienza el documento

% Esta frase estará centrada y con un tamaño de letra mayor
\begin{center}
{\large Curso de Introducción a Linux para Alumnos}
\end{center}

Esto es un  pequeño ejemplo de {\{\LaTeX}}, el más  potente procesador de
textos. La mayoría  de apuntes y exámenes de Matemáticas  que vemos en
la  Facultad están  escritos  en {\{\LaTeX}}.  Por  cierto, con  {\{\LaTeX}}
también estamos preparados para la llegada del \euro

A continuación algunos ejemplos de fórmulas matemáticas:

% Comenzamos una descripción de varios "items"
\begin{description}

\item [Definición de límite (Análisis Matemático I)]
$$
\lim_{x \longrightarrow a} = l \iff 
\forall \, \varepsilon > 0 \,
\, \exists \, \delta > 0 \, / \,
\, 0 < \| x - a \| < \delta \,
\Longrightarrow \, \| f(x) - l \| < \varepsilon
$$

\item [Teorema Generalizado de Cauchy (Análisis Matemático I)]
Si $f$ y $g$ tienen derivadas contínuas hasta el orden $n(n-1)$ en 
el intervalo $\lbrack a , b \rbrack$ y además $\forall \, x \in (a,b)
\, \, \exists \, f^{n)}(x), g^{n)}(x)$, entonces
$\exists \, c \in (a,b) \, /$
$$
\bigg( f(b) - \sum_{k=0}^{n-1} \frac{f^{k)}(a)}{k!}(b-a)^k \bigg) g^{n)}(x) =
f^{n)}(x) \bigg( g(b) - \sum_{k=0}^{n-1} \frac{g^{k)}(a)}{k!}(b-a)^k \bigg) 
$$

\item [$1^{er}$ Teorema de Isomorfía (Álgebra I)]
Sean $G$, $G'$ grupos, $f : G \longrightarrow G'$
homomorfismo de grupos. Entonces
$$
\frac{G}{Ker(G)} \, \thickapprox \, Im f
$$

\item [Funciones Eulerianas: Gamma y Beta (Análisis Matemático II)]
$$
\Gamma(p) = \int_{0}^{+\infty} e^{-x} x^{p-1} dx \quad \forall \, p > 0
$$
$$
\beta(p,q) = \int_{0}^{1} x^{p-1} (1-x)^{q-1} dx
$$

\item [Y por último, un ejemplo denso]
$$
\sum \limits_{n = 0}^{\infty} 
\left(
  \frac
    {\int \limits_{-\infty}^{+\infty}
      {\left\lceil 
        \frac
          {\sin 
            \left[ 
              8 \frac{\pi}{3}^3
            \right]}
          {\arctan \left(
            \sqrt[3]{ 2 \cdot \sin {(x)} }
          \right)}
      \right\rceil 
      dx}
    }
    {\lim \limits_{x \to n^2}
      \left(
        \vert{
          \frac
            {\log
              {\frac
                {\pi}
                {x^4}
              }
            }
            {e^{
              \frac
                {n + 1}
                {n - 1}
              }
            }
        \vert}
      \right)
    }
\right)
=
\left|
  \begin{array}{cccc}
    m_{(i,j)}   & m_{(i,j+1)}       & \ldots   & m_{(i,n)}     \\
    m_{(i+1,j)} & m_{(i+1,j+1)}     & \ldots   & m_{(i+1,n)}   \\
    \vdots        & \vdots              & \ddots & \vdots          \\
    m_{(n,j)}   & m_{(i + n,j + 1)} & \ldots   & m_{(n,n)}
  \end{array}
\right|
$$

\end{description}

\end{document} % Termina el documento

% END: Ejemplo 1 de {\LaTeX} para CILA
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Copiamos   esta  fórmula   en  algún  fichero,   por  ejemplo
{\ttfamily ejemplo.tex} y  veamos los pasos necesarios  para {\itshape compilarlo\/}.
Para compilar el  fuente lo único que hay que  hacer es ejecutar {\LaTeX}
seguido del nombre  del fichero fuente {\LaTeX}. En  nuestro ejemplo, nos
colocaremos  en  el directorio  donde  tenemos  el {\ttfamily ejemplo.tex}  y
teclearemos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ latex ejemplo.tex
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Esto generará varios ficheros,  pero el que realmente interesa
en estos momentos es {\ttfamily ejemplo.dvi}. Este fichero es el resultado de
la compilación  y lo  podemos ver usando  por ejemplo  {\ttfamily xdvi}. Para
verlo teclearemos en el mismo directorio en el que está el fichero
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
xdvi ejemplo.dvi
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Dado que el formato  {\ttfamily DVI} (DeVice Independent) no está muy
extendido se  han generado conversores  de formato, de tal  manera que
podemos  pasar  desde  dvi  a  formato  {\ttfamily PostScript}  y  a  formato
{\ttfamily PDF}, ambos mucho más extendidos que el dvi. Para pasar un fichero
generado por  {\LaTeX} en formato  {\ttfamily DVI} a un  fichero {\ttfamily PostScript}
usaremos el comando {\ttfamily dvips} de la siguiente manera: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ dvips ejemplo.dvi -o ejemplo.ps
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Ahora podemos  ver el resultado con  cualquier visualizador de
ficheros PostScript, por ejemplo {\ttfamily gv}: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ gv ejemplo.ps
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
Una  vez comprobado  que  todo va  bien  intentemos pasar  este
último  fichero   en  formato  {\ttfamily PostScript}  a   formato  {\ttfamily PDF}.
Para  ello  usaremos   el  comando  {\ttfamily ps2pdf}  como   se  explica  a
continuación:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ ps2pdf ejemplo.ps ejemplo.pdf
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Y una  vez hecho esto ya podemos usar  nuestro visualizador de
PDF preferido para ver el {\ttfamily ejemplo.pdf}. 
\end{quotation}


\begin{quotation}
 Esta ha sido una muy  breve introducción a {\LaTeX} que esperamos
haya  sido  suficiente como  para  que  os  pique  el gusanillo  y  os
introduzcais en el maravilloso mundo del {\LaTeX}. 
\end{quotation}





\subsubsection{{\LyX}}

\begin{quotation}
 {\LyX} es un procesador de  textos avanzado, basado en {\LaTeX}, que
permite  crear documentos  de calidad  de forma  más sencilla  que con
{\LaTeX}. Aunque {\LyX} utiliza {\LaTeX}, es mucho más que una simple interface
para  {\LaTeX},  también  puede  generar otros  formatos.  Una  cosa  muy
interesante de {\LyX}  es que permite insertar código de  {\LaTeX}, de forma
que los conocimientos  sobre {\LaTeX} pueden aplicarse también  al uso de
{\LyX} aunque no sean necesarios. 
\end{quotation}


\begin{quotation}
 Debido a la brevedad del presente curso, no nos entretendremos
en el uso de {\LyX}, ya  que éste proporciona una sencilla introducción y
un  breve  tutorial  en  castellano  que  son  ayuda  suficiente  para
comenzar a escribir  apuntes, trabajos, cartas y  otros documentos sin
necesidad de estudiar nada complicado.  Para leer la introducción y el
tutorial  de {\LyX}  basta con  elegir {\ttfamily Introducción}  o {\ttfamily Tutorial}
respectivamente en el menú {\ttfamily Ayuda}.  En el mismo menú se encuentran
los restantes capítulos de la documentación de {\LyX} en inglés: {\ttfamily Guía
del  usuario}, {\ttfamily Características  extendidas}, {\ttfamily Personalización},
{\ttfamily Manual de  referencia}, {\ttfamily Preguntas  de uso frecuente}  y otros.
\end{quotation}







\subsection{Software de cálculo y representación.}


\subsubsection{Octave}

\begin{quotation}
 Octave se puede definir como un lenguaje de alto nivel pensado
para  cálculos numéricos,  en especial  para trabajar  con matrices  y
vectores. Se puede usar para resolver numéricamente problemas lineales
o no lineales, o para hacer otros tipos de experimentos numéricos. Los
comandos que  se quieren ejecutar se  pueden escribir interactivamente
en  una  línea  de  comandos,  o  bien,  en  caso  de  que  se  quiera
automatizar una ejecución, se puede escribir el script correspondiente
y ejecutarlo de manera sencilla. 
\end{quotation}


\begin{quotation}
 Para ejecutar Octave de manera interactiva, se abre un shell y
se teclea {\ttfamily octave}, tras lo que aparece un prompt y queda preparado
a la espera de que teclees comandos. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
alberto@mencey:~$ octave
GNU Octave, version 2.1.34 (i386-pc-linux-gnu).
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 John W. Eaton.
This is free software with ABSOLUTELY NO WARRANTY.
For details, type `warranty'.

octave:1> 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Si quieres  salir  al  shell desde  dentro  de Octave  teclea
{\ttfamily exit},  {\ttfamily quit}  o   {\ttfamily CTRL+D}.  Para  hacer  representaciones
gráficas deberás haber ejecutado Octave desde un shell dentro de las X
puesto que la  representación gráfica se realiza  usando Gnuplot, cuya
forma de funcionar por defecto es en entorno X-Window. 
\end{quotation}


\begin{quotation}
 Existen varias maneras de  documentarse sobre la forma de usar
Octave.
\end{quotation}


\begin{itemize}
\item  Si quieres  ir relajadamente y de forma  ordenada mirando cosas
por tu cuenta, la mejor fuente, aunque no siempre actualizada, es abrir
un shell y ejecutar:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
alberto@mencey:~$ info octave
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Podrás navegar por una ayuda detallada,  mientras por el otro lado vas
trabajando, y  en la que  se describen las funciones  documentadas del
programa, pero  clasificadas por  materias y  explicadas de  una forma
cuidadosa.  Usa  {\ttfamily tabulador},  {\ttfamily flechas}, {\ttfamily enter}  y  {\ttfamily u},
{\ttfamily s} para  buscar y  {\ttfamily q} para  salir. Si ya  eres un  usuario mas
avanzado, puedes  pasearte por el  árbol de directorios que  cuelga de
{\ttfamily /usr/share/octave}

\item   Para   el  más  osado,  escribiendo   sencillamente  {\ttfamily help}
aparece el  gigantesco listado de funciones  disponibles descompuestas
en  categorías  que  se  puede  visualizar  con  las  flechas,  teclas
{\ttfamily Home/RePag/AvPag/End} y q para regresar a la línea de comandos
(también regresa  pasando el  final). Esta es  la ayuda  más completa,
pues presenta todas las funciones  existentes en el sistema, muchas de
las cuales a lo mejor no están agregadas en el {\ttfamily info}.

\item   Para  obtener ayuda  de  una  función en  particular,  teclear
{\ttfamily help  nombredelafuncion}.  Si  el  lector  teclea  los  siguientes
ejemplos, obtendrá, aparte  del resultado que se  transcribe aquí, una
coletilla  que informa  sobre como  obtener ayuda  desde el  entorno o
en  la WWW.  La  omitiremos  para clarificar  y  ahorrar espacio.  Por
ejemplo, veamos que  resulta de ver la ayuda de  la función cotangente
hiperbólica:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:2> help coth
coth is the user-defined function from the file
/usr/share/octave/2.1.34/m/elfun/coth.m

 - Mapping Function:  coth (X)
     Compute the hyperbolic cotangent of each element of X.
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


La mayoría de los comandos complejos de Octave disponen de esta ayuda.
Vemos que se  nos dice una descripción  de los parámetros y  de lo que
realiza la función, lo cual es suficiente para que podamos utilizarla.
Para el autodidacta, solo tienes que ir al listado largo, quedarte con
la categoría  que te interese, e  ir chequeando cada función  a ver si
hace lo que nos interesa.
\end{itemize}


\begin{quotation}
  Si leemos  más detenidamente  el principio  de la  ayuda, nos
comenta que {\ttfamily coth(X)} es una función  definida por el usuario en un
fichero  situado en  {\ttfamily /usr/share/octave/version/m/elfun/coth.m}
Si  tenemos curiosidad  por ver  ese fichero,  descartando comentarios
precedidos por {\ttfamily \#\#}, observamos lo siguiente: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
function w = coth (z)

  if (nargin != 1)
    usage ("coth (z)");
  endif

  w = cosh (z) ./ sinh (z);

endfunction
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Como  el  lector  ha  visto,  así  es  como  se  amplían  las
capacidades  de  Octave  y   se  implementan  nuevos  comandos.  Todas
las  funciones  que  has  visto  en  el  listado  largo  (excepto  las
nativas)  proceden  de  ficheros  {\ttfamily *.m},  por  lo  que  puedes  ver
incluso  de  que  forma   están  implementadas  simplemente  hiendo  a
{\ttfamily /usr/share/octave},   localizándolas  y   mirándolas  por   tí
mismo.  Si  durante su  uso  diario  encuentras  algún defecto  en  su
funcionamiento, tú mismo  puedes ir a su código fuente  y comprobar si
el fallo es tuyo o es de la función, en este caso podrás contribuir al
proyecto  enviando la  notificación del  bug  y su  corrección, si  la
conoces. 
\end{quotation}


\begin{quotation}
 Ni  que decir  tiene que puedes  crear tus  propias funciones,
siguiendo   unas  pequeñas   reglas   que  puedes   consultar  en   la
documentación, y si las  colocas dentro de {\ttfamily /usr/share/octave},
serán  añadidas al  listado como  si  de las  funciones originales  se
tratasen. Si la función que  has creado es interesante, siempre puedes
enviarla a  los autores de Octave  para que la incluyan  en la próxima
versión. 
\end{quotation}


\begin{quotation}
  Si, de  igual forma  hacemos help  sobre comandos  nativos de
Octave: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:3> help sinh
help: sorry, `sinh' is not documented
octave:4> help cosh
help: sorry, `cosh' is not documented
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Octave  nos da un mensaje  de error puesto que  esa función no
esta implementada  mediante un fichero {\ttfamily *.m},  una función definida
por el usuario,  sino que es una función nativa  del lenguaje. También
existen otras funciones, con extensión  {\ttfamily *.oct} que no son visibles
pues están compiladas para optimizar su rendimiento, como por ejemplo:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:5> help lsode
lsode is the dynamically-linked function from the file
/usr/lib/octave/2.1.34/oct/i386-pc-linux-gnu/lsode.oct
...
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Los  tipos de  datos en  Octave son  los vectores  y matrices,
strings y  estructuras. Las  matrices y vectores  son los  más usados,
los  strings  no  se  suelen  usar sino  para  presentar  mensajes,  y
las  estructuras  suelen ser  una  buena  base para  organizar  tareas
complicadas, pero  no se  tratarán aquí. En  el siguiente  log veremos
definiciones de cada uno de ellos. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:6> a=[1,2,3] 
a =
  1  2  3

octave:7> b=[1,2,3;4,5,6;7,8,9]
b =
  1  2  3
  4  5  6
  7  8  9

octave:8> c="hola mundo"
c = hola mundo

octave:9> d.vector=[1,2];
octave:10> d.matriz=[1,2;3,4];
octave:11> d 
d =
{
  vector =
    1  2

  matriz =
    1  2
    3  4
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Se  hace  necesario  anotar  una  característica  introducida
sutilmente en  este último  ejemplo. Un  punto y coma  al final  de la
línea le  dice a Octave que  no muestre ninguna salida  al ejecutar el
comando.  Así, en  el ejemplo,  las  asignaciones a  la estructura  no
mostraron mensaje pues tenían {\ttfamily ;} al final. 
\end{quotation}


\begin{quotation}
 También añadiré que para mostrar el valor de una variable solo
hay que introducir su  nombre, tal como se ha hecho  en el ultimo paso
del ejemplo  anterior. Si queremos  ver que variables existen  en este
momento  en  el  programa,  simplemente  tecleamos  {\ttfamily who}  (versión
reducida) o {\ttfamily whos} (versión larga). 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:12> who

*** currently compiled functions:
coth

*** local user variables:
a  b  c  d

octave:13> whos

*** currently compiled functions:
prot  type                       rows   cols  name
====  ====                       ====   ====  ====
 rwd  user-defined function         -      -  coth

*** local user variables:
prot  type                       rows   cols  name
====  ====                       ====   ====  ====
 rwd  matrix                        1      3  a
 rwd  matrix                        3      3  b
 rwd  string                        1     10  c
 rwd  struct                        -      -  d
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Como  curiosidad,  añadir  que Octave,  la  primera  vez  que
ejecutas  una  función  de  usuario, realiza  una  parte  de  análisis
sintáctico para verificación de la  función y luego compila la función
para  seguidamente ejecutarla,  todo  esto de  forma transparente.  La
segunda vez  que ejecutas  la función,  si el  fuente no  ha cambiado,
aprovecha  la compilación  anterior  y pasa  a ejecutar  directamente,
ahorrando un tiempo precioso en el proceso. 
\end{quotation}


\begin{quotation}
 Otro aspecto muy útil  es que Octave posee estructuras típicas
de lenguajes de programación propiamente dichos, como son: {\ttfamily if},
{\ttfamily switch}, {\ttfamily while}, {\ttfamily do-until},  {\ttfamily for}, {\ttfamily break},
{\ttfamily continue}, y {\ttfamily unwind\_protect}  y {\ttfamily try-catch}
para  el manejo  de  excepciones. También  se  definen los  operadores
lógicos típicos  and, or,  ...; los  de comparación  {\ttfamily ==}, {\ttfamily !=},
{\ttfamily $>$=}, ...; incluso los operadores  típicos de post-incremento
{\ttfamily x++} y similares de C++. Esto último y la existencia de los try-catch
posiblemente hayan hecho pensar a algún lector que existe alguna
relación  entre Octave  y C++...
Pues  ese lector  ha pensado  correctamente. Al  final nombraremos  la
relación. 
\end{quotation}


\begin{quotation}
  Para limpiar  la memoria  se usa  el comando  {\ttfamily clear}. Con
{\ttfamily save}  guardamos el  entorno de  variables a  un fichero,  para su
posterior recuperación  con {\ttfamily load}. Proseguiremos  haciendo algunas
operaciones básicas sobre matrices y vectores. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:14> a=[1:4]    # comienzo -> paso=1 -> final
a =
  1  2  3  4

octave:15> b=[2:2:8]  # comienzo -> paso -> final
b =
  2  4  6  8

octave:16> a.*b   # multiplicación elemento a elemento
ans =
   2   8  18  32

octave:17> a./b   # división elemento a elemento
ans =
  0.50000  0.50000  0.50000  0.50000

octave:18> a*b'   # vector 1x4 x vector 4x1
ans = 60

octave:19> a'*b   # vector 4x1 x vector 1x4
ans =
   2   4   6   8
   4   8  12  16
   6  12  18  24
   8  16  24  32

octave:20> c=diag([1,2,3,4]) # creación de matrices diagonales
c =
  1  0  0  0
  0  2  0  0
  0  0  3  0
  0  0  0  4

octave:21> inv(c) # inversa de una matriz
ans =
  1.00000  0.00000  0.00000  0.00000
  0.00000  0.50000  0.00000  0.00000
  0.00000  0.00000  0.33333  0.00000
  0.00000  0.00000  0.00000  0.25000

octave:22> det(c) # determinante de una matriz
ans = 24

octave:23> eye(4) # matriz identidad de dimensión 4
ans =
  1  0  0  0
  0  1  0  0
  0  0  1  0
  0  0  0  1

octave:24> rand(4,3) # matriz de números aleatorios 4x3
ans =
  0.85927  0.43700  0.85462
  0.88050  0.27016  0.52905
  0.58098  0.54402  0.29237
  0.41791  0.73324  0.45943
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Esto es  sólo una mínima expresión de  los comandos utilizados
para vectores y matrices. Cuando ya  se tiene experiencia y se conocen
todos los  comandos, muchas  cosas que  se suelen  hacer con  bucles u
otras construcciones  se empiezan a  hacer con vectores y  entonces es
cuando aprovechas al máximo las capacidades de Octave. En las primeras
secciones de {\ttfamily info octave} o en los primeros capítulos de cualquier
manual de  Matlab\textregistered{} se pueden  encontrar paso a  paso explicaciones
sobre todas estas funciones. 
\end{quotation}


\begin{quotation}
  En los  siguientes  ejemplos  entraremos en  el  campo de  la
representación gráfica,  que también  es sencillo (NOTA:  no olvidarse
los puntos y comas al final de línea pues los vectores son algo largos
para estarlos visualizando, y pulsar {\ttfamily q} para cerrar las gráficas).
\end{quotation}


\begin{quotation}
 Presentación en una  dimensión: La función {\ttfamily plot(vector)} o
{\ttfamily plot(x,y)}  es muy  sencilla de  usar. La  diferencia entre  ambas
llamadas  es que  cuando presentamos  un vector,  el eje  x se  numera
automáticamente de  1 en  adelante, mientras que  la segunda  forma de
llamarla, el  valor del eje  x esta  definido por nosotros.  Veamos el
siguiente ejemplo que presenta un periodo de una senoidal. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:25> x=[0:0.01:1];
octave:26> y=sin(2*pi*x);
octave:27> plot(x) # presentamos una recta
octave:28> plot(y) # presentamos una senoidal
octave:29> plot(x,y) # senoidal, pero con eje x bien puesto
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Representación en dos dimensiones: La función {\ttfamily mesh(x,y,z)}
hace una representación 3D dados dos vectores {\ttfamily x} e {\ttfamily y} para los
ejes y una matriz bidimensional {\ttfamily z}  que será la coordenada Z en un
espacio  tridimensional.  En  este  ejemplo, lo  mas  complicado  será
generar una  matriz {\ttfamily z}  bonita. Una  vez tenemos  la matriz  y los
ejes, la llamada es directa. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:30> x=[-1:0.1:1]; # vector del eje x 
octave:31> y=[-1:0.1:1]; # vector del eje x
octave:32> [mx,my]=meshgrid(x,y); # genera matrices de ejes
octave:33> mesh(mx) # matriz que representa las x
octave:34> mesh(my) # matriz que representa las y
octave:35> mz=2-mx.^2-my.^2; # elemento por elemento
octave:36> mesh(x,y,mz)
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Dentro  del  campo  de   la  ingeniería,  Octave  dispone  de
una  excelente toolbox  para  teoría del  control,  donde se  utilizan
estructuras  para  abstraer  al  usuario el  concepto  de  función  de
transferencia  de un  sistema, y  funciones para  el procesamiento  de
señales. En este  último caso, permite aplicar los  resultados a casos
reales ya que tiene módulos para cargar y salvar los datos de imágenes
y sonidos. 
\end{quotation}


\begin{quotation}
  La transformada  de  Fourier discreta,  más  conocida por  el
nombre  de  su algoritmo  FFT  ({\bfseries Fast  Fourier Transform}),  es  la
versión  discreta  y  periódica  de  la  transformada  exponencial  de
Fourier. Es una función muy usada en  ingeniería y en la vida real. La
tomaremos como  la función  para la ingeniería  por antonomasia,  y en
este ejemplo veremos  que sencillo resulta obtener  la transformada de
fourier discreta de un pulso. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:37> x=[-1:0.01:1];
octave:38> y=(abs(x)<0.2); # escalon generado con una comparación
octave:39> plot(x,y) # función original
octave:40> f=abs(fftshift(fft(y)));
octave:41> plot(f)  # función transformada
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Por último, dentro del  campo de las Matemáticas, Octave tiene
muchas  más funciones  avanzadas para  realizar cálculos  financieros,
distribuciones estadísticas, álgebra lineal  y ecuaciones no lineales,
polinomios, etc,  unas más  avanzadas que otras,  lo que  bien valdría
dedicarle un estudio particular. Como ejemplo indicativo se muestra lo
que  es necesario  escribir para  resolver numéricamente  una ecuación
diferencial no lineal de  la forma {\bfseries dx/dt=f(x,t)} con condición
inicial {\bfseries x(t=t0)=x0}. Aunque no podamos  ver el código de lsode
puesto que es una función interna, nos puede servir como ejemplo de lo
versátil  que puede  resultar en  calculo numérico  la metodología  de
Octave al trabajar solo con vectores y matrices. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
octave:42> function xdot = f (x, t)
> r = 0.25;
> k = 1.4;
> a = 1.5;
> b = 0.16;
> c = 0.9;
> d = 0.8;
> xdot(1) = r*x(1)*(1 - x(1)/k) - a*x(1)*x(2)/(1 + b*x(1));
> xdot(2) = c*a*x(1)*x(2)/(1 + b*x(1)) - d*x(2);
> endfunction
octave:43> x0 = [1; 2];
octave:44> t = linspace (0, 50, 200)';
octave:45> x = lsode ("f", x0, t);
octave:46> plot (t, x)
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Para   cualquiera  que  desee  optimizar   las  computaciones
realizadas  con   Octave,  Octave  provee  de   una  librería  llamada
{\ttfamily liboctave} que define unas clases  sobre C++ que te permiten pasar
tu  script  desde  Octave  hacia C++  casi  directamente,  para  luego
compilarlo y obtener tu ejecutable, o  para crear tu código objeto que
puedas integrar  en una  aplicación mayor  escrita en  otros lenguajes
como C, C++, Perl, Python, etc. 
\end{quotation}


\begin{quotation}
 La  web oficial de Octave  es: http://bevo.che.wisc.edu/octave
\end{quotation}





\subsubsection{Gnuplot}





\begin{quotation}
 Gnuplot es el programa encargado de hacer las gráficas 2D y 3D
que se visualizaban en Octave. Gnuplot es un programa independiente de
Octave, que  usado por si  mismo te permite hacer  representaciones de
funciones  continuas  y  de  tablas  de  datos.  Octave  solo  usa  un
subconjunto de las funcionalidades de Gnuplot. 
\end{quotation}


\begin{quotation}
 La primera  característica de Gnuplot es que es  muy similar a
Octave  en  funcionamiento,  es  decir,  que  posee  una  interfaz  de
comandos muy poderosa que también puedes utilizar escribiendo scripts.
Esta  forma de  trabajar tiene  sus  desventajas y  sus ventajas.  Las
desventajas es que necesitas una curva de aprendizaje más lenta, donde
tienes que  haberte mirado por lo  menos la descripción de  uno de los
comandos ({\ttfamily plot})  para poder  empezar a  hacer algo.  Cuando estas
tanteando datos mejor que uses otro  programa que te permita hacer las
cosas más interactivamente. Pero cuando  ya tienes claro lo que tienes
que hacer, por ejemplo, sobre una  tabla de datos, y tienes 100 tablas
de datos a las que hacer lo  mismo, poder hacer un script puede ser de
una gran ayuda.
\end{quotation}


\begin{quotation}
 La otra característica destacable de Gnuplot es la variedad de
formatos de  salida de que  dispone, que  se pueden seleccionar  en el
script.  Te  permite  exportar  a formatos  vectoriales  (xfig,  tex,
postscript),  formatos  bitmap (png,  pbm),  o  formatos de  impresora
(epson, hp, etc).  Con esto puedes tener tu gráfica  retocada por xfig
en tu publicación en  {\LaTeX}, o bien puesta en tu página  web (png) y o
bien impresa directamente en una impresora. 
\end{quotation}


\begin{quotation}
 Al ejecutar  gnuplot en un shell  de x entramos a  su linea de
comandos: 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
alberto@mencey:~$ gnuplot

        G N U P L O T
        Linux version 3.7
        patchlevel 1
        last modified Fri Oct 22 18:00:00 BST 1999

        Copyright(C) 1986 - 1993, 1998, 1999
        Thomas Williams, Colin Kelley and many others

        Type `help` to access the on-line reference manual
        The gnuplot FAQ is available from
        <http://www.ucc.ie/gnuplot/gnuplot-faq.html>

        Send comments and requests for help to <info-gnuplot@dartmouth.edu>
        Send bugs, suggestions and mods to <submit@bugs.debian.org>


Terminal type set to 'x11'
gnuplot> 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Como  fuente  de  ayuda teclea  {\ttfamily help}  desde  dentro  del
programa y después  de una pantalla introductoria te  saldrá un prompt
sobre el  que podrás escribir,  o bien un  nombre que elegirás  de los
topics que  se te presentan,  o bien un  nombre de comando  si quieres
conocer su sintaxis. 
\end{quotation}


\begin{quotation}
 Como has visto, el formato de salida es x11 (visualizar en las
X). Para ver un listado de  los diferentes tipos de salida disponibles
usa {\ttfamily set terminal}. 
\end{quotation}


\begin{quotation}
 La parte más sencilla y práctica de Gnuplot es la presentación
de funciones  continuas, tanto en  forma explícita {\ttfamily y=f(x)}  o
{\ttfamily z=f(x,y)}, como puede ser  en forma paramétrica: curvas 2D
{\ttfamily (x,y)=f(t)}, curvas 3D {\ttfamily (x,y,z)=f(u)}, superficies 3D
{\ttfamily (x,y,z)=f(u,v)}. 
\end{quotation}


\begin{quotation}
 Con  {\ttfamily help functions} tenemos  un listado de  las funciones
que  admite.  Una  gran  desventaja  que tiene  es  que  muestrea  las
funciones a intervalos  regulares, por tanto, no  hace ningún análisis
de  discontinuidades (lo  que  se  nota en,  por  ejemplo, la  función
{\ttfamily floor}),  aunque  si  se  puede configurar  para  que  reduzca  el
intervalo. Si queremos imponer cual será el  rango del eje X o el Y lo
ponemos  entre  corchetes  antes  de  la  función.  Algunos  ejemplos:
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
gnuplot> plot x                        # identidad
gnuplot> plot abs(x)                   # valor absoluto
gnuplot> plot x**2                     # parábola
gnuplot> plot [-1:1] sqrt(1-x**2)      # semicircunferencia
gnuplot> plot [] [-0.1:1.1] exp(-x**2) # gaussiana
gnuplot> plot [-1:4] gamma(x)          # función gamma
gnuplot> plot floor(x)                 # función redondeo hacia abajo
gnuplot> plot x-floor(x)               # diente de sierra
gnuplot> splot x**2+y**2               # plot en 3D
gnuplot> splot sqrt(1-x**2+y**2)              
gnuplot> set isosamples 20,20          # cambia la resolución
gnuplot> replot                 
gnuplot> set isosamples 50,50          # cambia la resolución
gnuplot> set contour                   # activa líneas de nivel
gnuplot> replot
gnuplot> set parametric                # modo paramétrico 

        dummy variable is t for curves, u/v for surfaces
gnuplot> set samples 500                   # mejor resolución (+lento)
gnuplot> plot sin(7*t),cos(5*t)            # lissajous en 2D
gnuplot> splot sin(5*u),sin(6*u),sin(7*u)  # lissajous en 3D
gnuplot> set samples 100                   # menor resolución (+rapido)
gnuplot> splot cos(u)*cos(v),cos(u)*sin(v),sin(u)  # esfera en 3D
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Gnuplot  también tiene un  modo para trabajar con  archivos de
datos con múltiples columnas. Cuando los  archivos de datos tienen 1 o
2  columnas  se  presentan  directamente.  Si  un  archivo  tiene  más
de  2 columnas  se  pueden presentar  columnas arbitrariamente,  hacer
operaciones matemáticas  sencillas entre  columnas. Veamos esto  en un
ejemplo real (bastante prolijo) donde  un servidor genera una linea de
log de  load, logins y  carga de cpu, a  cada hora y  queremos obtener
gráficas que muestren la evolución en el tiempo 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
# Ejemplo para la monitorización de carga de un servidor en el tiempo

set title "Convex     November 1-7 1989    Circadian"
set key left box
set xrange[-1:24]
plot 'gnuplot.dat' using 2:4 title "Logged in" with impulses,\
     'gnuplot.dat' using 2:4 title "Logged in" with points
pause -1 "Hit return to continue"

set xrange [1:8]
#set xdtic
set title "Convex     November 1-7 1989"
set key below
set label "(Weekend)" at 5,25 center
plot 'gnuplot.dat' using 3:4 title "Logged in" with impulses,\
     'gnuplot.dat' using 3:5 t "Load average" with points,\
     'gnuplot.dat' using 3:6 t "%CPU used" with lines
set nolabel
pause -1 "Hit return to continue"
reset
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Como último  ejemplo, vamos a probar un script  donde se hacen
ajustes por el método de mínimos  cuadrados con Gnuplot. En el ejemplo
se realizan ajustes a una recta  variando los pesos, pero el método de
ajuste que utiliza Gnuplot permite  poner cualquier función de ajuste,
simplemente definiendo las variables y constantes y dando unos valores
iniciales a las constantes. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
# ajustes por mínimos cuadrados en Gnuplot 

y(x) = a*x + b   # función a la que se ajustará
a = 0.0          # valores iniciales
b = 0.0          # de los parámetros

fit y(x) 'gnuplot-fit.dat' via a, b
set title 'Ajuste sin pesar'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:3 via a, b
set title 'Ajuste con mayor peso en bajas temperaturas'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:4 via a, b
set title 'Ajuste con mayor peso a altas temperaturas'
plot 'gnuplot-fit.dat', y(x)
pause -1 "Pulsa enter para continuar"

fit y(x) 'gnuplot-fit.dat' using 1:2:5 via a, b
set title 'Ajuste con peso correspondiente a error experimental'
plot 'gnuplot-fit.dat' using 1:2:5 with errorbars, y(x)
pause -1 "Pulsa enter para continuar"
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsubsection{Scilab}

  
\begin{quotation}
  Visto Octave,  Scilab  es  otro  intento de  clónico  de
Matlab\textregistered{} totalmente diferente a Octave, que intenta ganar facilidad
de uso  pero en ciertas  cosas dejando de  ser Matlab\textregistered{}-compatible.
También existe una diferencia en espíritu y es que Octave es GPL, todo
su  código  es obtenido  de  fuentes  GPL  y  por tanto,  los  cambios
repercuten en  los usuarios por  las vías  usuales en la  comunidad de
software libre, mientras que en el  scilab, la licencia es escrita por
{\bfseries INRIA} (Francia)  y tiene ciertas  limitaciones con respecto  a la
GPL,  en especial  sobre  autoría,  aparte de  incluir  una mezcla  de
código  de libre  distribución y  código propietario.  Las principales
diferencias que se aprecian, con más detalle son: 
\end{quotation}


\begin{itemize}
\item Las ayudas ahora están en integradas en modo gráfico, lo que las
hace un poco más amistosas pero más molestas. En contenido son un poco
más detalladas que las de Octave.
\item Ya no se  usa Gnuplot para la presentación gráfica.  La forma de
presentar plots  es diseñada por  la gente  de scilab y  permite hacer
zoom y exportar usando el ratón.
\item Octave posee estructuras de datos y scilab no
\item En  Octave 3.14159...  se llama  {\ttfamily pi}  y en  scilab se  llama
{\ttfamily \%pi}
\item Los comentarios de Octave eran con {\ttfamily \#\#} y en scilab son con
{\ttfamily //}
\item El  plot de  Octave (para  2D) sigue  funcionando, pero  el mesh
para  3D  es  sustituido/ampliado   por  varias  funciones  diferentes
({\ttfamily param3d}, {\ttfamily plot3d}, ...).
\item Los valores lógicos  en Octave se presentan como  valores (0.0 y
1.0). En scilab son otro tipo de datos (V y F).
\item El load/save del Octave, aunque siguen funcionando en scilab, se
complementan con el menú {\bfseries File $<$ File Operations}.
\item Cargar funciones externas  en scilab es un  proceso más complejo
(ver {\ttfamily getf}).
\item El Octave permitía exportar a C++ y el scilab no lo permite.
\item En scilab se aumenta el número de funciones disponibles, pues te
permite utilizar funciones  de su API que el programa  usa para pintar
ventanas,  controles,  lineas, dibujos,  imágenes,  etc,  para que  tu
pintes lo que quieras.
\item En estabilidad,  subjetivamente, encuentro más estable  a Octave
que a scilab
\item Ambos tienen ports  a plataforma Win32, por lo  tanto, no existe
demasiada diferencia en ese aspecto.
\end{itemize}


\begin{quotation}
 En resumen, si usas un  Matlab\textregistered{} básico, pues escoge el que
más  te guste  de  ámbos. Ten  cuidado porque  si  quieres pasarle  tu
programa a álguien que use el  otro deberá estar cambiando los {\ttfamily pi}
y los comentarios que pongas. Si  no puedes vivir sin GUI, usa scilab.
Si  vas a  hacer algo  serio, usa  Octave, porque  tu código  será más
entendible por  los viejos usuarios de  Matlab\textregistered{}, cualquier ejemplo
de  Matlab que  encuentres por  ahí lo  podrás ejecutar  sin demasiado
problema, podrás pasarlo a C++ en un futuro, y lo de dibujar en scilab
no está tan claro que lo vayas a aprovechar. 
\end{quotation}





\subsubsection{R }

  
\begin{quotation}
 {\ttfamily R}  es un  entorno de  programación para  análisis de
datos y gráficos, especialmente  útil para estadística. {\ttfamily R} dispone
de librerías  que implementan muchas técnicas  estadísticas, desde las
clásicas  hasta la  última  metodología, pero  el  usuario debe  estar
dispuesto a trabajar un poco para encontrarlas. 
\end{quotation}


\begin{quotation}
 La forma  de trabajar con {\ttfamily R} es distinta  que con de otros
programas  como  {\ttfamily SPSS}.  En  {\ttfamily R}, un  análisis  estadístico  se
realiza en  una serie  de pasos, con  unos resultados  intermedios que
se  van  almacenando en  objetos,  para  ser observados  o  analizados
posterioresmente,  produciendo  unas  salidas  mínimas.  En  {\ttfamily SPSS}
se  obtendría de  modo  inmediato una  salida  copiosa para  cualquier
análisis. Esto puede parecer a primera vista una terrible incomodidad,
pero  si  tuviéramos   que  trabajar  en  una   máquina  poco  potente
rápidamente nos daríamos cuenta de que puede resultar muy ventajosa la
sencillez  del  entorno  de  {\ttfamily R}  (un entorno  de  comandos)  y  la
posibilidad de ver en cada momento exáctamente lo que se necesita, sin
excesos que desperdicien recursos del sistema. 
\end{quotation}


\begin{quotation}
 Veamos  cómo se trabaja  con {\ttfamily R} usándolo. En  primer lugar
conviene crear  un directorio  y entrar  en él  antes de  comenzar una
sesión con {\ttfamily R}, que en éste almacena siempre en el directorio donde
se ejecutan unos ficheros donde almacena los objetos, datos, funciones
y comandos ejecutados. Esto puede  sernos muy útil en trabajos largos,
podemos  interrumpir  la sesión  con  {\ttfamily R}  en cualquier  momento  y
recuperarla luego donde mismo la dejamos. 
\end{quotation}


\begin{quotation}
 Hemos considerado a lo largo  de este curso que el símbolo del
sistema  Linux/UNIX es  {\ttfamily \$},  y  ahora vamos  a  considerar que  el
símbolo del prompt {\ttfamily R} es {\ttfamily $>$}. Abrimos un emulador de terminal
dentro del entorno gráfico y seguimos los siguientes pasos. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
$ mkdir sesion_R
$ cd sesion_R
$ R

R : Copyright 1999, The R Development Core Team
Version 0.90.1  (December 15, 1999)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type    "?license" or "?licence" for distribution details.

R is a collaborative project with many contributors.
Type    "?contributors" for a list.

Type    "demo()" for some demos, "help()" for on-line help, or
        "help.start()" for a HTML browser interface to help.
Type    "q()" to quit R.

>
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 El símbolo  {\ttfamily $>$} es el prompt de {\ttfamily R},  indica que está
esperando  nuestras  órdenes  para ejecutarlas.  Comenzamos  con  unos
ejemplos de vectores, distribuciones  probabilísticas y algún gráfico.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
> x <- rnorm(50)
> y <- rnorm(x)
> plot(x,y)
> ls()
[1] "x"        "y"
> rm(x,y)
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Hasta ahora nada complicado,  hemos introducido en {\ttfamily x} y en
{\ttfamily y} dos vectores  cada uno de 50 pseudoaleatorios  obtenidos de una
distribución normal  N(0,1), los mostrado  en un gráfico  X-Y, listado
los  objetos  disponibles y  borrados  los  objetos {\ttfamily x}  e  {\ttfamily y}.
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
> x <- 1:20
> w <- 1 + sqrt(x)/2
> hoja.de.datos <- data.frame(x=x,y=x+rnorm(x)*w)
> hoja.de.datos
> regr <- lm(y~x,data=hoja)
> summary(regr)

Call:
lm(formula = y ~ x, data = hoja)

Residuals:
    Min      1Q  Median      3Q     Max 
    -4.4338 -1.6785 -0.4704  1.9643  4.1038 

    Coefficients:
                Estimate Std. Error t value Pr(>|t|)    
(Intercept)  1.78985    1.08627   1.648    0.117    
x            0.84553    0.09068   9.324 2.59e-08 ***
---
Signif. codes:  0  `***'  0.001  `**'  0.01  `*'  0.05  `.'  0.1  ` '  1 

Residual standard error: 2.338 on 18 degrees of freedom
Multiple R-Squared: 0.8285,     Adjusted R-squared: 0.8189 
F-statistic: 86.94 on 1 and 18 degrees of freedom,      p-value: 2.592e-08 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
 Esta vez hemos introducido  en {\ttfamily x} el vector (1,2,...,20) y
a partir  de él creamos  un vector ponderado de  desviaciones típicas,
que  almacenamos  en  {\ttfamily w}.  Con  estos  dos  vectores  creamos  una
{\itshape hoja  de datos\/},  la guardamos  en {\ttfamily hoja},  y la  mostramos por
pantalla.  A  continuación  realizamos  el  ajuste  de  un  modelo  de
regresión lineal de {\ttfamily y} sobre {\ttfamily x}, lo almacenamos en {\ttfamily regr} y
presentamos en pantalla un resumen  del análisis. Veamos ahora algunas
representaciones gráficas a partir de estos datos. 
\end{quotation}


\begin{quotation}
 En primer  lugar conectamos la hoja de datos,  de tal modo que
sus  columnas  aparecen  como  variables y  podemos  acceder  a  ellas
directamente  por  su  nombre.   Realizamos  una  regresión  local  no
paramétrica.  Representamos el  gráfico  bidimensional  estándar y  le
superponemos la regresión local, la verdadera recta de regresión, y la
recta de regresión ponderada. Una vez  que hemos terminado con la hoja
de datos {\ttfamily hoja} la desconectamos. 
\end{quotation}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
> attach(hoja)
> regr.loc <- lowess(x,y)
> plot(x,y)
> lines(x,regr.loc$y)
> abline(0,1,lty=3)
> abline(coef(regr),col="red")
> detach()
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{quotation}
  Finalmente  terminamos la  sesión  con  el comando  {\ttfamily q()}.
{\ttfamily R} nos  preguntará si  queremos guardar la  imagen del  espacio de
trabajo, que es donde están  guardados todos los objetos que estábamos
usando y  el historial  de los comandos  que hemos  ejecutado. Podemos
responder {\ttfamily c}  para cancelar y  no salir, {\ttfamily n} para  desechar los
datos y no guardarlos  o {\ttfamily y} para guardar los datos  de la sesión y
poder así retomarla en cualquier momento. Nótese que {\ttfamily R} guarda una
imagen de espacio  de trabajo en cada directorio donde  se ejecuta, lo
que  nos permite  tener múltiples  sesiones guardadas  según dónde  lo
hayamos ejecutado. 
\end{quotation}







\section{Edición de gráficos
    }


\subsection{GtkGraph     }



\begin{quotation}
 {\ttfamily GtkGraph} es un sencillo programa para representar
funciones  reales  de  variable real,  {\ttfamily y=f(x)},  sobre  un
sistema  de coordenadas  cartesiano.  Resulta  útil para  producir
gráficos simples de una manera rápida  y más o menos intuitiva. La
sintaxis para las funciones es parecida a la de {\LaTeX}, veamos unos
sencillos ejemplos: 
\end{quotation}


\begin{itemize}
\item {\ttfamily y = sin(x) * cos(x) * x\^{}2 - x}
\item {\ttfamily y = exp(x) * log(x) - atan(sqrt(x)) + x\^{}2 + 1}
    
\item {\ttfamily y = sinh(x) + cosh(x) - 1}
       
\end{itemize}


\begin{quotation}
  En  el menú  {\ttfamily Archivo}  del  programa tenemos  las
opciones de  guardar un gráfico generado  en formatos {\ttfamily PNG}
(Portable Network Graphics) o PostScript. 
\end{quotation}





\subsection{DIA     }



\begin{quotation}
 {\ttfamily DIA}  es un programa para  editar diagramas, tales
como esquemas  de circuitos,  topologías de redes  de ordenadores,
sistemas hidráulicos o diagramas de  flujo. Sus capacidades no son
muy avanzadas dado  que se encuentra aún en  proceso de desarrollo
(versión 0.88),  pero resulta  útil para  crear esquemas  de forma
rápida y fácil. 
\end{quotation}


\begin{quotation}
 Para  ver un  ejemplo sencillo  de manejo  de {\ttfamily DIA}
vamos  a crear  un esquema  de cómo  tenemos nuestro  ordenador de
casa. (Quien no tenga puede hacer un esquema de lo que le gustaría
tener, y quien  tenga también ;-) para lo  cual elegimos {\ttfamily Nuevo
diagrama} en el menú {\ttfamily Archivo} y en el menú desplegable
que aparece bajo la barra de herramientas. 
\end{quotation}





\subsection{The GIMP     }



\begin{quotation}
{\ttfamily The  GIMP}  es  el   Programa  de  Manupilación  de
Imágenes de GNU  (GNU Image Manipulation Program).  Es un programa
libremente  distribuible  útil  para  trabajos  como  retoques  de
fotografía,  composición  y publicación de  imágenes.
{\ttfamily The  GIMP} ha  sido  escrito por  Peter  Mattis y  Spencer
Kimball, y liberado bajos la Licencia General Pública (GNU General
Public License).  {\ttfamily The GIMP} es un  programa bastante común
en  las  distribuciones de  GNU/Linux,  y  muy popular  entre  los
usuarios medios/avazanzados de Linux.
\end{quotation}


\begin{quotation}
 La primera  vez que los ejecutemos mostrará  un diálogo de
instalación,  lo cual  se refiere  realmente a  la personalización
(instalación  de  usuario)  del  programa.  En  este  dialogo  nos
preguntará hacerca de la resolución  de la pantalla, que suele ser
72 dpi  (dots per inch, puntos  por pulgada). Dado que  el dialogo
está en español resulta muy fácil de seguir :-)
\end{quotation}


\begin{quotation}
  Cuando  finalmente  {\ttfamily The GIMP}  se  presenta  ante
nosotros vemos cinco  ventanas. La que aparece en  primer plano es
la  ventana  de  {\tt\char`\"}consejo diario{\tt\char`\"},  donde  podemos  leer
trucos y  consejos que {\ttfamily The  GIMP} tendrá la  amabilidad de
enseñarnos.  Las  otras  ventanas  son la  de  {\tt\char`\"}selección  de
brocha{\tt\char`\"}, la  de {\tt\char`\"}opciones  de herramientas{\tt\char`\"},  la de
{\tt\char`\"}capas,  canales  y  caminos{\tt\char`\"} y  la  ventana  principal.
Esta ventana  principal contiene  la barra  de herramientas  y los
selectores de color, gradiente y brocha. 
\end{quotation}


\begin{quotation}
  Para aprender  a manejar  GIMP sólo  se necesitan  ganas,
osadía y unos cuantos ratitos para  sentarse y ponerse a jugar con
las herramientas, filtros y scripts que proporciona. 
\end{quotation}


\begin{quotation}
\end{quotation}





\section{Recursos en internet
  }



\begin{quotation}
 La mayoría  de los recursos que podamos  necesitar para usar
Linux se encuentran distribuidos por Internet, y una enorme cantidad
están disponibles en español. 
\end{quotation}


\begin{itemize}
\item  http://www.debian.org -- El Proyecto Debian es una asociación
de  personas  que  han  hecho  causa común  para  crear  un  sistema
operativo (SO)  libre. Este  sistema operativo  que hemos  creado se
llama Debian GNU/Linux, o simplemente Debian para acortar.
\item   http://www.redhat.es --  La  primera  distribución Linux  en
reorientarse hacia los usuarios finales.
\item  http://www.linux-mandrake.com/es/ -- Linux-Mandrake\texttrademark{} es
un amigable Sistema Operativo Linux. Es  muy fácil de usar, tanto en
el  hogar/oficina  como  en  servidores. Está  disponible  en  forma
gratuita en varios idiomas alrededor del mundo.
\item  http://www.ututo.org -- Un GNU/Linux Simple.
\item  http://www.linux-es.com -- Existen muchos lugares en Internet
dedicados a LINUX,  pero la mayoría de ellos están  en ingles. Estas
páginas  pretenden  ser  un  punto  de  partida  para  aquellos  que
necesitan encontrar información sobre este sistema y en la medida de
lo posible  se ha intentado que  la mayoría de enlaces  y contenidos
sean en castellano.
\item  http://www.gnu.org/home.es.html -- El Projecto GNU comenzó en
1984 para  desarrollar un sistema  operativo tipo Unix  completo, el
cual  es  software libre:  El  sistema  GNU. Variantes  del  sistema
GNU,  utilizando  Linux  como  kernel,  son  ampliamente  usadas,  y
aunque frecuentemente llamadas  ``Linux'', dichas variantes deberían
referirse más exactamente como sistemas GNU/Linux.
\item   http://lucas.hispalinux.es  --  Proyecto LuCAS  -  La  mayor
biblioteca en español dedicada a GNU/LiNUX de todo el planeta
\item   http://www.insflug.org  --  En  el INSFLUG  se  coordina  la
traducción {\tt\char`\"}oficial{\tt\char`\"} de documentos  breves, como los COMOs
y PUFs o  Preguntas de Uso Frecuente, las FAQs  en inglés. Esperamos
que la información que encuentre aquí le sea de utilidad.
\item  http://www.gnu.org/software/emacs/emacs.html --  Es un editor
de  pantalla y  ambiente  para cómputo  de  tiempo real,  extendible
y  personalizable. Ofrece  verdadero  Lisp  (finamente integrado  al
editor)  para escribir  extensiones  y proporciona  una interfaz  al
sistema de ventanas X.
\item  http://www.vim.org -- VIM es  una versión mejorada del editor
VI, uno de los editores de  texto estándar en los sistemas UNIX. VIM
añade muchas  de las  características que se  esperan en  un editor:
Deshacer ilimitado, coloreado de sintaxis, GUI, y mucho más.
\item    http://www.escomposlinux.org/sromero/linux/vim-tut.html  --
Usar VIM  (el editor),  de la  zarpa de Santiago  Romero. Vim  es el
típico  editor que  todos queremos  usar cuando  seamos mayores.  En
partícular parece  bastante complicado  al principio pero  cuando lo
usas no puedes vivir sin él :)
\item   http://www.escomposlinux.org/sromero/linux/mutt-tut.html  --
Usar MUTT (MailReader), del mismo autor que el anterior.
\item  http://www.escomposlinux.org/sromero/linux/ -- S.O.S. Linux.
\item  http://www.geocities.com/Athens/Temple/2269/ --  Tutorial de
C/C++
\item  http://www.fie.us.es/docencia/publi/JAVA/ -- Tutorial de Java
\item  http://apolo.us.es/CervanTeX/ -- Información {\LaTeX} en español
\item  ftp://ftp.cma.ulpgc.es/pub/software/{\TeX}/tex/latex2e/doc/ldesc2e/mix/ldesc2e.pdf -- Una descripción de {\LaTeX}, por Tomás Bautista y cia.
\item  http://www.lyx.org  --  Página del proyecto {\LyX} 
\item  http://www.octave.org  --  Página del proyecto Octave
\item  http://www.gnuplot.org  --  Página del proyecto Gnuplot
\item  http://www.r-project.org -- Página del proyecot R
\item  http://www-rocq.inria.fr/scilab/  --  Página del SciLab
\item  http://www.lysator.liu.se/~alla/dia/ --  Página del proyecto DIA
\item  http://www.gimp.org --  Página del GIMP
\end{itemize}





\section{Sobre este documento}

\begin{quotation}
 Este documento ha sido  escrito gracias a la iniciativa de
algunos  de  los  miembros  del  {\bfseries G}rupo  de  {\bfseries U}suarios  de
{\bfseries Li}nux de  {\bfseries C}anarias. El  propósito de este  documento, ha
sido el servir  de ayuda e introducción a Linux  a los alumnos del
{\bfseries C}urso  de {\bfseries I}ntroducción  a {\bfseries L}inux  para {\bfseries A}lumnos,
organizado  conjuntamente con  la  Facultad de  Matemáticas de  la
Universidad de La Laguna, en Tenerife (España) 
\end{quotation}






\begin{quotation}
 Este documento  se acoje a la La  Licencia General Pública
(GPL) 
\end{quotation}





\subsection{La Licencia General Pública (GPL)}

\begin{quotation}
 Software libre  significa entre otras cosas  que las licencias
de  los programas  no requieren  de un  pago para  su uso  ni para  su
distribución. Ello es posible gracias a  la GPL. GPL son las iniciales
de  General  Public  License,  Licencia Pública  General  cuyo  nombre
completo es  GNU GPL.  La GPL permite  que cualquiera  pueda extender,
adaptar o modificar  los programas cubiertos por  la licencia. También
permite  que distribuya  los resultados  de su  trabajo y  que incluso
cobre por ello.  La GPL obliga a  que el código fuente  de un programa
esté disponible con la distribución de  las copias de ese programa. De
este modo, el usuario puede modificar el programa para adaptarlo a sus
necesidades y puede vender o  distribuir copias de sus modificaciones,
siempre y  cuando el programa  modificado esté  también bajo la  GPL e
incluya los códigos fuente. 
\end{quotation}




\begin{quotation}
 La GNU/GPL te obliga a dar a los otros lo que tú has recibido.
El conocimiento que  a tí te ha beneficiado y  las aportaciones que tú
has hecho  a ese  conocimiento han de  estar también  disponibles para
otros. La  GPL te  prohibe transformar el  software libre  en software
propietario: toda modificación de software  GPL ha de continuar siendo
GPL. 
\end{quotation}


\begin{quotation}
 La GNU/GPL no significa que  no haya derechos de autor, que no
se reconozcan las autorías de los programas o las modificaciones a los
programas. Todo  lo contrario.  Todas las aportaciones  son protegidas
por los  derechos de autor.  Pero los  autores aceptan que  su trabajo
se  vea  modificado  y  adaptado  por otros,  siempre  y  cuando  esas
modificaciones sigan siendo libres y estén disponibles con los códigos
fuentes, para que puedan a su vez ser modificadas. 
\end{quotation}


\begin{quotation}
 Dado que los autores de  los programas los ponen a disposición
de  cualquiera libres  de cargas,  los  programas bajo  la GNU/GPL  no
tienen GARANTÍAS. Se  te ofrecen "tal cual" y lo  que suceda con ellos
cae dentro  de los riesgos que  tú asumes. Cada uno  es responsable de
los programas GNU/GPL que decide instalar y probar. 
\end{quotation}


\begin{quotation}
  ESTOS  APUNTES SE  SOMETEN  A  LA  GPL.  Se pueden  copiar  y
modificar estos apuntes  y se ofrecen cumpliendo lo  establecido en la
GNU/GPL,  por lo  que sus  copias y  modificaciones tienen  que seguir
estando disponibles y ser "copy left" (permitido copiar). 
\end{quotation}


\begin{quotation}
 Igualmente,  los autores admitimos y  agradeceremos toda clase
de sugerencias  para mejorar los  apuntes, pero no damos  garantías de
ellos... ;-) 
\end{quotation}


\begin{quotation}
 En GNU/Linux lo importante es  aprender. Y aprender es un acto
de voluntad.  Sin él, no hay  manual ni apuntes que  sirvan para nada.
\end{quotation}


\begin{quotation}
{\bfseries Referencias:}
\end{quotation}

\begin{itemize}
\item  GNU  GPL Versión 2, junio  de 1991. Versión oficial  en inglés.
Url: http://www.gnu.org/copyleft/gpl.html
\item    Traducción   no   oficial   al  español   de   la   GPL   por
Jesús   González  Barahona   y  Pedro   de  las   Heras  Quirós.   Muy
recomendable  si  no   te  desenvuelves  bien  con   el  inglés.  Url:
http://es.gnu.org/Licencias/gples.html
\item   Términos  de   la  licencia  GPL  y   GNU.  Interesante.  Url:
http://www.marquese.net/relatos/relatos/mvarios/linux/gpl.htm
\end{itemize}




\end{document}
