
  <sect>Editores de texto

      <sect1>Joe

<p>
<quote> El  primer editor que  suele aprenderse en Linux  es <tt/Joe/,
por  ser muy  sencillo y  rápido. Puede  usarse para  editar cualquier
fichero,  pero aquí  trataremos  su uso  básico  para editar  pequeños
textos,  ficheros de  configuración, pequeños  programas. Todos  estos
ficheros pueden editarse  con más comodidad con  editores más potentes
como  Emacs o  VIM  pero para  ello es  necesario  aprender a  usarlos
primero,  lo  cual  puede  no  resultar  tan  sencillo  como  aprender
<tt/Joe/.</quote>

<quote> Veremos sólo un par  de comandos de <tt/Joe/, simplemente como
editar un  fichero existente o  nuevo, guardarlo sin salir,  salir sin
guardarlo  y salir  guardándolo.  Para obtener  más información  sobre
otras opciones del editor existe  el comando de ayuda que explicaremos
luego. </quote>

<quote> El manejo  de <tt/Joe/ se basa en combinaciones  de teclas con
la tecla <tt/Control/. Denotaremos por  <tt/&lt;Ctrl&gt;x y/ a la combinación de
teclas que  se obtiene al  pulsar la tecla  <tt/Control/, seguidamente
(sin soltar la primera) pulsar la tecla <tt/x/ y después (soltando las
teclas anteriores)  pulsar la tecla  <tt/y/. Veamos un  rápido ejemplo
del uso de este editor. En un terminal ejecutamos: </quote>

<code>
$ joe prueba.txt
</code>

<quote>
Escribimos una frase sencilla, tal como:
</quote>

<code>
Si algo funciona, no lo toques.
</code>

<quote> Para  guardar el fichero  utilizamos la combinación  de teclas
<tt/&lt;Ctrl&gt;k s/  y entonces <tt/Joe/  nos preguntará  el nombre con  el que
queremos guardar el fichero. </quote>

<code>
Name of file to save (^C to abort): hola.txt
</code>

<quote>  Si pulsamos  ahora ahora  <tt/&lt;Ctrl&gt;c/ simplemente  cancelamos la
orden  de guardar  el fichero,  pero  no perdemos  su contenido.  Para
guardar  el fichero  pulsamos  <tt/Enter/, modificando  el nombre  del
fichero si lo deseamos. Ahora añadimos otra línea:</quote>

<code>
Si algo funciona, no lo toques.
Si algo funciona, y no sabes porqué, úsalo siempre.
</code>

<quote>  Ahora  saldremos  del   editor  <bf/guardando  los  cambios/,
mediante  la  combinación  de  teclas   <tt/&lt;Ctrl&gt;k  x/.  De  esta  manera
volveremos al prompt  del sistema siendo informados de  que el fichero
ha sido guardado. </quote>

<code>
File prueba.txt saved.
$
</code>

<quote> Como última maniobra, abrimos de nuevo el fichero, borramos la
última línea y salimos sin guardar los cambios. 
</quote>

<code>
$ joe prueba.txt
</code>

<quote>  Boramos la  última línea  como haríamos  en el  <tt/edit/ del
<tt/DOS/, y pulsamos  <tt/&lt;Ctrl&gt;c/ para salir sin guardar  los cambios. El
editor nos pedirá  confirmación antes de salir.  Podemos responder que
sí  queremos salir  pulsando <tt/y/,  o por  el contrario  cancelar la
maniobra  pulsando  <tt/n/  o  <tt/&lt;Ctrl&gt;c/. Decimos  que  sí  (<tt/y/)  y
volvemos al prompt del sistema.</quote>

<code>
Lose changes to this file (y,n,^C)? 
File hola.txt not saved.
$
</code>

<quote> Esto es lo mínimo que  debemos saber para editar con <tt/Joe/,
y con esto  nos conformaremos aquí pues en lo  sucesivo aprenderemos a
hacer operaciones más avanzadas con otros editores. Para conocer sobre
otras opcioens de este editor, se peude utilizar la opción <tt/&lt;Ctrl&gt;k h/.
</quote>

      </sect1>

      <sect1>Emacs 

<p>
<quote> <tt/Emacs/,  junto con  <tt/VI/, ha  sido uno  de los  primeros
editores  de texto  para UNIX.  A  pesar de  visualmente presentar  un
interfaz similar al de un editor  de texto corriernte, como podría ser
<tt/joe/, el  <tt/edit/ de MS-DOS, o  similar, lo cierto es  que tiene
muchisimas posibilidades que uno no atribuiría a un editor de texto en
modo consola. Por  ejemplo, el indentado automático  de código Pascal,
Java, C, o cualquier lenguaje para  el que haya escrito un módulo para
Emacs de  asistencia a  la programación,  nos ofrece  posibilidades de
trabajar con  CVS, enviar correo  electrónico, y un largo  etcétera de
posibilidades. Como anécdota cabe contar,  para que se hagan una idea,
el  manual de  GNU Emacs,  en  formato ASCII  ocupa cerca  de 1.1  MB.
</quote>

<quote>Hablemos  de cómo  manejarse con  los menús  de Emacs.  Existen
cientos de  combinaciones de  teclas en Emacs  que nos  permiten hacer
cualquier cosa sin ver un menú. Los usuarios expertos de Emacs valoran
esta posibilidad, pues a la hora de escribir con prisas, un menú puede
ser  algo  muy  incómodo.  Pero  para  ustedes  que  están  empezando,
recuerden: la tecla <tt/&lt;F10&gt;/ es su amiga.</quote>

<quote>La tecla  <tt/&lt;F10&gt;/ nos da  acceso a todos los  menús de
Emacs, menu archivo,  edición, cambio entre las  distintas ventanas de
edición de texto, etc.</quote>

<quote>Empezemos viendo como editar un  fichero de texto básico. En la
consola ponemos:</quote>

<code>
$ emacs prueba.c
</code>

<quote>y escribimos un programa común y corto:</quote>

<code>
#include <stdio.h>
int
main()
{
  printf(&quot;\nHola Mundo\n\n&quot;;
}
</code>

<quote>Como  podemos  apreciar, Emacs  hace  retroceder  el cursor  al
cerrar  los corchetes  y  los paréntesis,  para  indicarnos donde  los
abrimos  y tener  una  referencia  de cuáles  quedan  aún por  cerrar.
Probemos  ahora  a  guardar  nuestro pequeño  programa  C.  Para  ello
pulsamos <tt/&lt;F10&gt;/ y una vez pulsada <tt/&lt;F10&gt;/ vemos que
la tecla <tt/B/ nos daría acceso al menú buffers (que no son otra cosa
que las distintas ventanas que  tenemos abiertas), la <tt/F/ nos daría
acceso  al  menú  <tt/files/  (el cual  hace  practicamente  lo  mismo
que  el  menú archivo  de  cualquier  editor  de  texto, etc...  y  la
tecla  <tt/C/ nos  daría  acceso,  si las  tenemos  instaladas, a  las
posibilidades que  ofrece emacs para la  edición de código en  C. Como
solo queremos  guardar, pulsamos después de  <tt/&lt;F10&gt;/, <tt/S/.
Ya  lo tendríamos  guardado. Otra  cosa muy  importante, en  cualquier
programa es saber salir. Esto se hace con <tt/&lt;F10&gt;/, <tt/F/ y a
continuación la tecla  <tt/S/. Nos pregunta, si no lo  hemos hecho ya,
que  si  deseamos guardar.  Escribimos  <tt/yes/  (hay que  escribirlo
entero) o <tt/no/, y a continuación nos pregunta si realmente queremos
salir, a lo cual ahora si,  responderemos <tt/y/ para <tt/si/ o <tt/n/
para <tt/no/. </quote>

<quote>Una   función  muy   básica   tambien  es   la   de  buscar   y
reemplazar texto.  Esto puede  hacerse cómodamente con  la combinación
<tt/&lt;Ctrl&gt;-s/, dejando  pulsado la tecla  <tt/&lt;Control/&gt; y
pulsando la  <tt/s/, y a  continuación poniendo que queremos  buscar y
pulsando <tt/Enter/. Una vez  encuentre la primera coincidencia, puede
seguir  buscándose  el  mismo  patrón pulsando  de  nuevo  simplemente
<tt/&lt;Ctrl&gt;-s/. </quote>

<quote>Podemos saber  en todo momento que  estamos haciendo fijándonos
en la linea inferior de la pantalla de Emacs.</quote>

<quote>Para reemplazar trozos de texto, cosa también de supervivencia,
podemos hacerlo fácilmente de la siguiente forma:</quote>

<enum>
<item> Pulsamos &lt;F10&gt;.
<item> Pulsamos la S, que corresponde al menú Search.
<item> Nos sale el siguiente menú:
</enum>

<code>
Possible completions are:
S==&gt;Search...                      R==&gt;Regexp Search...
B==&gt;Search Backwards...            0==&gt;Regexp Search Backwards...
1==&gt;Repeat Search                  2==&gt;Repeat Regexp
3==&gt;Repeat Backwards               4==&gt;Repeat Regexp Backwards
5==&gt;Bookmarks                      F==&gt;Find Tag...  (M-.)
Q==&gt;Query Replace...  (M-%)        6==&gt;Query Replace Regexp...
</code>

<quote>Pulsamos <tt/Q/ y nos dice:</quote>

<quote><tt/Query replace:/  donde escribiremos lo que  queremos buscar
para ser reemplazado, y pulsamos <tt/Enter/.</quote>

<quote>Luego,  emacs nos  pregunta:  <tt/query replace  with: /  donde
escribiremos el  texto con  el cual  queremos sustituir,  y pulsaremos
enter.</quote>

<quote>En este menú,  encontramos también una serie  de comandos, como
<tt/query  regexp/, <tt/query  replace  regexp/, etc.,  que aunque  no
entraremos en ellos,  son muy interesantes, pues  nos permiten buscar,
no  ya patrones  de  texto concretos,  sino un  tipo  de búsqueda  más
avanzada por  medio de  expresiones regulares (regular  expressions en
inglés),  esto es,  &quot;todas  las  palabras que  empiecen  por c  y
terminen  por  j&quot; o  &quot;todas  las  mayúsculas cambiarlas  por
minúsculas&quot; en el caso de <tt/query replace regexp/.</quote>

      </sect1>

      <sect1>VI y VIM

<p>
<quote> <tt/VI/  es un editor  de texto visual, de  pantalla completa,
basado en  el editor de línea  <tt/ex/. Es un editor  poco intuitivo y
con mala  prensa entre los estudiantes  que dan sus primeros  pasos en
UNIX/Linux, pero por otra parte es  el editor favorito de los usuarios
avanzados y de muchos programadores. Es  además un editor que se puede
encontrar  en cualquier  sistema UNIX,  desde antiguas  estaciones Sun
Solaris o HP-UX hasta las  más recientes distribuciones de GNU/Linux o
FreeBSD, OpenBSD,  etc. <tt/VI/ es  además un editor muy  potente, que
permite  hacer complicadas  operaciones en  grandes ficheros  con unos
pocos  comandos, por  lo  que su  aprendizaje  puede ahorrarnos  mucho
tiempo. Otra  ventaja de  <tt/VI/ es  que al  ser tan  corriente suele
encontrarse incluso en disquetes de rescate. Lógicamente poco se puede
rescatar  si no  se  sabe manejar  el único  editor  disponible en  un
momento de emergencia. Pero el manejo de <tt/VI/ es realmente incómodo
si nos enfrentamos  a la versión clásica. Por ejemplo  no podemos usar
los  cursores para  movernos por  el texto,  debemos pasar  al llamado
&quot;modo comando&quot; y utilizar letras para movernos. </quote>

<quote>  En  este  curso  utilizaremos el  editor  <tt/VIM/.  <tt/VIM/
significa &quot;<bf/V/i  <bf/IM/proved&quot; (<bf/VI M/ejorado&quot;),
y como su  nombre indica es un clon (muy)  mejorado del clásico editor
<tt/VI/. <tt/VIM/ es bastante más amigable que <tt/VI/, ya que permite
un uso más intuitivo (p.ej. los cursores y otras teclas para moverse).
</quote>

<quote> Lo primero que debe aprenderse con <tt/VIM/ es la filosofía de
los dos modos de trabajo: el modo <tt/comando/ y el modo <tt/edición/.
El  modo comando  se utiliza  sólamente  para dar  órdenes al  editor,
decirles que haga cosas como borrar  una línea, buscar un patrón, ir a
una  determinada  línea,  guardar  el fichero,  salir,  etc.  El  modo
<tt/edición/ se utiliza  sólamente para escribir texto  en el fichero.
Es muy importante familiarizarse con esta filosofía de funcionamiento,
ya que resulta  imprescindible para cualquier operación  que se quiera
realizar con <tt/VIM/. </quote>

<quote> Para ejecutar este editor el comando es: </quote>

   <code>
   $ vi
   </code>

<quote> Aunque  conserva el nombre  de <tt/VI/ estamos  trabajando con
<tt/VIM/. Este comando  admite varias opciones que se  le pueden pasar
como  parámetros, p.ej.  el nombre  del fichero  que queremos  editar:
</quote>

   <code>
   $ vi fichero
   </code>

<quote> <tt/VIM/ comienza siempre en modo <tt/comando/, preparado para
realizar operaciones  sobre el  fichero. Una  de estas  operaciones es
pasar al modo  <tt/edición/ pulsando la tecla  <tt/i/ (Insertar). Para
pasar del modo  <tt/edición/ al como <tt/comando/ basta  con pulsar la
tecla de escape, que llamaremos <tt/&lt;ESC&gt;/. A continuación vamos
a editar  un pequeño  fichero de prueba  para familiarizarnos  con sus
comandos básicos. </quote>

<quote> Comenzamos invocando al editor desde la línea de comandos:
</quote>

   <code>
   $ vi prueba.txt
   </code>

<quote>  Veremos que  en  la última  línea de  la  consola aparece  lo
siguiente: </quote>

   <code>
&quot;prueba.txt&quot; [New File]                                        0,0-1 All
   </code>

<quote>  Esta  línea  es  la  <tt/barra  de  estado/  del  editor.  Es
aquí  donde  teclearemos algunos  comandos  y  donde aparecerá  cierta
información como, como  el modo en el que estamos,  la línea y columna
en la que estamos, el porcentaje del documento en el que estamos, etc.
</quote>

<quote> A  continuación pulsamos  la tecla <tt/i/  para pasar  al modo
<tt/edición/. Observamos que la barra  de estado se muestra diferente:
</quote>

   <code>
-- INSERT --                                                     0,1 All
   </code>

<quote> Tecleamos por ejemplo lo siguiente: </quote>

   <code> Lo pequeño es bello.  </code>

<quote> Cuando  tenemos algo  escrito, pulsamos  <tt/&lt;ESC&gt;/ para
pasar  al modo  <tt/comando/. Entonces  tecleamos la  orden <tt/:w/  y
pulsamos <tt/&lt;Enter&gt;/. Veremos como  la orden <tt/:w/ aparece en
la barra  de estado mientras  la tecleamos,  y luego al  ejecutarla se
muestra información sobre el resultado, en este caso información sobre
el fichero que acabamos de guardar. </quote>

   <code>
&quot;prueba.txt&quot; [New] 1L, 21C written                              1,20 All
   </code>

<quote>  Pasamos  nuevamente  al  modo  <tt/edición/  pulsando  <tt/a/
(observamos   la  diferencia   con   pulsar   <tt/i/)  y   continuamos
escribiendo: </quote>

   <code>
   ---
   Lo pequeño es bello.
   ---
   La  medida de programar es programar sin medida.
   ---
   Software is like sex, it's better when it's free.
   ---
   </code>

<quote> Observamos  como podemos movernos  libremente por el  texto en
modo <tt/edición/ utilizando los cursores,  las teclas de Inicio, Fin,
Av. Pag, Re.  Pag., etc. Esto no puede hacerse  en el <tt/VI/ clásico.
Volvemos a guardar el fichero con la orden <tt/:w/. </quote>

<quote>  Ahora pensemos  que  queremos eliminar  esas  líneas de  tres
guiones y  cambiarlas por líneas  de cinco asteriscos. Pasamos  a modo
<tt/comando/,  situamos el  cursor en  una  de esas  línas y  pulsamos
<tt/dd/. Veremos como  la línea entera desaparece.  Repetimos lo mismo
con  las otras  líneas.  Ahora  nos situamos  en  la  primera línea  y
pasamos a  modo <tt/edición/,  escribimos cinco asteriscos  y pulsamos
<tt/&lt;Enter&gt;/. Volvemos al modo  <tt/comando/, situamos el cursor
en la  nueva línea de  asteriscos y  pulsamos de nuevo  <tt/dd/, vemos
como la  línea desaparece. Situamos  el cursor  en el principio  de la
línea y pulsamos  <tt/P/, vemos como la línea que  habíamos borrado se
inserta <em/antes/ del  cursor. Si situamos el cursor  al principio de
la tercera  línea y  pulsamos <tt/p/  vemos como  la línea  se inserta
<em/después/ del  cursor. Añadimos las restantes  líneas de asteriscos
donde estaban las de guiones. </quote>

<quote> Para  deshacer cualquier operación realizada  pulsamos en modo
<tt/comando/ la tecla  <tt/u/. Para salir del  editor <em/sin/ guardar
el fichero se usa la orden  <tt/:q!/. Esta operación se suele realizar
con mucha frecuencia al principio,  cuando se comete algún error grave
como teclear  una palabra sin pasar  al modo <tt/edición/. En  el modo
<tt/comando/ cada  tecla tiene  su función, y  es diferente  además si
está en  mayúsculas que si  está en minúsculas.  Una regla de  oro con
<tt/VIM/ es: cuando no se sabe con qué comando se hace algo, no probar
teclas  al  azar.  Y  por  supuesto,  cuando  se  está  editando  algo
importante  guardar  el  fichero  cada con  frecuencia  con  la  orden
<tt/:w/, sobretodo en las primeras semanas de uso. </quote>


<quote> Con estos pocos comandos  es suficiente para la edición básica
de  textos  y programas.  En  la  tabla 1  se  resumen  estos y  otros
comandos: </quote>

<table loc="hbtp">
<tabular ca="lll">
 Comando  |Descripción@
 <tt/&lt;ESC&gt;/ |Mientras se teclea un comando, lo cancela@
 <tt/i/   |Inserta en la posición del cursor (pasa a modo comando)@
 <tt/a/   |Inserta tras la posición del cursor (pasa a modo comando)@
 <tt/I/   |Inserta al inicio de la línea (pasa a modo comando)@
 <tt/A/   |Inserta al final de la línea (pasa a modo comando)@
 <tt/x/   |Borra un caracter@
 <tt/r/   |Reemplaza un carater@
 <tt/u/   |Deshace la última operación  realizada (se puede repetir para
           deshacer varias operaciones)@
 <tt/U/   |Deshace los cambios efectuados sobre la línea actual@
 <tt/:q/  |Salir del editor@
 <tt/:x/  |Salir del editor <bf/guardando/ el fichero@
 <tt/:q!/ |Salir del editor <bf/sin guardar/ el fichero@
 <tt/:w/  |Guardar el fichero@
 <tt/:w nombrefichero/ |Guardar el fichero con nombre <bf/nombrefichero/@
 <tt/nG/  |Ir a la línea <tt/n/@
 <tt/$G/  |Ir al final del fichero@
 <tt/v/   |Activa el modo de selección (utiliza los cursores para
           seleccionar texto@
 <tt/y/   |Copia en memoria (buffer) el texto seleccionado@
 <tt/d/   |Borra el texto seleccionado, y lo copia en memoria (buffer)@
 <tt/p/   |Pega el texto copiado en memoria, tras la posición del cursor@
 <tt/P/   |Pega el texto copiado en memoria, en la posición del cursor@
 <tt/:syntax on/ |Activa el coloreado de sintaxis@
 <tt/:syntax off/ |Desactiva el coloreado de sintaxis@
 <tt>/palabra</tt>  |Busca la cadena <tt/palabra/ hacia adelante@
 <tt>?palabra</tt>  |Busca la cadena <tt/palabra/ hacia atrás@
 <tt/n/  |Muestra la  siguiente  conicidencia de  la última  búsqueda
</tabular>
<caption>Comandos básicos del VI.</caption>
</table>

      </sect1>

      <sect1>Otros editores <p> <quote> Los tres editores de texto que
hemos visto hasta ahora trabajan  en modo consola, sin entorno gráfico
ni ventanas, ni siquiera utilizan el ratón. Obviamente hay disponibles
muchos  más editores  de  texto en  Linux, tanto  de  consola como  de
entornos gráficos. Veamos dos editores  de entorno gráfico que vale la
pena presentar. </quote>


      
         <sect2>Kwrite

<p>
<quote> <tt/Kwrite/ es un potente editor de textos para KDE que cuenta
con  todo  lo  necesario  para  editar cualquier  tipo  de  texto,  es
configurable en todos los aspectos, desde  el tipo de letra con la que
se nos presentará el texto editado hasta las teclas de acceso rápido a
las funciones que implementa este editor. </quote>

<quote> Entre las características  que tiene destaca el reconocimiento
de la  sintaxis de muchos  lenguajes de programación (C,  C++, PASCAL,
FORTRAN, LATEX,  etc ...) el indentado  automático, deshacer, rehacer,
copiar, pegar, buscar, reemplazar y  un largo excétera de herramientas
útiles para la edición. </quote>

  </sect2>

         <sect2>gnotepad+

<p>
<quote>  <tt/Gnotepad+/ es  un  editor con  prácticamentes las  mismas
capacidades que  el kwrite  de KDE solo  que en este  caso es  para el
entorno  de GNOME  y no  tiene  tantas opciones  de reconocimiento  de
sintaxis como el kwrite, en  cambio tiene algunas herramientas para la
edición de código HTML interesantes  para el desarrollo de un proyecto
para la web de poca complejidad, como son la posibilidad de visualizar
como va quedando el código que vamos haciendo, botones que simplifican
la inserción  de ciertos elementos del  lenguaje html, etc ...  Una de
las  capacidades  interesantes del  gnotepad  es  la de  poder  editar
simutáneamente  varios ficheros  fuente con  un solo  editor y  varias
pestañas  de edición,  lo cual  resulta interesante  para no  tener el
escritorio lleno de ventanas y la memoria del sistema desperdiciada en
llevar cuatro procesos exactamente iguales. </quote>

	  </sect2>

      </sect1>

  </sect>




