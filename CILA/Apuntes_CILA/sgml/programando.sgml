
  <sect>Programando con GNU/Linux

    <sect1>C/C++ (GNU C Compiler)

      <sect2>Compilado y enlazado

<p>
<quote>A la hora  de generar un programa  en C se suele  pasar por dos
fases:</quote>

<descrip>

<tag/Compilar/Traduce cada archivo de C <tt/(*.c)/ de nuestro programa
a lenguaje máquina almacenando la traducción en los archivos de código
objeto <tt/(*.o)/.  Para ello  usamos el <bf/GCC  (GNU C  Compiler)/ a
través del comando <tt/gcc/

<tag/Enlazar/Une todos los archivos de código objeto para fundirlos en
el ejecutable de la aplicación. Se usa el comando <tt/ld/.

</descrip>

<quote>Por fortuna para nosotros <tt/gcc/  llama por defecto a <tt/ld/
ahorrándonos  tener que  realizar los  dos  pasos a  mano. Tomemos  el
siguiente programa:</quote>

  <code>
  /* holamundo.c .- Ejemplo 1 para el CILA 2001 */

  #include &lt;stdio.h&gt;

  int
  main (void)
  {
    puts (&quot;El que a buen árbol se arrima, buena sombra lo cobija.\n&quot;);
    return 0;
  }
  </code>

<quote> Y ejecutemos el comando: </quote>

  <code> 
  $ gcc holamundo.c 
  </code>

<quote>Si listásemos el contenido del directorio actual con el comando
<tt/ls/  veríamos  un  nuevo  archivo con  el  nombre  de  <tt/a.out/.
Ese  archivo  contiene  nuestro   programa  y  puede  ser  fácilmente
ejecutado.</quote>

  <code>
  $ ./a.out
  El que a buen árbol se arrima, buena sombra lo cobija.
  </code>

<quote>Es probable  que pocos programadores consideren  que <tt/a.out/
sea un  nombre apropiado para el  ejecutable de su aplicación.  Con el
fin  de  cambiar dicho  nombre  se  puede  utilizar la  opción  <tt/-o
&lt;nombre_ejecutable&gt;/.</quote>

  <code>
  $ gcc -o holamundo holamundo.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  </code>

<quote>Como podemos apreciar el ejecutable de nuestra aplicación ahora
se denomina <tt/holamundo/.</quote>

<quote>Una práctica muy habitual en la programación es dividir nuestro
código  en  varios  archivos,  cada  uno  especializado  en  un  tarea
determinada. Supongamos que disponemos del siguiente programa:</quote>

  <code>
  /* main.c .- Ejemplo 2 para el CILA 2001 */

  #include &quot;holafunc.h&quot;

  int
  main (void)
  {
    holafunc (&quot;buena sombra lo cobija&quot;);
    return 0;
  }
  </code>

  <code>
  /* holafunc.h .- Ejemplo 2 para el CILA 2001 */

  int holafunc (const char *str);
  </code>

  <code>
  /* holafunc.c .- Ejemplo 2 para el CILA 2001 */

  #include &lt;stdio.h&gt;
  #include &quot;holafunc.h&quot;

  int
  holafunc (const char *str)
  {
    return printf (&quot;El que a buen árbol se arrima, %s.\n\n&quot;, str);
  }
  </code>

<quote>Para generar nuestro programa  sólo debemos listar los archivos
que lo forman en la línea de comandos del <tt/gcc/.</quote>

  <code>
  $ gcc -o holamundo main.c holafunc.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  </code>

<quote>Cuando  <tt/gcc/ llama  a <tt/ld/  no solo  se están  enlazando
a  nuestro  programa   el  código  objeto  de  <tt/main.c/   y  el  de
<tt/holafunc.c/.  El compilador  sabe  que para  que nuestro  programa
funcione es  necesario que  esté enlazado a  una serie  de bibliotecas
estándar del sistema, así que las incluye automáticamente. Una de esas
bibliotecas es la <tt/libc/ cuya  documentación podemos obtener con el
comando:</quote>

  <code>
  $ info libc
  </code>

<quote>Funciones  como  <tt/fopen/,   <tt/malloc/,  <tt/printf/  y  en
general  todas las  del  C estándar  y  muchas más  se  definen en  la
<tt/libc/. Evidentemente  en nuestro sistema existen  bibliotecas para
toda clase de  tareas cuya documentación se  puede obtener recurriendo
a  la  ayuda  del  sistema.  Sin  embargo,  la  mayor  parte  de  esas
bibliotecas no se  enlazan automáticamente, así que nos  queda la duda
de  como  resolver  este  problema.  Por  ejemplo  vamos  a  modificar
<tt/holafunc.c/:</quote>

  <code>
  /* holafunc3.c .- Ejemplo 3 para el CILA 2001 */
  #include &lt;math.h&gt;
  #include &lt;stdio.h&gt;
  #include &quot;holafunc.h&quot;

  int
  holafunc (const char *str)
  {
    float a, b;

    printf (&quot;El que a buen árbol se arrima, %s,\n&quot;, str);

    a = 0.5;
    b = cos (a);
    return printf (&quot;y el coseno de %f es %f.\n\n&quot;, a, b);
  }
  </code>

<quote>Si  generamos <tt/holamundo/  veremos el  siguiente mensaje  de
error:</quote>

  <code>
  $ gcc -o holamundo main.c holafunc3.c
  /tmp/ccKSzM6q.o: In function `holafunc':
  /tmp/ccKSzM6q.o(.text+0x30): undefined reference to `cos'
  collect2: ld returned 1 exit status
  </code>

<quote>Ese mensaje nos indica que  la función <tt/cos()/ llamada desde
<tt/holafunc()/  no  está definida  puesto  que  se encuentra  en  una
biblioteca que no está siendo enlazada al programa. Para resolverlo se
emplea la opción <tt/-l&lt;nombre_biblioteca&gt;/ con la que se indica
la biblioteca adicional que debe ser enlaza al programa.</quote>

  <code>
  $ gcc -lm -o holamundo main.c holafunc3.c
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija,
  y el coseno de 0.500000 es 0.877583.
  </code>

<quote>Al especificar <tt/-lm/ se enlaza la biblioteca <tt/libm/ (como
vemos no hace falta poner el <tt/lib/ cuando se indica el nombre de la
biblioteca)  que contiene  la defunción  de <tt/cos()/.  Es importante
destacar  que  el  enlazador  sólo  busca  bibliotecas  en  una  serie
de  directorios estándar  de  nuestro sistema.  Por ejemplo  <tt/libm/
se  encuentra en  <tt>/usr/lib/</tt>  que es  un directorio  estándar.
Si  deseamos  enlazar  bibliotecas   situadas  en  otros  directorios,
como  por  ejemplo  el  directorio  actual,  debemos  usar  la  opción
<tt/-L&lt;ruta_biblioteca&gt;/.  Por  ejemplo   el  siguiente  comando
enlaza a nuestro programa una  biblioteca de nombre <tt/libpropia/ que
se encuentra en el directorio actual:</quote>

  <code>
  $ gcc -L. -lm -lpropia -o holamundo main.c holafunc3.c
  </code>

<quote>En  caso  de  que  prefiramos  utilizar  el  enlazador  <tt/ld/
directamente se utiliza la opción  <tt/-c/ con el compilador <tt/gcc/.
De esa manera le informamos de  que sólo queremos que genere el código
objeto. Probemos a generar el código objeto para cada archivo:</quote>

  <code>
  $ gcc -c main.c
  $ gcc -c holafunc3.c
  </code>

<quote>Ahora  tenemos  dos  nuevos  archivos  denominados  <tt/main.o/
y  <tt/holafunc3.o/  que  se  corresponden  con  el  código  objeto  de
<tt/main.c/ y  <tt/holafunc3.c/ respectivamente.  La parte  positiva de
esto es que ahora podemos  enlazar en nuestra aplicación código objeto
generado  por  otros lenguajes  como  <tt/Fortran/  o <tt/Pascal/.  El
lado  complicado  es que  debemos  indicarle  a  mano al  <tt/ld/  que
enlace  a  nuestro  programa  las bibliotecas  estándar  del  sistema,
puesto  que él  no  lo  hace automáticamente.  Dado  que  se trata  de
un  aspecto  avanzado  del  uso   del  compilador  nos  quedaremos  en
saber  que si  generamos  la  primera aplicación  de  ejemplo de  este
capítulo,  o cualquier  otra  aplicación  sencilla, añadiendo  <tt/-v/
a  la  línea  de  comandos  del <tt/gcc/  dispondremos,  al  final  de
la  salida por  pantalla  del  programa, de  la  lista de  bibliotecas
estándar. En cualquier caso el proceso está perfectamente explicado en
<tt>http://www.chiralcomp.com/support/mixing_f77_c_cpp/</tt>. </quote>

<quote>Otro  uso  interesante  del  <tt/ld/ es  para  generar  nuestras
propias bibliotecas  de enlace  dinámico. Ahora  que disponemos  de un
archivo <tt/holafunc.o/ ejecutemos lo siguiente: </quote>

  <code>
  $ ld -shared -lm -o libholafunc.so holafunc3.o
  </code>

<quote>Si listamos  el contenido del directorio  observaremos un nuevo
archivo  denominado <tt/libholafunc.so/  que  es  nuestra librería  de
enlace  dinámico. Dicha  biblioteca puede  se utilizada  por cualquier
aplicación del sistema si la enlazamos como hemos aprendido.</quote>

  <code>
  $ gcc -L. -lholafunc -o holamundo main.c
  </code>

<quote>A  diferencia  de  ejemplos  anteriores,  nuestro  programa  no
funcionará  si  no  disponemos  de  <tt/libholafunc.so/.  Sin  embargo
cualquier  programa futuro  podrá  utilizar las  funciones de  nuestra
biblioteca. El  inconveniente de crear bibliotecas  de enlace dinámico
es que hay que instalarlas en  algún directorio donde <tt/ld/ sepa que
hay bibliotecas (p.ej. <tt>/usr/lib</tt>), pero la labor de instalar o
desinstalar  bibliotecas en  el  sistema, así  como  la de  configurar
<tt/ld/ para que las busque es  del Sr. root. Por ello si ejecutáramos
ahora nuestro programa,  este no funcionaría puesto  que sería incapaz
de encontrar  <tt/libholafunc.so/. Para  que esto  no sea  así debemos
definir la variable de entorno $LD_LIBRARY_PATH con la ruta de nuestra
biblioteca.</quote>

  <code>
  $ export LD_LIBRARY_PATH=./
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija,
  y el coseno de 0.500000 es 0.877583.
  </code>

      </sect2>

      <sect2>Introducción al Make

<p>
<quote>Es evidente que  utilizar la línea de  comandos resulta molesto
incluso cuando  se dispone  de unos pocos  archivos de  código fuente.
Para ayudar en  dichas tareas se utiliza el comando  <tt/make/. Con el
objetivo  de que  funcione  es  necesario disponer  de  un archivo  de
nombre <tt/Makefile/  en el  directorio de  nuestro código  fuente. El
archivo  debe  contener  reglas  que le  indiquen  al  <tt/make/  como
generar  la  aplicación. Un  ejemplo  de  <tt/Makefile/ puede  ser  el
siguiente:</quote>

  <code>
  # Makefile .- Ejemplo para el CILA 2001.

  CC = gcc
  CFLAGS = -g -Wall
  LFLAGS = -lm

  OBJECTS = main.o holafunc3.o
  INCLUDES = holafunc.h

  holamundo: $(OBJECTS)
	$(CC) $(LFLAGS) -o $@ $^

  $(OBJECTS): %.o : %.c $(INCLUDES)
	$(CC) -c $(CFLAGS) -o $@ $&lt;
	
  clean:
	rm -f *~ $(OBJECTS)

  clean_all: clean
  	rm -f holamundo
  </code>

<quote>Las  primeras líneas  se  utilizan para  definir variables  que
serán  utilizadas  en  el  resto de  nuestro  programa.  Por  ejemplo,
definimos en <tt/CC/  el compilador a utilizar, es  decir el <tt/gcc/,
mientras que  las variables <tt/CFLAGS/ y  <tt/LFLAGS/ especifican las
opciones para el compilador y el enlazador respectivamente. En nuestro
caso indicamos con  <tt/-lm/ que queremos enlazar  la biblioteca libm,
con  <tt/-g/  que deseamos  incluir  el  código  de depuración  en  el
ejecutable de nuestro programa y con <tt/-Wall/ que el compilador debe
avisarnos a la más mínima sospecha de un posible error en el programa.
Por  último  se listan  en  <tt/OBJECTS/  el  nombre de  los  archivos
de  código objeto  <tt/(*.o)/  que formarán  nuestra  aplicación y  en
<tt/INCLUDE/  los includes  <tt/(*.h)/ de  nuestro código  fuente. Las
siguientes líneas  del <tt/Makefile/  especifican los  <em/targets/ u
objetivos de la ejecución del <tt/make/.</quote>

  <code>
  holamundo: $(OBJECTS)
	$(CC) $(LFLAGS) -o $@ $^
  </code>

<quote>Indica que  el programa  <tt/holamundo/ depende de  disponer de
los  archivos de  código objeto  listados en  <tt/OBJECTS/ y  que para
generarlo debemos enlazarlos con el programa especificado en <tt/CC/ y
con las opciones de <tt/LFLAGS/. Para generar <tt/holamundo/ basta con
ejecutar: </quote>

  <code>
  $ make holamundo
  </code>

<quote>Puesto que <tt/holamundo/ es el primer target del <tt/Makefile/
también  es el  target por  defecto. Así  que se  obtienen los  mismos
resultados si ejecutamos:</quote>

  <code>
  $ make
  </code>

<quote>Aunque ya  hemos especificado la dependencia  de <tt/holamundo/
respecto de  los archivos de  código objeto se hace  necesario indicar
como  se obtienen  dichos  archivos. El  siguiente  target indica  ese
proceso.</quote>

  <code>
  $(OBJECTS): %.o : %.c $(INCLUDES)
	$(CC) -c $(CFLAGS) -o $@ $&lt;
  </code>

<quote>El último target permite  borrar todos los archivos intermedios
presentes  en el  directorio. Eso  incluye  a los  archivos de  código
objeto, que  una vez creada  la aplicación  ya no tiene  utilidad, así
como los archivos temporales que dejan algunos editores. Se ejecuta de
la siguiente manera:</quote>

  <code> $ make clean </code>

<quote>También podemos borrar todos los archivos generados por nuestro
<tt/Makefile/, incluida la aplicación.</quote>

  <code> $ make clean_all </code>

<quote>Evidentemente  este <tt/Makefile/  puede extenderse  con nuevos
targets que  se encarguen  de generar la  documentación de  ayuda, que
generen bibliotecas  de enlace dinámico  con las funciones de  uso más
frecuente,  que  generen otros  ejecutables  que  formen parte  de  la
aplicación e incluso que empaqueten  nuestro programa y lo dejen listo
para su instalación en cualquier sistema.</quote>

      </sect2>

      <sect2>Depurando la aplicación

<p>
<quote>Se suele decir que el 10% del tiempo de desarrollo de un programa
se dedica a la codificación y el 90% restante a la depuración. Al margen
de que sea cierto o no la verdad es que es de vital importancia disponer
de las herramientas adecuadas para corregir los errores del software en
un tiempo razonable.</quote>

<quote>La  primera  recomendación  es dejar  que  <tt/lclint/  analice
nuestro  código para  que busque  y notifique  cualquier inconsistencia.
Es  importante  destacar  que  dicho programa  es  mucho  más  potente
detectando posibles errores que  el analizador sintáctico del <tt/gcc/
debido  a  que  el  compilador  asume  que  ya  hemos  pasado  nuestro
código por  un programa  como <tt/lclint/.  Esa suposición  permite al
<tt/gcc/ realizar  ciertas optimizaciones que mejoran  su velocidad de
compilación.</quote>

  <code>
  $ lclint main.c holafunc.c
  </code>

<quote>Si  disponemos de  nuestro programa  perfectamente compilado  y
observamos que presenta  algún error del que no  sabemos determinar su
origen,  significa que  ha llegado  la hora  del depurador.  GNU/Linux
dispone del  GNU Debugger bajo  el comando <tt/gdb/. Para  usarlo sólo
debemos ejecutarlo  especificando el nombre  del programa en  la línea
de  comandos;  y  haber  compilado  nuestro  programa  con  la  opción
<tt/-g/.</quote>

  <code>
  $ gdb holamundo
  GNU gdb 19990928
  Copyright 1998 Free Software Foundation, Inc.
  GDB is free software, covered by the GNU General Public License, and you are
  welcome to change it and/or distribute copies of it under certain conditions.
  Type &quot;show copying&quot; to see the conditions.
  There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
  This GDB was configured as &quot;i686-pc-linux-gnu&quot;...
  (gdb) 
  </code>

<quote>En ese  momento tendremos al  <tt/gdb/ esperando alguno  de los
comandos de depuración. A continuación  disponemos de una lista de los
comandos más básicos. </quote>

<descrip>

<tag/break/Situa un  punto de ruptura  en la línea o  función indicada
como argumento.

<tag/continue/Continua  la ejecución  de un  programa que  está siendo
depurado y se encuentra detenido en un punto de ruptura.

<tag/display  &lt;exp&gt;/Muestra el  valor de  la expresión  <tt/exp/
cada vez que el programa se detiene.

<tag/help/Lista las clases  de comandos disponibles. Si  el comando va
seguido por un nombre de clase  se listan los comandos de dicha clase.
Si va seguido  por un nombre de comando se  muestra una ayuda completa
del comando indicado.

<tag/list/Lista   una   línea   o    función   especificada.   Si   el
comando   va  seguido   del  nombre   de  una   función,  el   comando
muestra   dicha   función.   Si   va   seguido   de   un   número   de
línea,  muestra  esa  línea.  En   programas  de  varios  archivos  se
puede  utilizar  <tt/&lt;nombre_archivo&gt;:&lt;nombre_funcion&gt;/  o
<tt/&lt;nombre_archivo&gt;:&lt;numero_línea&gt;/   para   listar   los
contenidos de un  archivo particular. Si no  se especificar argumentos
se  lista desde  la última  línea mostrada;  y si  se especifican  dos
números  de línea  separados  por  una coma,  se  muestran las  líneas
comprendidas en el intervalo.

<tag/next/Ejecución  paso  a  paso   pero  ignorando  las  llamadas  a
funciones.

<tag/print &lt;exp&gt;/Muestra el valor de la expresión <tt/exp/ en el
punto actual.

<tag/quit/Salir del <tt/gdb/.

<tag/run/Inicia la ejecución del  programa. Los argumentos del comando
son los argumentos que se le pasan al programa.

<tag/step/Ejecución paso a paso incluso  de las funciones llamadas por
el programa.

<tag/undisplay &lt;exp&gt;/Deja  de mostrar  el valor de  la expresión
<tt/exp/ cada vez que el programa se detiene.

</descrip>

<quote>El número  de comandos es mucho  más grande pero basta  con los
anteriores para agilizar enormemente  nuestro trabajo. Una alternativa
a  todo  esto  es  usar  el <tt/ddd/  que  se  puede  considerar  como
una  interfaz  gráfica  para  el  <tt/gdb/. Funciona  sobre  las  X  y
su  uso  es  semejante  a  de  los  depuradores  existentes  en  otras
plataformas.</quote>

      </sect2>

      <sect2>¿Y que pasa con el C++?
      
<p>
<quote>A  la hora  de compilar  código en  C++ <tt/(*.C,  *.cc, *.cpp,
*.c++, *.cp,  *.cxx)/ se utiliza  el comando <tt/g++/.  Básicamente se
encarga de ejecutar  el <tt/gcc/ habilitando el C++  como lenguaje por
defecto y  añadiendo las bibliotecas  estándar del  C++ en la  fase de
enlazado. Por tanto todo lo  explicado para <tt/gcc/ es aplicable para
el <tt/g++/. Y si no veamos el siguiente código de ejemplo:</quote>

  <code>
  // main.cc .- Ejemplo 5 para el CILA 2001

  #include &quot;saludo.h&quot;

  int
  main (void)
  {
    saludo hola (&quot;El que a buen árbol se arrima, buena sombra lo cobija.\n\n&quot;);
  
    hola.print ();
    return 0;
  }
  </code>

  <code>
  // saludo.h .- Ejemplo 5 para el CILA 2001

  class saludo
  {
  public:
    saludo (const char *str);
     ñsaludo ();

    void print (void);

  private:
    const char *msg;
  };
  </code>

  <code>
  // saludo.cc .- Ejemplo 5 para el CILA 2001

  #include &lt;iostream.h&gt;
  #include &quot;saludo.h&quot;

  saludo::saludo (const char *str):
  msg (str)
  {
  }

  saludo::ñsaludo ()
  {
  }

  void
  saludo::print (void)
  {
    cout << msg;
  }
  </code>

<quote>El cual  se genera de  forma semejante  al caso de  trabajar en
leguaje C.</quote>

  <code>
  $ g++ -o holamundo main.cc saludo.cc
  $ ./holamundo
  El que a buen árbol se arrima, buena sombra lo cobija.
  </code>

<quote>Con  todo  esto se  puede  decir  que  ya estamos  hechos  unos
<em/Linux Programmers/ por lo que  sólo queda navegar un poco, escoger
el <em/proyecto de software libre/ que  más nos guste, o disguste, y a
colaborar <tt/:D/</quote>

      </sect2>

  </sect1>

  <sect1>Pascal (FreePascal)

<p>
<quote>  El lenguaje  de programación  Pascal es  sencillo y  bastante
didáctico, por  lo que se  suele enseñar en  el primer año  de algunas
carreras técnicas como Matemáticas,  Física o Informática. Normalmente
estos  cursos  o asignaturas  de  programación  tratan de  enseñar  al
estudiante los  conceptos básicos  de la programación  de computadores
sin entrar en demasiados detalles acerca del funcionamiento interno de
los mismos. En este capítulo aprenderemos las herramientas básicas que
se encuentran  disponibles en GNU/Linux  para programar en  Pascal. El
compilador que  utilizaremos está siendo desarrollado  por el proyecto
<bf/Free Pascal/, que proporciona  un buen compilador de Pascal
para múltiples plataformas, entre éstas GNU/Linux, MS-DOS, MS Windows,
Amiga, MaC OS y otras.</quote>

<quote> Comenzaremos  escribiendo un ejemplo muy  sencillo de programa
en  Pascal,  el típico  &quot;Hola  Mundo&quot;.  En cualquier  editor
escribimos  el  siguiente   código  y  lo  guardamos   con  el  nombre
<tt>HolaMundo.pas</tt> </quote>

<code>
{ Ejemplo 1 de Pascal para CILA }

Program HolaMundo;

Begin
  writeln ('Hola Mundo');
End.
</code>

<quote> Para compilar un programa  escrito en Pascal con el compilador
de FreePascal  utilizamos el  comando <tt/ppc386/ del  siguiente modo:
</quote>

<code>
$ ppc386 HolaMundo.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo.pas
Assembling holamundo
Linking holamundo
7 Lines compiled, 0.3 sec

$ ls
holamundo2    HolaMundo2.pas  holamundo2.o
</code>

<quote>  Como podemos  apreciar  en los  mensajes  del compilador,  él
mismo  se  encarga  de  compilar,  ensamblar  y  enlazar  el  programa
para  generar  el  fichero  ejecutable  <tt/holamundo/.  Para  cambiar
el   nombre   del  ejecutable   resultante   se   utiliza  la   opción
<tt/-o&lt;nombredelejecutable&gt;/ (sin dejar  espacio entre la <tt/o/
y el nombre del ejecutable.</quote>

<code>
$ ppc386 -oHolaMundo HolaMundo.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo.pas
Assembling HolaMundo
Linking HolaMundo
7 Lines compiled, 0.3 sec

$ ls
HolaMundo    HolaMundo2.pas  holamundo2.o
</code>

<quote>  Para ejecutar  el programa  resultante, recordar  que debemos
poner <tt>./</tt> delante del nombre del ejecutable: </quote>

<code>
$ HolaMundo
bash: HolaMundo: command not found
$ ./HolaMundo
Hola Mundo
</code>

<quote> Veamos ahora un ejemplo del uso de las &quot;unidades&quot; en
Pascal.  El  concepto de  unidades  en  Pascal  es equivalente  al  de
librerías en C,  se trata de ficheros binarios que  obtenemos a partir
de código fuente separado y luego enlazamos con el programa principal.
Esto permite  dividir el código  de un  programa en varios  ficheros y
evita tener que compilar todo el programa cada vez que se modifica una
función. Con el  uso de unidades basta con recompilar  la unidad en la
que se modifica el código fuente y volverla a enlazar con el programa.
A diferencia del Borland Pascal,  el compilador Free Pascal utiliza la
extensión <tt/ppu/ (en  lugar de <tt/tpu/) para  los ficheros binarios
de unidades. </quote>

<quote>
Tenemos para este ejemplo dos ficheros de código fuente en Pascal, 
<tt/HolaMundo2.pas/ y <tt/saludos.pas/.
</quote>

<code>
{ Ejemplo 2 de Pascal para CILA }
{    Fichero: HolaMundo2.pas    }

Program HolaMundo2;
Uses
  Crt, Saludos ;
Var
  nombre : string ;
Begin
  TextColor(13) ;
  write ('¿Cómo te llamas? ') ;
  TextColor(15) ;
  readln (nombre) ;
  TextColor(14) ;
  Saluda (nombre) ;
  TextColor(7) ;
End.
</code>

<code>
{ Ejemplo 2 de Pascal para CILA }
{    Fichero: saludos.pas       }

Unit Saludos ;

Interface

Uses Crt ;

Procedure Saluda ( mensaje : string ) ;

Implementation

Procedure Saluda ( mensaje : string ) ;
Begin
  writeln('Hola ', mensaje);
End;

Begin
End.
</code>

<quote>Cuidado  con un  detalle:  Los nombres  de  las unidades  deben
coincidir  con  el  nombre  del  fichero en  el  que  están  escritas,
i.e.  la  unidad <tt/Saludos/  no  se  puede  escribir en  un  fichero
llamado  <tt/Otronombre.pas/.  Además,  los  ficheros en  los  que  se
implementan las  unidades conviene que tengan  el nombre completamente
en  <bf/minúsculas/.  De  lo  contrario el  compilador  FreePascal  no
encontrará  la  unidad  al  compilar  un programa  que  la  use,  pero
podremos aún  compilarla manualmente. El siguiente  ejemplo ilustra la
situación:</quote>

<code>
$ ls
HolaMundo2.pas  saludos.pas

$ mv saludos.pas otronombre.pas

$ ls
HolaMundo2.pas  otronombre.pas

$ ppc386 otronombre.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling otro.pas
otro.pas(4,6) Error: Illegal unit name: SALUDOS
otro.pas(10,1) Fatal: There were 1 errors compiling module, stopping

$ mv otronombre.pas Saludos.pas

$ rm *.o *.ppu

$ ls
HolaMundo2.pas  Saludos.pas

$ ppc386 HolaMundo2.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
HolaMundo2.pas(6,16) Fatal: Can't find unit SALUDOS

$ ppc386 Saludos.pas 
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling Saludos.pas
Assembling saludos
18 Lines compiled, 0.0 sec

$ ppc386 HolaMundo2.pas
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
Assembling holamundo2
Linking holamundo2
17 Lines compiled, 0.0 sec

$ ls
holamundo2    HolaMundo2.pas  Saludos.pas
holamundo2.o  saludos.o       saludos.ppu

$ ./holamundo2
¿Cómo te llamas? Pepe
Hola Pepe

$ mv Saludos.pas saludos.pas

$ rm *.o *.ppu

$ ls
HolaMundo2.pas  saludos.pas

$ ppc386 HolaMundo2.pas 
Free Pascal Compiler version 1.0.4 [2001/08/31] for i386
Copyright (c) 1993-2000 by Florian Klaempfl
Target OS: Linux for i386
Compiling HolaMundo2.pas
Assembling holamundo2
Linking holamundo2
18 Lines compiled, 0.0 sec

$ ls
holamundo2    HolaMundo2.pas  Saludos.pas
holamundo2.o  saludos.o       saludos.ppu

$ ./holamundo2
¿Cómo te llamas? Pepe
Hola Pepe
</code>

<quote>  Con esta  breve presentación  ya sabemos  lo suficiente  para
compilar prácticas en Pascal, sólo  queda aprender el lenguaje y pasar
muchas  horas  escribiendo  programas  para llegar  a  ser  auténticos
programadores ;-) </quote>

  </sect1>

    <sect1>Fortran 77 (GNU Fortran) 

<p> <quote>El  lenguaje de programación <tt/Fortran/  estaba orientado
puramente  al   cálculo  matemático,   y  sigue  siendo   un  lenguaje
importante en  entornos científicos.  Su nombre viene  de <bf/For/mula
<bf/Tran/slator,  ya que  su mayor  uso era  traducir las  fórmulas de
cálculo matemático al lenguaje de  las máquinas. Desde sus principios,
el lenguaje Fortran ha tenido una sintaxis particular, adaptada al uso
de  tarjetas  perforadas. En  la  actualidad,  Fortran se  utiliza  en
asignaturas de Cálculo en carreras técnicas como Matemáticas, Física y
algunas ingenierías. </quote>

<quote>  Utilizaremos   aquí  el   compilador  <bf/GNU   Fortran  77/,
compatible  con  la  mayoría  del   lenguaje  básico  de  Fortran  77,
suficiente para las  prácticas de programación en  Fortran. Veamos una
vez más el  típico ejemplo de &quot;HolaMundo&quot;. En  el editor que
más nos guste, escribiremos el siguiente código Fortran: </quote>

<code>
* Ejemplo 1 de Fortran 77 para CILA

      Program HolaMundo
      
      write(*.5) Hola Mundo
      
 5    format(//,2x,a,/)

      stop
      end
</code>

<quote> Para compilar el programa  utilizamos el comando <tt/g77/ como
si fuera el <tt/gcc/. El compilador <tt/g77/ también produce la salida
por defecto  en un ejecutable  llamado <tt/a.out/, opción  que podemos
modificar con la opción <tt/-o nombredelejecutable/. </quote>

<code>
$ ls
HolaMundo.for

$ g77 HolaMundo.for

$ ls
a.out  HolaMundo.for

$ g77 -o HolaMundo HolaMundo.for

$ ls
HolaMundo  HolaMundo.for

$ ./HolaMundo


  Hola Mundo

</code>

<quote>  Veamos  ahora  también   como  podemos  dividir  un  programa
en  varios  ficheros  de  código   fuente.  En  el  editor  escribimos
los   siguientes  códigos   fuente  Fortran   y  los   guardamos  como
<tt/HolaMundo2.for/ y <tt/Saludos.for/ respectivamente. </quote>

<code>
* Ejemplo 2 de Fortran para CILA
* Fichero: HolaMundo2.for

      Program HolaMundo2
      character(10) saludo

      saludo = 'Mundo'

      call saluda (saludo)

      stop
      end
</code>

<code>
* Ejemplo 2 de Fortran para CILA
* Fichero: saludos.for

      Subroutine saluda(mensaje)
      character(10) mensaje

      print 5, 'Hola ', mensaje

 5    format (//,2x,a,a,/)

      return
      end
</code>

<quote>  Para  generar  ahora  el  ejecutable  utilizamos  el  comando
<tt/g77/  dándole ambos  ficheros  como argumentos.  En general,  para
compilar un  programa Fortran escrito  en varios ficheros  bastará con
utilizar el comando de la forma <tt/g77 -o ejecutable fichero1.for ...
ficheroN.for/ </quote>

<code>
$ ls
HolaMundo2.for  Saludos.for

$ g77 -o HolaMundo2 HolaMundo2.for Saludos.for

$ ls
HolaMundo2  HolaMundo2.for  Saludos.for

$ ./HolaMundo2


  Hola Mundo

</code>

<quote>  Estos  pocos  comandos  serán  suficientes  para  compilar  y
ejecutar las  prácticas de Fortran  77 que podamos necesitar,  pero no
piensen  que  es  verdad  eso  de  que  <em/&quot;Real  programers  do
Artificial Inteligence programs in Fortran&quot;/ ;-)</quote>

    </sect1>

    <sect1>Java (JDK 1.3) 

<p>
<quote> Java  es un  lenguaje de  alto nivel  y de  propósito general.
Al  principio   fue  desarrollado  en  los   laboratorios  de  <em/Sun
Microsystems/ para servir en aparatos  de electrónica de consumo, como
videoteléfonos,  set boxes  (descodificadores), o  aparatos similares,
pues pretendía hacerse un lenguaje  lo más independiente posible de la
plataforma en la que fueran a  ser ejecutados los programas hechos con
él. </quote>

<quote>  A  diferencia  de   otros  muchos  lenguajes  compilados,  el
compilador  de  java  no  genera  ficheros  ejecutables.  Genera  unos
ficheros  con  extensión  <tt/.class/ llamados  <em/bytecodes/.  Estos
ficheros posteriormente podrán ser  ejecutados mediante la <em/Máquina
Virtual Java/  (JVM en inglés),  que es  la encargada de  ejecutar los
programas de java. </quote>

<quote> Esto, que  a primera vista puede parecer tedioso  e inútil, es
una gran ventaja para la portabilidad del código, pues cada plataforma
tiene su  propia Máquina Virtual Java:  Apple Mac OS tiene  una, Linux
tiene otra, Windows  otra, Amiga OS también, etc. Esto  implica que si
desarrollamos un programa en un iMac  con Linux, el amigo que tenga un
potente servidor SUN podrá ejecutar  nuestra aplicación hecha en Java,
al  igual que  nosotros podremos  utilizar el  complicado programa  de
calculo de estructuras  que otra persona ha desarrollado en  su Pc con
Windows en el trabajo. </quote>

<quote> Realmente, Java no es tan bonito como lo estamos pintando. Uno
de sus principales puntos débiles es  que no es demasiado rápido, y es
bastante  caprichoso en  cuestiones de  recursos de  hardware. Ademas,
existen  dos maquinas  virtuales Java,  la de  Microsoft y  la de  SUN
Microsystems, que presentan algunas incompatibilidades. </quote>

<quote> Pero  su principal  ventaja es la  impresionante portabilidad,
así como su utilidad en  campos como Internet (donde principalmente se
usa en la actualidad), en servidores web. </quote>

<quote>  Los  programas  java  podemos  clasificarlos  basicamente  en
tres categorias: <em/applets/,  <em/servlets/ y aplicaciones <em/stand
alone/. </quote>

<itemize>

<item>  Los  <em/applets/ son  pequeñas  aplicaciones  creadas con  el
proposito de ser incluidas en paginas web. Cuando el cliente, desde su
navegador web con  java incorporado pide esa pagina web,  el applet se
descarga  a su  ordenador donde  comienza su  ejecución. El  navegador
tiene la maquina virtual java incorporada.  Los applets son el tipo de
aplicaciones  java que  mas restricciones  de seguridad  presentan. No
pueden acceder  al sistema de  archivos local fuera del  directorio en
que  se  ejecutan,  no  pueden  abrir  ventanas  adicionales  sin  que
estas aparezcan  señalizadas con el indicativo:  &quot;Warning: applet
window&quot;, ni hacer muchas cosas que podrian ser perjudiciales para
nuestro ordenador.

<item>  Las  aplicaciones  que  a  nivel  de  seguridad  permiten  mas
libertades que los applets 

<item> Los  <em/servlets/ son una  especie de applets que  se ejecutan
solo en  el servidor  web cuando  uno pide una  pagina, y  que generan
dinamicamente  paginas  a  partir  de fuentes  como  bases  de  datos,
terceros programas que recopilan informacion, etcetera.

</itemize>

<quote> A nivel visual, java tiene dos grupos de controles, widgets, o
como prefiramos llamarlos  (no son otra cosa que los  campos de texto,
formularios, botones, etc.): </quote>

<itemize>

<item> El  Java AWT, (Advanced  Window Toolkit), obsoleto  y mantenido
solo por compatibilidad en versiones actuales de java.

<item>  El conjunto  de  widgets <bf/Java  Swing/,  que presenta  unos
controles mucho mas esteticos y es mucho mas flexible.

</itemize>

<quote>  Ambos  conjuntos  de widgets  proporcionan  una  presentación
uniforme  independiente  de  la  plataforma en  que  sean  ejecutados.
Además,  otro  de  los  principales  atractivos  de  java  es  que  el
compilador no nos cuesta nada. Se encuentra disponible para bajarlo de
java.sun.com  para cualquiera  de las  plataformas mas  comunes en  el
mercado. </quote>

<quote> Veamos cómo  se generan programas básicos en  java mediante un
ejemplo. En  un editor escribimos  el siguiente código y  lo guardamos
con el nombre de fichero <tt/Prueba.java/. </quote>


<code>
// Ejemplo 1 de Java para CILA
// Fichero: HolaMundo.java

public class HolaMundo {
       public static void main(String[] argv){
	      System.out.println("Hola mundo");
}
}
</code>

<quote> Es de vital importancia que el nombre del fichero coincida con
lo  que  escribimos  despues  de  &quot;<tt/public  class/&quot;.  Así
mismo, Java  es un lenguaje  muy exigente  en materia de  mayúsculas y
minúsculas,  como de  de espacios  y tabuladores.  Para compilar  este
programa utilizamos el siguiente comando: </quote>

<code>
$ ls
HolaMundo.java

$ javac HolaMundo.java

$ ls
HolaMundo.java  HolaMundo.class

</code>

<quote>
Obtendremos un fichero con extension <tt/.class/ que es el
<em/bytecode/, el fichero que ejecutaremos con el siguiente comando:
</quote>

<code>
$ java HolaMundo
Hola Mundo
</code>

<quote>  Es importante  no  poner &quot;<tt/java  Prueba.class/&quot;,
pues no funcionaria, devolviendo el siguiente error:</quote>

<code>
$ java HolaMundo.class
Can't find class HolaMundo.class
</code>

<code>
$ java HolaMunco.class
Exception in thread "main" java.lang.NoClassDefFoundError: HolaMundo/java
</code>

<quote> Veamos ahora un ejemplo de <em/applet/. Tecleamos el siguiente
código y lo guardamos como <tt/HolaMundo2.java/. </quote>

<code>
// Ejemplo 2 de Java para CILA
// Fichero: HolaMundo2.java

import java.applet.Applet;
import java.awt.*;

public class HolaMundo2 extends Applet {
    public Button botonUno = new Button ("Hola Mundo");
    public void init() {
    add ( botonUno );
    }
}
</code>

<quote> Compilamos el applet del mismo modo que hicimos con el ejemplo
anterior: </quote>

<code>
$ javac HolaMundo.java
</code>

<quote>  Con  esto  generamos  el  fichero  <tt/HolaMundo2.class/  que
contiene  el applet.  Ahora necesitamos  una página  web que  carge el
applet.  Creamos  el  fichero <tt/HolaMundo2.html/  con  el  siguiente
código: </quote>

<code>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt; Ejemplo 2 de Java para CILA &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;
&lt;applet code=&quot;HolaMundo2.class&quot; width=&quot;300&quot; height=&quot;300&quot; &gt;&lt;/applet&gt;
&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>

<quote> Para  probar el applet  utilizaremos el método  que utilizaría
cualquier visitante, cargarlo  desde la página web que  hemos creado a
tal efecto. Esto lo hacemos con cualquier navegador que soporte, Java,
entre los que recomendamos Netscape. </quote>

<code>
$ netscape HolaMundo2.html
</code>

<quote> Veremos  como el applet  se ejecuta  dentro de la  página web.
Otra forma de  ejecutar un applet de Java, por  ejemplo cuando estamos
programando  y  sólo  deseamor  probarlo  pero  no  queremos  ejecutar
netscape, es el programa appletviewer que proporciona el JDK. </quote>

<code>
$ appletviewer HolaMundo2.html
</code>

<quote>  Podemos apreciar  la  diferencia entre  un <em/applet/,  cuya
ejecución está controlada por el navegador y se limita a la página web
desde el que es cargado, y una aplicación intependiente que se ejecuta
directamente en  la consola del  sistema sin más intermediario  que la
Máquina Virual Java. </quote>

</sect1>

    <sect1>Bash (Unix shell) 

<p>
<quote>En  capítulos  anteriores  hemos  visto  algunos  aspectos  del
intérprete de comandos (shell). Como en muchos otros casos la variedad
de intérpretes de comandos existente es muy amplia. Sin embargo existe
uno que ha destacado sobre los demás,  o al menos que ha sabido ocupar
el puesto de estándar de facto en el mundo GNU/Linux. Estamos hablando
del <tt/bash/  que suele ser  el intérprete de comandos  instalado por
defecto en nuestro sistema.</quote>

<quote>En general esto no desmerece en nada las posibilidades de otros
intérpretes de  comandos como  pueden ser el  <tt/tsh/ o  el <tt/ash/.
Todo  lo  contrario,  los  intérpretes  de  comandos  del  mundo  UNIX
presentan una  potencia sin igual,  en especial si los  comparamos con
sus equivalentes  en Microsoft&trade;  Windows&trade; (o sea  el viejo
<tt/COMMAND.COM/ o el nuevo <tt/CMD.EXE/).  Esto es natural si tenemos
en cuenta que por la consola  de los sistemas UNIX han pasado millones
de  profesionales que  han contribuido  con sus  comentarios o  con su
esfuerzo  a  que haya  ido  ganando  en potencia  a  lo  largo de  los
años.</quote>

<quote>En general  cada usuario  puede tener  su propio  intérprete de
comando,  pero  por sencillez,  y  puesto  que  es el  intérprete  por
defecto en muchos sistema  GNU/Linux, no centraremos exclusivamente en
el  <tt/bash/. En  realidad  ya  hemos pasado  por  un capítulo  donde
aprendimos los principios básicos del  uso del intérprete de comandos,
ahora se trata  de utilizarlo para generar pequeños  programas que nos
ayuden en el trabajo diario.</quote>

<quote>El <tt/bash/ no  sólo permite la ejecución  de las aplicaciones
instaladas en el  sistema; sino que proporciona una  serie de comandos
internos  así  como  estructuras   sintácticas  de  control  de  flujo
semejantes a las existentes en muchos lenguajes de programación (p.ej:
<tt/for/, <tt/case/, <tt/while/, <tt/until/).</quote>

      <sect2>Ficheros de comandos

<p>
<quote>Todos  estos recursos  pueden  ser utilizados  interactivamente
introduciendo  los comandos  directamente  desde la  consola. Esto  es
práctico para realizar tareas  sencillas. Sin embargo, para desarrollar
programas  extensos o  rutinas  ampliamente utilizadas  suele ser  más
interesante  escribir  nuestro  programa  en  un  archivo  a  modo  de
<em/script/.</quote>

<quote>En   este  último   caso  podemos   invocar  nuestro   programa
escribiendo el comandos:</quote>

  <code>
  $ bash prueba
  </code>

<quote>De esa manera  se iniciará la ejecución de una  nueva copia del
<tt/bash/  que  abrirá el  script  y  lo  ejecutará. En  los  sistemas
Linux  suele haber  un comando  llamado <tt/sh/.  Dicho comando  suele
corresponderse con  el intérprete de  comandos por defecto  de nuestro
sistema.  Por lo  tanto, podemos  sustituir <tt/bash/  por <tt/sh/  si
estamos seguros de que el  <tt/bash/ es nuestro intérprete por defecto
o  de  que  nuestro  script  utiliza  comandos  estándares  entre  los
diferentes  intérpretes disponibles.  Si  queremos  garantizar que  la
interpretación de nuestro script la realice el <tt/bash/ es conveniente
indicarlo explícitamente en lugar  de utilizar el <tt/sh/. Resumiendo,
podemos invocar nuestro programa de la siguiente manera:</quote>

  <code>
  $ sh prueba
  </code>

<quote>La verdad es  que resulta muchos más profesional  y sencillo si
nuestro script se  ejecuta de formar semejante a la  de cualquier otro
ejecutable.  Es  decir,  escribiendo  directamente  su  nombre  en  el
intérprete de  comandos. Para  ello sólo es  necesario que  la primera
línea de nuestro script sea así:</quote>

  <code>
  #!/bin/bash
  </code>

<quote>O sustituimos <tt/bash/  por <tt/sh/ si se  dan las condiciones
comentadas anteriormente. El  último paso es habilitar  los permisos de
ejecución y ya podemos utiliza nuestro script.</quote>

  <code>
  $ chmod u+x mi_programa
  $ ./mi_programa
  </code>

<quote>Cada línea de nuestro archivo contiene un comando a ejecutar
por nuestro intérprete. Si deseamos poner varios comandos en una
misma línea debemos usar <tt/&dquot;;&dquot;/ para separarlos. Por lo tanto
la siguiente secuencia de comandos:</quote>

  <code>
  who am I
  pwd
  date
  </code>

<quote>Es equivalente a:</quote>

  <code>
  who am I; pwd; date
  </code>

<quote>A la hora  de mostrar texto por pantalla se  utiliza el comando
<tt/echo/. Veamos el siguiente script:</quote>

<code>
#!/bin/sh
# whoami .- Ejemplo 1 para el CILA 2001.
 
echo Usted es:
who am I
echo Su directorio actual es:
pwd
echo La fecha de hoy:
date
</code>

<quote>Varios  son  los  elementos  nuevos que  podemos  ver  en  este
programa, a parte del uso del <tt/echo/:</quote>

<enum>

<item>Cuando  el  intérprete  encuentra  un <tt/"#"/  ignora  todo  el
contenido de la línea a partir de ese punto.

<item>El  comando  <tt/who/  muestra información  sobre  los  usuarios
autentificados en el sistema. Al añadir las opciones <tt/am I/ estamos
indicando  que  queremos  que  sólo muestre  información  referente  a
nosotros como usuarios.

<item>El comando <tt/pwd/ informa del directorio actual de trabajo.

<item>El  comando  <tt/date/  muestra  la fecha  y  hora  actual  del
sistema.

</enum>

<quote>En este  punto es  importante recordar que  todo lo  que veamos
aquí se cumple  tanto cuando trabajamos con ficheros  de comandos como
cuando trabajamos interactivamente desde la consola.</quote>

<quote>Existen una serie de variables predefinidas que contienen información
sobre la línea de comandos que se le ha pasado a nuestro script:</quote>

<table loc="hbtp">
<tabular ca="lll">
 Variable   |Contenido@
 <tt/$0/    |Nombre del fichero de comandos@
 <tt/$1-$9/ |Argumentos del 1º al 9º. El primero es $1, el segundo $2...@
 <tt/$*/    |Línea de comandos completa exceptuando $0@
</tabular>
<caption>Variables de la línea de comandos.</caption>
</table>

<quote>Veamos un ejemplo sencillo de lo anterior:</quote>

<code>
#!/bin/sh
# yorecuerdo .- Ejemplo 2 para el CILA 2001.

echo El comando es $0
echo El primer argumento es $1
echo El tercer argumento es $3
echo Todos los argumentos son $*
</code>

<quote>Al ejecutarlo obtenemos:</quote>

<code>
$ ./yorecuerdo A B C
El comando es ./yorecuerdo
El primer argumento es A
El tercer argumento es C
Todos los argumentos son A B C
</code>

      </sect2>

      <sect2>Variables de entorno

<p>
<quote>El intérprete  de comandos  permite la definición  de variables
que  puedan  ser  utilizadas  en  nuestros  script.  Algunas  de  esas
variables tienen  un significado  particular en nuestro  sistema. Para
conocer  las variables  actualmente  definidas  utilizamos el  comando
<tt/set/.</quote>

<quote>Si lo usásemos seguramente  veríamos variables como <tt/$HOME/,
que define nuestro directorio personal de usuario (la ruta ~/ tiene el
mismo significado), o <tt/$PATH/, que contiene la lista de directorios
por donde el  intérprete buscará los ejecutables  cuando le indiquemos
el nombre de alguno.</quote>

<quote>Definir  nuevas  variables es  tan  sencillo  como realizar  una
asignación:</quote>

  <code>
  $ EDAD=65;
  </code>

<quote>Mientras que acceder  a su valor se hace  precediendo al nombre
de la variable con el caracter <tt/$/.</quote>

  <code> $ echo Mi edad es $EDAD </code>

<quote>Toda variable definida en un <tt/bash/ es local a esa copia del
<tt/bash/ y por tanto invisible para el resto. Si tenemos en cuenta que
cada  vez que  ejecutamos  un  script se  inicia  un <tt/bash/  nuevo,
resulta evidente que todas las  variables definidas en el script serán
destruidas  cuando este  termine.  Además si  un  script ejecuta  otro
script, padre  e hijo no pueden  ver las variables del  otro. Para que
esté garantizado que una variable  pueda ser vista fuera del <tt/bash/
donde fue definida es necesario exportarla. </quote>

<code>
$ EDAD=65
$ export EDAD
</code>

<quote>A continuación vamos a añadir una nueva ruta al <tt/$PATH/:</quote>

<code>
$ PATH=$HOME/bin:$PATH
</code>

<quote>O a modificar nuestro prompt:</quote>

<code>
$ PS1='Le obedezco amo: '
</code>

<quote>Como  vemos hemos  puesto la  frase  entre comillas.  Si no  lo
hubiéramos hecho así obtendríamos un  error. Esto nos lleva a intentar
conocer algunos  caracteres que en  el entono del <tt/bash/  tienen un
significado especial.</quote>

      </sect2>

      <sect2>Metacaracteres

<p>
<quote>Para nuestro intérprete de comandos algunos caracteres tienen un
significado especial:</quote>

        <sect3>Sustitución: <tt/* ?/

<p>
<quote>El primero puede ser sustituido por un numero indeterminado
de cualquier combinación de caracteres. El segundo sólo representa
a <bf/un/ caracter cualquiera. Se explican por si mismos si vemos el
siguiente código de ejemplo en el que se listan todos lo archivos
del directorio actual:</quote>

  <code>
  $ echo Ingrese un *
  </code>

<quote>O todos los que empiecen por <tt/a/ y terminen por <tt/b/:</quote>
 
  <code>
  $ echo Ingrese un a*b
  </code>
  
<quote>O sencillamente todos los que empiecen por <tt/a/ y terminen
por <tt/b/ pero que sólo tengan tres letras:</quote>

  <code>
  $ echo Ingrese un a?b
  </code>

        </sect3>

	<sect3>Redirección: <tt/&gt; &gt;&gt; &lt; |/

<p>  <quote>Podemos volcar  la  salida  de un  comando  a un  archivo,
borrándolo y creándolo de nuevo si éste existe.</quote>

  <code>
  $ ls &gt; lista_archivos
  </code>

<quote>
O bien si preferimos añadir la salida del comando a un fichero ya existente,
</quote>

<code>
$ ls -al &gt;&gt; lista_archivos
</code>

<quote>Pasar dicha salida como entrada a otro comando:</quote>

  <code>
  $ ls | less
  </code>

<quote>O usar como entrada de un comando el contenido de un archivo:</quote>

  <code>
  $ less &lt; miarchivo
  </code>
	
        </sect3>

	<sect3>Ejecutar en segundo plano: <tt/&amp;/

<p>
<quote>Si al final de un comando añadimos &amp; este se ejecutará en
segundo plano. Es decir, el <tt/bash/ no esperará a que el comando
termine, permitiéndonos seguir ejecutando nuevos comandos mientras
este se ejecuta en paralelo. Evidentemente resulta muy práctico
cuando suponemos que un comando va ha llevar un tiempo de
de ejecución prolongado y nosotros deseamos poder seguir
utilizando el sistema.</quote>

        </sect3>

	<sect3>Separado de comando: <tt/;/

<p>
<quote>Como ya hemos visto, permite indicar varios comandos en una
misma línea.</quote>

        </sect3>

	<sect3>Continuación de línea
	
<p>
<quote>Permite dividir una línea en varias si por algún motivo no podemos
escribirla de una sola vez.</quote>

  <code>
  $ echo Quiero vivir en \
  &gt; canarias
  </code>

        </sect3>

	<sect3>Valor de una variable: <tt/$/

<p>
<quote>Como ya hemos visto, precede al nombre de una variable para
que el intérprete sepa que debe sustituir su valor.</quote>

        </sect3>

        <sect3>Otros: <tt/[ ] `/

<p> <quote>La segunda ejecuta el comando entre las comillas invertidas
(tildes  francesas) y  sustituye  la  cadena por  la  salida de  dicho
comando. Por ejemplo, si ejecutamos:</quote>

  <code>
  $ echo date
  date
  </code>

<quote>Pero si ejecutamos:</quote>

  <code>
  $ echo `date`
  mar oct 30 23:51:08 WET 2001
  </code>

<quote>Si  deseamos escribir  estos  metacaracteres  de forma  literal deben ir
precedidos de <tt/\/.</quote>

  <code>
  $ echo \* \\ \[
  * \ [
  </code>

<quote>También podemos  evitar la sustitución si  los escribimos entre
comillas simples o dobles:</quote>

  <code>
  $ echo &quot;Enviar $100?&quot;
  Enviar $100?

  $ echo &quot;`minombre` es dulce&quot;
  `minombre` es dulce
  </code>

<quote>La diferencia  entre las comillas  simples y las dobles  es que
las  segunda  eliminan todas  las  sustituciones  excepto las  de  los
metacaracteres <tt/$/ y <tt/`/.</quote>

        </sect3>

      </sect2>

      <sect2>Ficheros de comandos interactivos

<p>
<quote>A parte  de ejecutar  una secuencia predeterminada  de comandos
nuestros scripts  pueden ser interactivos.  Es decir solicitar  y leer
datos desde  la consola de  usuario. Para  ello se utiliza  el comando
<tt/read/ seguido por uno o más nombre de variables.</quote>

  <code>
  $ read NAME1 NAME2 NAME3
  $ echo $NAME1
  $ echo $NAME2
  $ echo $NAME3
  </code>

<quote>El  comando  <tt/read/  lee  desde la  entrada  estándar  hasta
encontrar  un espacio  y  almacena  lo leído  en  la primera  variable
indicada. A  continuación sigue leyendo  hasta el siguiente  espacio y
almacena la nueva  lectura en la segunda  variable. Así sucesivamente,
excepto que la última variable  siempre almacena desde el último punto
guardado en la variable anterior hasta el final de la línea. </quote>

      </sect2>

      <sect2>Control de flujo del programa

<p>
<quote>Al  igual  que  en  muchos  otros  lenguajes  de  programación,
disponemos de  sentencias de  control de  flujo del  programa. Algunos
ejemplos son: </quote>

<descrip>
<tag/<tt>if</tt>/<tt>if &lt;comando&gt;; then &lt;comando&gt;;
[ elif &lt;comando&gt;; then &lt;comando&gt;; ] ...
[ else &lt;comando&gt;; ] fi</tt>
<tag/<tt>while</tt>/<tt>while &lt;comando&gt;; do &lt;comando&gt;;
done</tt>
<tag/<tt>until</tt>/<tt>until &lt;comando&gt;; do &lt;comando&gt;;
done</tt>
</descrip>

<quote>La verificación  de la condición  para determinar el  flujo del
programa se realiza sobre el código de error devuelto por cada comando
o aplicación. Para  conocer las condiciones en las que  se devuelve un
código de  error u otro se  hace necesario consultar la  ayuda de cada
comando en particular.</quote>

<quote>Otras  sentencias son  <tt/case/  <tt/select/  y <tt/for/.  Una
forma interesante de esta última es:</quote>

<tt>for &lt;variable&gt; in &lt;lista&gt;; do comando; done</tt>

  <code>
  for a in pato gallo perro
  do
    echo yo tenía un $a
  done
  </code>

<quote>Este ejemplo puede parecer inútil pero es el paso previo a:
</quote>

  <code>
  for a in *
  do
    cat $a
  done
  </code>

<quote>El  cual  muestra   en  la  consola  todos   los  archivos  del
directorio. Otra de las característica  del lenguaje es la posibilidad
de crear funciones cuyo valor de retorno es el mismo que el del último
comando ejecutado:</quote>

  <code>
  function mifunc ()
  {
    echo La fecha de hoy:
    date
  }

  echo Veamos que hace esta función...
  mifunc
  </code>

<quote>En general el  <tt/bash/ es un programa  demasiado potente como
para poder  ser explicado en  unas pocas líneas. Probablemente  con lo
que  hemos  comentado  sea  posible  crear  nuestros  pequeños  script
para  automatizar algunas  tareas  tediosas, pero  en  caso de  querer
profundizar más lo mejor es recurrir  a la propia ayuda del intérprete
(<tt/man bash/). Un tema interesante a consulta es sobre el uso de los
archivos  <tt/.bash_profile/  y  <tt/.bashrc/  de  nuestro  directorio
personal, y sobre como usarlos para personalizar la consola.</quote>

      </sect2>

    </sect1>

  </sect>


